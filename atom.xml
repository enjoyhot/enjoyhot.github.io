<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ENJOYHOT</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://enjoyhot.github.io/"/>
  <updated>2017-04-30T09:53:32.592Z</updated>
  <id>http://enjoyhot.github.io/</id>
  
  <author>
    <name>enjoyhot</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Apache大数据组件</title>
    <link href="http://enjoyhot.github.io/2017/04/30/Apache%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%BB%84%E4%BB%B6/"/>
    <id>http://enjoyhot.github.io/2017/04/30/Apache大数据组件/</id>
    <published>2017-04-30T09:24:08.000Z</published>
    <updated>2017-04-30T09:53:32.592Z</updated>
    
    <content type="html">&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;大数据的处理模式大体可以分为批处理（也可称为离线计算）、流式计算（数据实时性高）、在线处理（即时响应）和交互式分析（允许分钟级）四种。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;大数据的4V属性&lt;br&gt;数量（Volume），多样性（Variety），速度（Velocity），真实性（Veracity）&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;HDFS&quot;&gt;&lt;a href=&quot;#HDFS&quot; class=&quot;headerlink&quot; title=&quot;HDFS&quot;&gt;&lt;/a&gt;HDFS&lt;/h1&gt;&lt;h2 id=&quot;组成组件&quot;&gt;&lt;a href=&quot;#组成组件&quot; class=&quot;headerlink&quot; title=&quot;组成组件&quot;&gt;&lt;/a&gt;组成组件&lt;/h2&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;HDFS是以master/slave模式运行的，其中NameNode、SecondaryNameNode 通常运行在master节点，DataNode运行slave节点。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;NameNode&lt;br&gt;  管理文件系统的Namespace，维护文件系统树以及树中所有文件和文件夹的元数据（metadata）；处理客户端请求。&lt;/li&gt;
&lt;li&gt;SecondaryNameNode&lt;br&gt;相当于一个Checkpoint Node，监控HDFS状态的辅助后台程序，与NameNode进行通信，以便定期地保存HDFS元数据的快照。&lt;/li&gt;
&lt;li&gt;DataNode&lt;br&gt;文件系统的工作节点，当需要通过客户端读/写某个数据时，先由NameNode告诉客户端去哪个DataNode进行具体的读/写操作，然后，客户端直接与这个DataNode服务器上的后台程序进行通信，并且对相关的数据块进行读/写操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;不同版本的比较&quot;&gt;&lt;a href=&quot;#不同版本的比较&quot; class=&quot;headerlink&quot; title=&quot;不同版本的比较&quot;&gt;&lt;/a&gt;不同版本的比较&lt;/h2&gt;&lt;h3 id=&quot;Hadoop-1-x&quot;&gt;&lt;a href=&quot;#Hadoop-1-x&quot; class=&quot;headerlink&quot; title=&quot;Hadoop 1.x&quot;&gt;&lt;/a&gt;Hadoop 1.x&lt;/h3&gt;&lt;h4 id=&quot;单点故障问题&quot;&gt;&lt;a href=&quot;#单点故障问题&quot; class=&quot;headerlink&quot; title=&quot;单点故障问题&quot;&gt;&lt;/a&gt;单点故障问题&lt;/h4&gt;&lt;p&gt;由于只有一个NameNode，因此会出现单点故障问题。有多种方式可以解决：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将hadoop元数据写入到本地文件系统的同时再实时同步到一个远程挂载的网络文件系统（NFS）（在2.X中同样适用）；&lt;/li&gt;
&lt;li&gt;运行一个secondaryNameNode进行冷备份，它的作用是与NameNode进行交互，定期将编辑日志文件(&lt;strong&gt;edit logs&lt;/strong&gt;)合并为命名空间镜像，当NameNode发生故障时它会通过自己合并的命名空间镜像副本来恢复。&lt;ul&gt;
&lt;li&gt;secondaryNameNode保存的状态总是滞后于NameNode，所以这种方式难免会导致丢失部分数据。&lt;/li&gt;
&lt;li&gt;NameNode中存放的元信息文件是fsimage，操作期间所有对元信息的操作都保存在内存中并被持久化到另一个文件edit logs中。edit logs文件和fsimage文件会被SecondaryNameNode周期性的合并。&lt;br&gt;注：&lt;a href=&quot;http://blog.csdn.net/xh16319/article/details/31375197&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.csdn.net/xh16319/article/details/31375197&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;fsimage ：保存的是上个检查点的HDFS的元信息；&lt;/li&gt;
&lt;li&gt;edits ：保存的是从上个检查点开始发生的HDFS元信息状态改变信息。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;按照HDFS的设计，NameNode不会主动发起任何请求，只会被动接受来自客户端或DataNode的请求。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;SecondaryNameNode&quot;&gt;&lt;a href=&quot;#SecondaryNameNode&quot; class=&quot;headerlink&quot; title=&quot;SecondaryNameNode&quot;&gt;&lt;/a&gt;SecondaryNameNode&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;合并流程：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先，secondaryNameNode定时到NameNode去获取edit logs，并更新到fsimage上。[笔者注：Secondary NameNode自己的fsimage]&lt;/li&gt;
&lt;li&gt;一旦它有了新的fsimage文件，它将其拷贝回NameNode中。&lt;/li&gt;
&lt;li&gt;NameNode在下次重启时会使用这个新的fsimage文件，从而减少重启的时间。&lt;/li&gt;
&lt;/ul&gt;
&lt;center&gt;&lt;br&gt;&lt;img src=&quot;http://www.processon.com/chart_image/535371590cf2bb589c5e2391.png&quot; alt=&quot;此处输入图片的描述&quot;&gt;&lt;br&gt;&lt;/center&gt;

&lt;h3 id=&quot;Hadoop-2-x&quot;&gt;&lt;a href=&quot;#Hadoop-2-x&quot; class=&quot;headerlink&quot; title=&quot;Hadoop 2.x&quot;&gt;&lt;/a&gt;Hadoop 2.x&lt;/h3&gt;&lt;h4 id=&quot;HA&quot;&gt;&lt;a href=&quot;#HA&quot; class=&quot;headerlink&quot; title=&quot;HA&quot;&gt;&lt;/a&gt;HA&lt;/h4&gt;&lt;p&gt;在2.X中，HDFS的变化，主要体现在增强了NameNode的水平扩展及可用性，可以同时部署多个NameNode，这些NameNodes之间是相互独立，也就是说他们不需要相互协调，DataNode同时在所有NameNodes注册，做为他们共有的存储节点，并定时向所有的这些NameNodes发送心跳块使用情况的报告，并处理所有NameNodes向其发送的指令。&lt;br&gt;多个NameNode之间共享数据，可以通过Nnetwork File System或者Quorum Journal Node。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;NFS方案；&lt;/li&gt;
&lt;li&gt;基于Paxos的QJM(Quorum Journal Node)方案，它的基本原理就是用2N+1台JournalNode存储EditLog，每次写数据操作有大多数（&amp;gt;=N+1）返回成功时即认为该次写成功。在HDFS运行时，同一时刻只有一个NameNode处于active状态，另一个处于standby状态。standbyNamenode作为“休眠方”，只进行数据同步，维护着数据状态，随时准备切换。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;附：HDFS中的沟通协议&lt;/strong&gt;&lt;/p&gt;
&lt;center&gt;&lt;br&gt;&lt;img src=&quot;http://www.ibigdata.io/wp-content/uploads/2016/08/HadoopProtocols.jpg&quot; alt=&quot;此处输入图片的描述&quot;&gt;&lt;br&gt;&lt;/center&gt;


&lt;h2 id=&quot;HDFS文件读写&quot;&gt;&lt;a href=&quot;#HDFS文件读写&quot; class=&quot;headerlink&quot; title=&quot;HDFS文件读写&quot;&gt;&lt;/a&gt;HDFS文件读写&lt;/h2&gt;&lt;h3 id=&quot;hdfs文件读取过程&quot;&gt;&lt;a href=&quot;#hdfs文件读取过程&quot; class=&quot;headerlink&quot; title=&quot;hdfs文件读取过程&quot;&gt;&lt;/a&gt;hdfs文件读取过程&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;客户端发起读请求；&lt;/li&gt;
&lt;li&gt;客户端与NameNode得到文件的块及位置信息列表；&lt;/li&gt;
&lt;li&gt;客户端直接和DataNoie交互读取数据；&lt;/li&gt;
&lt;li&gt;读取完成关闭连接；&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;hdfs文件写入过程&quot;&gt;&lt;a href=&quot;#hdfs文件写入过程&quot; class=&quot;headerlink&quot; title=&quot;hdfs文件写入过程&quot;&gt;&lt;/a&gt;hdfs文件写入过程&lt;/h3&gt;&lt;p&gt;hdfs有一个DistributedFileSystem实例，客户端通过调用这个实例的create()方法就可以创建文件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;DistributedFileSystem会发送给NameNode一个RPC调用，在文件系统的命名空间创建一个新文件，在创建文件前NameNode会做一些检查，如文件是否存在，客户端是否有创建权限等，若检查通过，NameNode会为创建文件写一条记录到本地磁盘的EditLog，若不通过会向客户端抛出IOException。创建成功之后DistributedFileSystem会返回一个FSDataOutputStream对象，客户端由此开始写入数据。&lt;/li&gt;
&lt;li&gt;客户端在向NameNode请求之前先写入文件数据到本地文件系统的一个临时文件；&lt;/li&gt;
&lt;li&gt;待临时文件达到&lt;strong&gt;块大小&lt;/strong&gt;时开始向NameNode请求DataNode信息；&lt;/li&gt;
&lt;li&gt;NameNode在文件系统中创建文件并&lt;strong&gt;返回给客户端&lt;/strong&gt;一个数据块及其对应DataNode的地址列表（列表中包含副本存放的地址）；&lt;/li&gt;
&lt;li&gt;客户端通过上一步得到的信息把创建临时文件块flush到列表中的第一个DataNode；&lt;/li&gt;
&lt;li&gt;当文件关闭，NameNode会提交这次文件创建，此时，文件在文件系统中可见。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;不适合的场景&quot;&gt;&lt;a href=&quot;#不适合的场景&quot; class=&quot;headerlink&quot; title=&quot;不适合的场景&quot;&gt;&lt;/a&gt;不适合的场景&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;大量小文件：文件的元数据(命名空间信息，块信息等)都存储在NameNode内存中，大量小文件会占用大量内存。&lt;/li&gt;
&lt;li&gt;低延迟数据访问：hdfs是专门针对高数据吞吐量而设计的&lt;/li&gt;
&lt;li&gt;多用户写入，任意修改文件，HDFS设计上是为了适合一次写入，多次使用&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;Kafka&quot;&gt;&lt;a href=&quot;#Kafka&quot; class=&quot;headerlink&quot; title=&quot;Kafka&quot;&gt;&lt;/a&gt;Kafka&lt;/h1&gt;&lt;h2 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;topic：消息存放的目录即主题&lt;/li&gt;
&lt;li&gt;Producer：生产消息到topic的一方&lt;/li&gt;
&lt;li&gt;Consumer：订阅topic消费消息的一方&lt;/li&gt;
&lt;li&gt;Broker：Kafka的服务实例就是一个broker&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;HA-1&quot;&gt;&lt;a href=&quot;#HA-1&quot; class=&quot;headerlink&quot; title=&quot;HA&quot;&gt;&lt;/a&gt;HA&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Partition分布在集群的每一台server上，而每一个Partition在集群中都可以有多个备份，这个备份数量是可配置的。&lt;/li&gt;
&lt;li&gt;每个Partition都有一个leader server，而其他备份的server都称为followers，只有leader服务器才会处理这个Partition上所有的读写请求，而其它followers则被动地复制leader上的数据。如果一个leader挂掉了，followers中的一个服务器则会自动升级为leader。同一个机器可以有多个Partition。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;应用场景&quot;&gt;&lt;a href=&quot;#应用场景&quot; class=&quot;headerlink&quot; title=&quot;应用场景&quot;&gt;&lt;/a&gt;应用场景&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Kafka基本应用图如下所示：&lt;/p&gt;
&lt;center&gt;&lt;br&gt;&lt;img src=&quot;http://img.blog.csdn.net/20170430174922678?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ3VndWd1amlhd2Vp/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;此处输入图片的描述&quot;&gt;&lt;br&gt;&lt;/center&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;使用场景&lt;br&gt;负责消费Partition的每个消费者都是一个消费进程，而且消费者本身也可以是多线程的应用程序，因为一个Partition只能属于一个消费者线程，所以存在如下几种不同的场景：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;线程数量多于Partition的数量，有部分线程无法消费该topic下任何一条消息&lt;/li&gt;
&lt;li&gt;线程数量少于Partition的数量，有一些线程会消费多个Partition的数据(这是最好的场景)&lt;/li&gt;
&lt;li&gt;线程数量等于Partition的数量，则正好一个线程消费一个Partition的数据&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;消费模式&quot;&gt;&lt;a href=&quot;#消费模式&quot; class=&quot;headerlink&quot; title=&quot;消费模式&quot;&gt;&lt;/a&gt;消费模式&lt;/h2&gt;&lt;p&gt;消息传递通常由两种模式，queuing（队列）和publish-subscribe （发布-订阅）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;queuing: 每个Consumer从消息队列中取走一个消息&lt;/li&gt;
&lt;li&gt;pub-scrib: 消息被广播到每个Consumer&lt;/li&gt;
&lt;/ul&gt;
&lt;center&gt;&lt;br&gt;&lt;img src=&quot;http://img.blog.csdn.net/20170430175031635?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ3VndWd1amlhd2Vp/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;此处输入图片的描述&quot;&gt;&lt;br&gt;&lt;/center&gt;

&lt;p&gt;实际上，kafka通过提供了一个对Consumer的抽象来同时实现这两种模式——ConsumerGroup。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;当同一个 Topic （一个producer一个topic）的 consumer 配置 group.id 相同时，即为 queue模式。否则用不同的group.id时，则以public-subscribe模式工作。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;消息顺序性&quot;&gt;&lt;a href=&quot;#消息顺序性&quot; class=&quot;headerlink&quot; title=&quot;消息顺序性&quot;&gt;&lt;/a&gt;消息顺序性&lt;/h2&gt;&lt;h3 id=&quot;Partition顺序性&quot;&gt;&lt;a href=&quot;#Partition顺序性&quot; class=&quot;headerlink&quot; title=&quot;Partition顺序性&quot;&gt;&lt;/a&gt;Partition顺序性&lt;/h3&gt;&lt;p&gt;消息在一个Partition中的顺序是有序的，但是Kafka只保证消息在一个Partition中有序，如果要想使整个topic中的消息有序，那么一个topic仅设置一个Partition即可，或者在producer端控制每个partition消息应有的顺序。&lt;/p&gt;
&lt;h3 id=&quot;Partition-Offset&quot;&gt;&lt;a href=&quot;#Partition-Offset&quot; class=&quot;headerlink&quot; title=&quot;Partition Offset&quot;&gt;&lt;/a&gt;Partition Offset&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;生产者的提交日志采用递增的offset连同消息内容一起写入到本地日志文件，生产者客户端本身不需要保存offset相关的状态。&lt;/li&gt;
&lt;li&gt;消费者进程则要保存消费消息的offset，因此它是有状态的，这样消费者才能将消息的消费进度保存到ZK或者其他存储系统中。在顺序读取过程中，通过offset记录每条日志对于每个组的当前消费进度。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;Rebalance&quot;&gt;&lt;a href=&quot;#Rebalance&quot; class=&quot;headerlink&quot; title=&quot;Rebalance&quot;&gt;&lt;/a&gt;Rebalance&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;一个消费组有多个消费者，因此消费组需要维护所有的消费者，如果一个消费者宕掉了，分配给这个消费者的Partition需要被重新分配给相同组的其他消费者；&lt;/li&gt;
&lt;li&gt;如果一个消费者加入了同一个组，之前分配给其他消费组的Partition需要分配给新加入的消费者。&lt;ul&gt;
&lt;li&gt;实际上一旦有消费者加入或退出消费组，导致消费组成员列表发生变化，即使Kafka集群的Partition没有变化，消费组中所有的消费者也都要触发重新rebalance的工作。当然如果集群的Partition发生变化，即使消费组成员没有变化，所有的消费者也都要重新rebalance。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;消费者消费消息&lt;/strong&gt;时需要&lt;strong&gt;定时&lt;/strong&gt;地将最新的消费进度保存到ZooKeeper中，当发生rebalance时，新的消费者拥有的新的Partition都可以从ZooKeeper中读取出来并恢复到最近的状态。&lt;center&gt;&lt;br&gt;&lt;img src=&quot;http://img.blog.csdn.net/20170430175114695?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ3VndWd1amlhd2Vp/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;此处输入图片的描述&quot;&gt;&lt;br&gt;&lt;/center&gt;

&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;Push-vs-Pull&quot;&gt;&lt;a href=&quot;#Push-vs-Pull&quot; class=&quot;headerlink&quot; title=&quot;Push vs Pull&quot;&gt;&lt;/a&gt;Push vs Pull&lt;/h2&gt;&lt;p&gt;kafka的consumer之所以没有采用push模式，是因为push模式很难适应消费者速率不同的消费者而且很难实现消息的回放功能，因为消息发送速率是由broker决定的。push模式的目标就是尽可能以最快速度传递消息，但是这样很容易造成consumer来不及处理消息，典型的表现就是拒绝服务以及网络拥塞，而pull模式则可以根据consumer的消费能力以适当的速率消费message。&lt;br&gt;&lt;a href=&quot;http://kafka.apache.org/documentation.html#design_pull&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://kafka.apache.org/documentation.html#design_pull&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;客户端API&quot;&gt;&lt;a href=&quot;#客户端API&quot; class=&quot;headerlink&quot; title=&quot;客户端API&quot;&gt;&lt;/a&gt;客户端API&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;在0.9.0版本中：This new unified consumer API removes the distinction between the 0.8 high-level and low-level consumer APIs。&lt;a href=&quot;https://kafka.apache.org/090/documentation.html#newconsumerapi。但还是可以用0.8之前的low&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://kafka.apache.org/090/documentation.html#newconsumerapi。但还是可以用0.8之前的low&lt;/a&gt; level API，在0.10之后则官方doc连low level提也不提。可见high level API将渐渐成为开发者唯一操作接口。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;Hight Level Consumer高级API提供了一个从Kafka消费数据的高层抽象，消费者客户端代码不需要管理offset的提交，并且采用了消费组的自动负载均衡功能，确保消费者的增减不会影响消息的消费；&lt;/li&gt;
&lt;li&gt;Low Level Consumer低级API通常针对特殊的消费逻辑（比如消费者只想要消费某些特定的Partition），低级API的客户端代码需要自己实现一些和Kafka服务端相关的底层逻辑，比如选择Partition的Leader，处理Leader的故障转移等。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;磁盘存储特点&quot;&gt;&lt;a href=&quot;#磁盘存储特点&quot; class=&quot;headerlink&quot; title=&quot;磁盘存储特点&quot;&gt;&lt;/a&gt;磁盘存储特点&lt;/h2&gt;&lt;p&gt;Kafka使用磁盘进行数据的存储，默认有效期为7天，而不是采用内存，主要好处有：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;磁盘缓存由Linux系统维护，减少了程序员的不少工作。&lt;/li&gt;
&lt;li&gt;磁盘顺序读写速度超过内存随机读写。&lt;/li&gt;
&lt;li&gt;JVM的GC效率低，内存占用大,使用磁盘可以避免这一问题。&lt;/li&gt;
&lt;li&gt;系统冷启动后，磁盘缓存依然可用。&lt;br&gt;&lt;a href=&quot;http://blog.csdn.net/endlu/article/details/51392905&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.csdn.net/endlu/article/details/51392905&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;zookeeper&quot;&gt;&lt;a href=&quot;#zookeeper&quot; class=&quot;headerlink&quot; title=&quot;zookeeper&quot;&gt;&lt;/a&gt;zookeeper&lt;/h1&gt;&lt;p&gt;ZooKeeper是以Fast Paxos算法为基础，实现同步服务，配置维护和命名服务等分布式应用。对于Zookeeper集群而言，设定有2n+1台server，只要有n+1台依然能运行，就可以使用，继续提供服务。&lt;/p&gt;
&lt;h2 id=&quot;配置&quot;&gt;&lt;a href=&quot;#配置&quot; class=&quot;headerlink&quot; title=&quot;配置&quot;&gt;&lt;/a&gt;配置&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;# 集群配置，3台机器，2888为Leader服务端口，3888为选举时所用的端口&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;server.1=cu01:2888:3888&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;server.2=cu02:2888:3888&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;server.3=cu03:2888:3888&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;数据模型&quot;&gt;&lt;a href=&quot;#数据模型&quot; class=&quot;headerlink&quot; title=&quot;数据模型&quot;&gt;&lt;/a&gt;数据模型&lt;/h2&gt;&lt;p&gt;zookeeper 会维护一个具有层次关系的数据结构，它非常类似于一个标准的文件系统：&lt;/p&gt;
&lt;center&gt;&lt;br&gt;&lt;img src=&quot;https://www.ibm.com/developerworks/cn/opensource/os-cn-zookeeper/image001.gif&quot; alt=&quot;此处输入图片的描述&quot;&gt;&lt;br&gt;&lt;/center&gt;

&lt;ul&gt;
&lt;li&gt;概念&lt;ul&gt;
&lt;li&gt;znode: 每个目录项称为znode;&lt;/li&gt;
&lt;li&gt;zookeeper 的客户端和服务器通信采用长连接方式，每个客户端和服务器通过心跳来保持连接，这个连接状态称为 session，如果 znode 是临时节点，这个 session 失效，znode 也就删除了；&lt;/li&gt;
&lt;li&gt;znode 是有版本的，每个znode中存储的数据可以有多个版本，也就是一个访问路径中可以存储多份数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;四种形式的目录节点(String create()的createMode选项)&lt;ul&gt;
&lt;li&gt;PERSISTENT：持久化目录节点，这个目录节点存储的数据不会丢失；&lt;/li&gt;
&lt;li&gt;PERSISTENT_SEQUENTIAL：顺序自动编号的目录节点，这种目录节点会根据当前已经存在的节点数自动加 1，然后返回给客户端已经成功创建的目录节点名；&lt;/li&gt;
&lt;li&gt;EPHEMERAL：临时目录节点，一旦创建这个节点的客户端与服务器端口也就是 session 超时，这种节点会被自动删除；&lt;/li&gt;
&lt;li&gt;EPHEMERAL_SEQUENTIAL：临时自动编号节点。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;zookeeper结构&quot;&gt;&lt;a href=&quot;#zookeeper结构&quot; class=&quot;headerlink&quot; title=&quot;zookeeper结构&quot;&gt;&lt;/a&gt;zookeeper结构&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;角色&lt;ul&gt;
&lt;li&gt;Leader&lt;br&gt;作为整个ZooKeeper集群的主节点，负责响应所有对ZooKeeper&lt;br&gt;&lt;strong&gt;状态变更的请求&lt;/strong&gt;。它会将每个状态更新请求进行排序和编号，以便保证整个集群内部消息处理的FIFO。&lt;/li&gt;
&lt;li&gt;Follower&lt;br&gt;响应本服务器上的读请求外，follower还要处理leader的提议，并在leader提交该提议时在本地也进行提交。leader和follower构成ZooKeeper集群的法定人数，也就是说，只有他们才参与新leader的选举、响应leader的提议。&lt;/li&gt;
&lt;li&gt;Observer&lt;br&gt;observer服务器用于提高读取的吞吐量。Observer和Follower比较相似，只有一些小区别：首先observer不属于法定人数，即不参加选举也不响应提议；其次是observer不需要将事务持久化到磁盘，一旦observer被重启，需要从leader重新同步整个名字空间。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;节点状态&lt;br&gt;每个集群中的节点都有一个状态LOOKING,FOLLOWING,LEADING,OBSERVING，每个节点启动的时候都是LOOKING状态，如果这个节点参与选举但最后不是leader，则状态是FOLLOWING，如果不参与选举则是OBSERVING，leader的状态是LEADING。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;选取Leader的过程&quot;&gt;&lt;a href=&quot;#选取Leader的过程&quot; class=&quot;headerlink&quot; title=&quot;选取Leader的过程&quot;&gt;&lt;/a&gt;选取Leader的过程&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;专有概念&lt;ul&gt;
&lt;li&gt;zxid：每个ZooKeeper服务器保存在磁盘的事务id,在初始阶段，每台服务器的这个值都是自己的id(高32位是epoch，低32位用于递增计数)；&lt;/li&gt;
&lt;li&gt;epoch：逻辑时钟的值，每次选举leader这个值会加1;用来标识leader关系是否改变，每次一个leader被选出来，它都会有一个新的epoch，标识当前属于那个leader的统治时期。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Zk的选举算法有两种&lt;br&gt;一种是基于basic paxos实现的,另外一种是基于fast paxos算法实现的。系统默认的选举算法为fast paxos。&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Basic paxos：&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;当前Server发起选举的线程担任选举线程，其主要功能是对投票结果进行统计，并选出推荐的Server；&lt;/li&gt;
&lt;li&gt;选举线程首先向所有Server发起一次询问(包括自己)；&lt;/li&gt;
&lt;li&gt;选举线程收到回复后，验证是否是自己发起的询问(验证zxid是否一致)，然后获取对方的id(myid)，并存储到当前&lt;strong&gt;询问对象列表&lt;/strong&gt;中，最后获取对方提议的leader相关信息(id,zxid)，并将这些信息存储到当次选举的&lt;strong&gt;投票记录表&lt;/strong&gt;中；&lt;/li&gt;
&lt;li&gt;收到&lt;strong&gt;所有Server&lt;/strong&gt;回复以后，就计算出zxid最大的那个Server，并将这个Server相关信息设置成下一次要投票的Server。在收集齐的过程中，可能有个别server网络好，就更新了自己要选的那个server；&lt;/li&gt;
&lt;li&gt;如果此时获胜的Server获得n/2+1的Server票数，&lt;strong&gt;设置当前推荐的leader为获胜的Server&lt;/strong&gt;，将根据获胜的Server相关信息设置自己的状态，否则，继续这个过程，直到leader被选举出来。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Fast Paxos：&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;每个Server会发出一个投票。初始情况，将自己作为Leader服务器来进行投票。每次投票包含的基本的元素包括：所推举的服务器的myid和ZXID,以(myid，ZXID)的形式来表示。因为是初始化阶段，因此无论是Server1还是Server2，都会投给自己，即Server1的投票为(1，0)，Server2的投票为(2,0)，然后各自将这个投票发给集群中其他所有机器。&lt;/li&gt;
&lt;li&gt;接收来自各个服务器的投票&lt;br&gt;每个服务器都会接收来自其他服务器的投票。集群中的每个服务器在接收到投票后，首先会判断该投票的有效性，包括检査是否是本轮投票、是否来自LOOKING 状态的服务器。&lt;/li&gt;
&lt;li&gt;处理投票&lt;br&gt;在接收到来自其他服务器的投票后，服务器都需要将别人的投票和自己的投票进行PK：&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;优先检査Epoch，Epoch高的作为Leader。&lt;/li&gt;
&lt;li&gt;在检査ZXID。ZXID比较大的服务器优先作为Leader。&lt;/li&gt;
&lt;li&gt;如果Epoch、ZXID相同的话，那么就比较myid。myid比较大的服务器作为Leader服务器。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;对于Server1来说，它自己的投票是(1，0)，而接收到的投票为(2,0)。首先会对比两者的Epoch，我们假设两个的Epoch相同，再比较ZXID，因为都是0,所以无法决定谁是Leader。接下来会对比两者的myid，很显然，Server1发现接收到的投票中的myid是2,大于自id，于是就会更新自己的投票为(2,0)，然后重新将投票发出去。而对于Server2来说，不需要更新自己的投票信息。&lt;/li&gt;
&lt;li&gt;统计投票。&lt;br&gt;毎次投票后，服务器都会统计所有投票，判断是否已经有过半的机器接收到相同的投票信息。有的话，&lt;strong&gt;设置当前推荐的leader为获胜的Server&lt;/strong&gt;，将根据获胜的Server相关信息设置自己的状态，否则，继续这个过程，直到leader被选举出来。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;选完leader以后，zk就进入状态同步过程。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;leader等待server连接；&lt;/li&gt;
&lt;li&gt;Follower连接leader，将&lt;strong&gt;最大的zxid&lt;/strong&gt;发送给leader；&lt;/li&gt;
&lt;li&gt;Leader根据follower的zxid确定同步点；&lt;/li&gt;
&lt;li&gt;完成同步后通知follower 已经成为uptodate状态；&lt;/li&gt;
&lt;li&gt;Follower收到uptodate消息后，又可以重新接受client的请求进行服务了。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;应用&quot;&gt;&lt;a href=&quot;#应用&quot; class=&quot;headerlink&quot; title=&quot;应用&quot;&gt;&lt;/a&gt;应用&lt;/h2&gt;&lt;p&gt;ZooKeeper主要是用来维护和监控一个目录节点树中存储的数据的状态，所有操作ZooKeeper和操作目录节点树大体一样，如&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;创建一个目录节点；&lt;/li&gt;
&lt;li&gt;给某个目录节点设置数据；&lt;/li&gt;
&lt;li&gt;获取某个目录节点的所有子目录节点；&lt;/li&gt;
&lt;li&gt;给某个目录节点设置权限和监控这个目录节点的状态变化。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Zookeeper 从设计模式角度来看，是一个基于观察者模式设计的分布式服务管理框架，然后接受观察者的注册，一旦这些数据的状态发生变化，Zookeeper就将负责通知已经在Zookeeper上注册的那些观察者做出相应的反应，从而实现集群中类似 Master/Slave 管理模式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;统一命名服务（Name Service）：分布式中统一命名；&lt;/li&gt;
&lt;li&gt;配置管理（Configuration Management）：软件运行中可动态修改配置；&lt;/li&gt;
&lt;li&gt;集群管理（Group Membership）：选出一个“总管”知道当前集群每台机器的服务状态，涉及zookeeper中Leader Election的功能；&lt;blockquote&gt;
&lt;p&gt;Zookeeper实现 Leader Election，也就是选出一个 Master Server。普通监听：每台 Server 创建一个 EPHEMERAL 目录节点，并&lt;strong&gt;调用父目录节点getChilden监听&lt;/strong&gt;，此时不同的是它还是一个SEQUENTIAL 目录节点，所以它是个 EPHEMERAL_SEQUENTIAL目录节点。之所以它是 EPHEMERAL_SEQUENTIAL 目录节点，是因为可以给每台 Server 编号，可以选择当前最小编号的 Server 为 Master，假如这个最小编号的 Server 死去，由于是 EPHEMERAL 节点，死去的 Server 对应的节点也被删除，所以当前的节点列表中又出现一个最小编号的节点，我们就选择这个节点为当前 Master。这样就实现了动态选择 Master，避免了传统意义上单 Master 容易出现单点故障的问题。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;共享锁：要获得锁的server创建EPHEMERAL_SEQUENTIAL目录节点，对父节点getChilden判断当前server编号是否是同级最小编号，是就获得了锁，释放就删除；&lt;/li&gt;
&lt;li&gt;创建同步队列（用得较少）：通过不断增加目录，增加时到没到数目，到了就创建一个监控标志位目录（xx/start），各个节点监听到有这个节点就触发监听程序，然后移除成员，不到就继续等待。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;HBase&quot;&gt;&lt;a href=&quot;#HBase&quot; class=&quot;headerlink&quot; title=&quot;HBase&quot;&gt;&lt;/a&gt;HBase&lt;/h1&gt;&lt;p&gt;(注：Zookeeper的引入使得Master不再是单点故障)&lt;/p&gt;
&lt;h2 id=&quot;HBase主要优点&quot;&gt;&lt;a href=&quot;#HBase主要优点&quot; class=&quot;headerlink&quot; title=&quot;HBase主要优点&quot;&gt;&lt;/a&gt;HBase主要优点&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;高效的储存空间利用率&lt;br&gt;传统的行式数据库由于每个列的长度不一，为了预防更新的时候不至于出现一行数据(没值的字段需要补值)跳到另一个block上去，所以往往会预留一些空间。而面向列的数据库由于一开始就完全为分析而存在，不需要考虑少量的更新问题，所以数据完全是密集储存的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;不可见索引&lt;br&gt;在已经读取了可能的数据块之后，对于类似age &amp;lt; 65或job=’Axx’的，列式数据库并不需要扫描完整个block，因为数据已经排序了。如果读到第一个age=66或者Job=‘Bxx’的时候就会停止扫描了。这相当与行式数据库索引里的范围扫描。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;压缩算法&lt;br&gt;列式数据库由于其每一列都是分开储存的。所以很容易针对每一列的特征运用不同的压缩算法。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;延迟物化&lt;br&gt;列式数据库由于其特殊的执行引擎，在数据中间过程运算的时候一般不需要解压数据而是以指针代替运算，直到最后需要输出完整的数据时才解压缩。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;列式数据库特点&quot;&gt;&lt;a href=&quot;#列式数据库特点&quot; class=&quot;headerlink&quot; title=&quot;列式数据库特点&quot;&gt;&lt;/a&gt;列式数据库特点&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;优点&lt;ul&gt;
&lt;li&gt;极高的装载速度（最高可以等于所有硬盘IO的总和，基本是极限了）&lt;/li&gt;
&lt;li&gt;适合大量的数据而不是小数据&lt;/li&gt;
&lt;li&gt;实时加载数据仅限于增加（删除和更新需要解压缩Block然后计算然后重新压缩储存）&lt;/li&gt;
&lt;li&gt;高效的压缩率，不仅节省储存空间也节省计算内存和CPU。&lt;/li&gt;
&lt;li&gt;非常适合做聚合操作。 　　&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;缺点&lt;ul&gt;
&lt;li&gt;不适合扫描小量数据&lt;/li&gt;
&lt;li&gt;不适合随机的更新&lt;/li&gt;
&lt;li&gt;批量更新情况各异，有的优化的比较好的列式数据库（比如Vertica）表现比较好，有些没有针对更新的数据库表现比较差。 不适合做含有删除和更新的实时操作&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;物理模型&quot;&gt;&lt;a href=&quot;#物理模型&quot; class=&quot;headerlink&quot; title=&quot;物理模型&quot;&gt;&lt;/a&gt;物理模型&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;每个column family存储在HDFS上的一个单独文件中，空值不会被保存；&lt;/li&gt;
&lt;li&gt;Table在行的方向上分割为多个Region，Region按大小分割的，每个表开始只有一个region，随着数据增多，region不断增大，当增大到一个阀值的时候，region就会等分会两个新region，之后会有越来越多的region；&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Region是Hbase中分布式存储和负载均衡的最小单元（最小存储单元是store——对应一个columnfamily），不同Region分布到不同RegionServer上。&lt;/p&gt;
&lt;center&gt;&lt;br&gt;&lt;img src=&quot;http://img.blog.csdn.net/20131226173700718?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd29zaGl3YW54aW4xMDIyMTM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;此处输入图片的描述&quot;&gt;&lt;br&gt;&lt;/center&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Master&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;为Region server分配region；&lt;/li&gt;
&lt;li&gt;负责Region server的负载均衡；&lt;/li&gt;
&lt;li&gt;发现失效的Region server并重新分配其上的region；&lt;/li&gt;
&lt;li&gt;管理用户对table的增删改查操作；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;因此，无Master过程中：&lt;ul&gt;
&lt;li&gt;数据读取仍照常进行；&lt;/li&gt;
&lt;li&gt;region切分、负载均衡等无法进行；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;HBase的compact&quot;&gt;&lt;a href=&quot;#HBase的compact&quot; class=&quot;headerlink&quot; title=&quot;HBase的compact&quot;&gt;&lt;/a&gt;HBase的compact&lt;/h2&gt;&lt;p&gt;HFile数量过多会降低读性能。为了避免对读性能的影响，可以对这些HFile(&lt;strong&gt;Store中的Storefile&lt;/strong&gt;)进行compact操作，把多个HFile合并成一个HFile。compact操作需要对HBase的数据进行多次的重新读写，因此这个过程会产生大量的IO。因此compact操作的本质就是以IO操作换取后续的读性能的提高。&lt;/p&gt;
&lt;p&gt;HBase的compact是针对HRegion的HStore进行操作的。compact操作分为major和minor两种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;major会把HStore所有的HFile都compact为一个HFile，并同时忽略标记为delete的KeyValue（被删除的KeyValue只有在compact过程中才真正被”删除”），可以想象major会产生大量的IO操作，对HBase的读写性能产生影响。&lt;/li&gt;
&lt;li&gt;minor则只&lt;strong&gt;会选择数个HFile文件&lt;/strong&gt;compact为一个HFile，minor的过程一般较快，而且IO相对较低。在日常任务时间，都会禁止major操作，只在空闲的时段定时执行。&lt;center&gt;&lt;br&gt;&lt;img src=&quot;http://img.blog.csdn.net/20131226173618000?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd29zaGl3YW54aW4xMDIyMTM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;此处输入图片的描述&quot;&gt;&lt;br&gt;&lt;/center&gt;

&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;读写性能讨论&quot;&gt;&lt;a href=&quot;#读写性能讨论&quot; class=&quot;headerlink&quot; title=&quot;读写性能讨论&quot;&gt;&lt;/a&gt;读写性能讨论&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;HBase的写入速度快是因为它其实并不是真的立即写入文件中，而是先写入内存，随后异步刷入HFile。所以在客户端看来，写入速度很快。另外，写入时候将随机写入转换成顺序写，数据写入速度也很稳定。因此，用户写操作只需要进入到内存即可立即返回，从而保证I/O高性能。&lt;/li&gt;
&lt;li&gt;读取速度快是因为它使用了LSM树型结构。LSM树原理把一棵大树拆分成N棵小树，它首先写入内存中，随着小树越来越大，内存中的小树会flush到磁盘中，磁盘中的树定期可以做merge操作，合并成一棵大树，以优化读性能。LSM树实际上是牺牲了部分读性能，用来大幅提高写性能。&lt;/li&gt;
&lt;li&gt;磁盘的顺序读取速度很快，但是相比而言，寻找磁道的速度就要慢很多。HBase的存储结构导致它需要磁盘寻道时间在可预测范围内，并且读取与所要查询的rowkey连续的任意数量的记录都不会引发额外的寻道开销。比如有5个存储文件，那么假设要到HFile中读取数据，最多需要5次磁盘寻道就可以。&lt;br&gt;HBase读取首先会在缓存（BlockCache）中查找，它采用了LRU（最近最少使用算法），如果缓存中没找到，会从内存中的MemStore中查找，只有这两个地方都找不到时，才会加载HFile中的内容。&lt;br&gt;在HFile中保存的内容是有序的，当数据写入HFile后，内存中的数据会被丢弃。HFile文件为磁盘顺序读取做了优化，按页存储。因此，读取HFile速度也会很快，因为节省了寻道开销。&lt;br&gt;而关系型数据库，即使有索引，也无法确定磁盘寻道次数。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;与zookeeper的关系&quot;&gt;&lt;a href=&quot;#与zookeeper的关系&quot; class=&quot;headerlink&quot; title=&quot;与zookeeper的关系&quot;&gt;&lt;/a&gt;与zookeeper的关系&lt;/h2&gt;&lt;p&gt;-ROOT-和.META.是HBase的两张内置表，从存储结构和操作方法的角度来说，它们和其他HBase的表没有任何区别，你可以认为这就是两张普通的表，对于普通表的操作对它们都适用。它们与众不同的地方是HBase用它们来存贮一个重要的系统信息——&lt;strong&gt;Region的分布情况&lt;/strong&gt;以及&lt;strong&gt;每个Region的详细信息&lt;/strong&gt;。&lt;/p&gt;
&lt;center&gt;&lt;br&gt;&lt;img src=&quot;http://img.blog.csdn.net/20131226174043000?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd29zaGl3YW54aW4xMDIyMTM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;此处输入图片的描述&quot;&gt;&lt;br&gt;&lt;/center&gt;

&lt;p&gt;参考：&lt;a href=&quot;http://blog.csdn.net/woshiwanxin102213/article/details/17584043&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.csdn.net/woshiwanxin102213/article/details/17584043&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;调优&quot;&gt;&lt;a href=&quot;#调优&quot; class=&quot;headerlink&quot; title=&quot;调优&quot;&gt;&lt;/a&gt;调优&lt;/h2&gt;&lt;p&gt;更多：&lt;a href=&quot;http://www.cnblogs.com/shitouer/archive/2012/08/07/2626377.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.cnblogs.com/shitouer/archive/2012/08/07/2626377.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;hbase中hfile（storefile）的默认最大值(hbase.hregion.max.filesize)是256MB，而google的bigtable论文中对tablet的最大值也推荐为100-200MB，这个大小有什么秘密呢？&lt;br&gt;　　众所周知hbase中数据一开始会写入memstore，当memstore满64MB以后，会flush到disk上而成为storefile。当storefile数量超过3时，会启动compaction过程将它们合并为一个storefile。这个过程中会删除一些timestamp过期的数据，比如update的数据。而当合并后的storefile大小大于hfile默认最大值时，会触发split动作，将它切分成两个region。&lt;br&gt;　　链接中作者声明进行了持续insert压力测试，并设置了不同的hbase.hregion.max.filesize，根据结果得到如下结论：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;值越小，平均吞吐量越大，但吞吐量越不稳定；&lt;/li&gt;
&lt;li&gt;值越大，平均吞吐量越小，吞吐量不稳定的时间相对更小。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;为什么会这样呢？推论如下：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当hbase.hregion.max.filesize较小时，触发split的机率更大，而split的时候会将region offline，因此在split结束的时间前，访问该region的请求将被block住，客户端自我block的时间默认为1s。当大量的region同时发生split时，系统的整体访问服务将大受影响。因此容易出现吞吐量及响应时间的不稳定现象&lt;/li&gt;
&lt;li&gt;当hbase.hregion.max.filesize比较大时，单个region中触发split的机率较小，大量region同时触发split的机率也较小，因此吞吐量较之小hfile尺寸更加稳定些。但是由于长期得不到split，因此同一个region内发生多次compaction的机会增加了。compaction的原理是将原有数据读一遍并重写一遍到hdfs上，然后再删除原有数据。无疑这种行为会降低以io为瓶颈的系统的速度，因此平均吞吐量会受到一些影响而下降。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;综合以上两种情况，hbase.hregion.max.filesize不宜过大或过小，256MB或许是一个更理想的经验参数。对于离线型的应用，调整为128MB会更加合适一些，而在线应用除非对split机制进行改造，否则不应该低于256MB。&lt;/p&gt;
&lt;h2 id=&quot;rowkey设计原则&quot;&gt;&lt;a href=&quot;#rowkey设计原则&quot; class=&quot;headerlink&quot; title=&quot;rowkey设计原则&quot;&gt;&lt;/a&gt;rowkey设计原则&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;长度原则&lt;br&gt;Rowkey的长度被很多开发者建议说设计在10~100个字节，不过建议是越短越好，不要超过16个字节。&lt;br&gt;原因如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据的持久化文件HFile中是按照KeyValue存储的，如果Rowkey过长比如100个字节，1000万列数据光Rowkey就要占用100*1000万=10亿个字节，将近1G数据，这会极大影响HFile的存储效率；&lt;/li&gt;
&lt;li&gt;MemStore将缓存部分数据到内存，如果Rowkey字段过长内存的有效利用率会降低，系统将无法缓存更多的数据，这会降低检索效率。因此Rowkey的字节长度越短越好。&lt;/li&gt;
&lt;li&gt;目前操作系统是都是64位系统，内存8字节对齐。控制在16个字节，8字节的整数倍利用操作系统的最佳特性。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;散列原则&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果Rowkey是按时间戳的方式递增，不要将时间放在二进制码的前面，建议将Rowkey的高位作为散列字段，由程序循环生成，低位放时间字段，这样将提高数据均衡分布在每个Regionserver实现负载均衡的几率。&lt;/li&gt;
&lt;li&gt;如果没有散列字段，首字段直接是时间信息将产生所有新数据都在一个 RegionServer上堆积的热点现象，这样在做数据检索的时候负载将会集中在个别RegionServer，降低查询效率。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;hbase-shell操作&quot;&gt;&lt;a href=&quot;#hbase-shell操作&quot; class=&quot;headerlink&quot; title=&quot;hbase shell操作&quot;&gt;&lt;/a&gt;hbase shell操作&lt;/h2&gt;&lt;h3 id=&quot;delete操作&quot;&gt;&lt;a href=&quot;#delete操作&quot; class=&quot;headerlink&quot; title=&quot;delete操作&quot;&gt;&lt;/a&gt;delete操作&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;每个记录有个保存于memstore的记录，在持久化前，记录新旧程度的”ts”&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;put &amp;apos;key&amp;apos;, &amp;apos;value&amp;apos;, ts=1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;put &amp;apos;key&amp;apos;, &amp;apos;value&amp;apos;, ts=2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;del &amp;apos;key&amp;apos;, &amp;apos;value&amp;apos;, ts=3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如上所示，进行两次put操作再加一次delete操作，合并后，就只有delete的操作了。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Hbase有一个TTL(time to live)，可以标识数据的有效期，比如，可以把TTL设置成86400*1000，也就是说数据将于1天后过期。这是一个表级的设置，必须在建表时指定。本质上也是利用ts(timestamp)进行比较，当前ts与put之后的ts进行比较，若大于TTL则删除。注意，ts可人工改，要谨慎，不然太大就表示该记录长时间有效，影响正常操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;创建表&quot;&gt;&lt;a href=&quot;#创建表&quot; class=&quot;headerlink&quot; title=&quot;创建表&quot;&gt;&lt;/a&gt;创建表&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;# create [tableName],[family1],&amp;lt;family2&amp;gt;,...,&amp;lt;familyN   &amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;create &amp;apos;t1&amp;apos;,&amp;apos;f1&amp;apos;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;添加数据&quot;&gt;&lt;a href=&quot;#添加数据&quot; class=&quot;headerlink&quot; title=&quot;添加数据&quot;&gt;&lt;/a&gt;添加数据&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;put &amp;lt;table&amp;gt;,&amp;lt;rowkey&amp;gt;,&amp;lt;family:column&amp;gt;,&amp;lt;value&amp;gt;,&amp;lt;timestamp&amp;gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;e.g.&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;hbase(main):003:0&amp;gt; put &amp;apos;t1&amp;apos;,&amp;apos;rowkey001&amp;apos;,&amp;apos;f1:col1&amp;apos;,&amp;apos;value01&amp;apos;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;查找数据&quot;&gt;&lt;a href=&quot;#查找数据&quot; class=&quot;headerlink&quot; title=&quot;查找数据&quot;&gt;&lt;/a&gt;查找数据&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;get &amp;lt;table&amp;gt;,&amp;lt;rowkey&amp;gt;,[&amp;lt;family:column&amp;gt;,....]&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;e.g.&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;hbase(main)&amp;gt; get &amp;apos;t1&amp;apos;,&amp;apos;rowkey001&amp;apos;, &amp;apos;f1:col1&amp;apos;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;扫描表数据&quot;&gt;&lt;a href=&quot;#扫描表数据&quot; class=&quot;headerlink&quot; title=&quot;扫描表数据&quot;&gt;&lt;/a&gt;扫描表数据&lt;/h3&gt;&lt;p&gt;如下，获取前五条rowkey相对应的数据：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;hbase(main):017:0&amp;gt; scan &amp;apos;FeatureIndex0.01_v2&amp;apos;,&amp;#123;LIMIT=&amp;gt;5&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;ROW                                              COLUMN+CELL&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; 0@1|0@0                                         column=label:avg, timestamp=1483110072314, value=0.0554465387563&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; 0@1|0@0                                         column=label:stddev, timestamp=1483110072314, value=0.228849788944&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; 0@1|0@0                                         column=label:sum, timestamp=1483110072314, value=500383.0&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; 0@1|0@1                                         column=label:avg, timestamp=1483110072312, value=0.0510849704785&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; 0@1|0@1                                         column=label:stddev, timestamp=1483110072312, value=0.220171615499&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; 0@1|0@1                                         column=label:sum, timestamp=1483110072312, value=10149.0&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; 0@1|1@0                                         column=label:avg, timestamp=1483110072323, value=0.0442181954694&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; 0@1|1@0                                         column=label:stddev, timestamp=1483110072323, value=0.20557989582&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; 0@1|1@0                                         column=label:sum, timestamp=1483110072323, value=12721.0&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; 100@101|0@0                                     column=label:avg, timestamp=1483110244726, value=0.0549538811079&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; 100@101|0@0                                     column=label:stddev, timestamp=1483110244726, value=0.227890231369&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; 100@101|0@0                                     column=label:sum, timestamp=1483110244726, value=519447.0&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; 100@101|0@1                                     column=label:avg, timestamp=1483110244726, value=0.061603404489&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; 100@101|0@1                                     column=label:stddev, timestamp=1483110244726, value=0.240437952631&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; 100@101|0@1                                     column=label:sum, timestamp=1483110244726, value=1795.0&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5 row(s) in 0.1300 seconds&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;删除表&quot;&gt;&lt;a href=&quot;#删除表&quot; class=&quot;headerlink&quot; title=&quot;删除表&quot;&gt;&lt;/a&gt;删除表&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;truncate &amp;lt;table&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;# 其具体过程是：disable table -&amp;gt; drop table -&amp;gt; create table&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h1 id=&quot;Lambda架构&quot;&gt;&lt;a href=&quot;#Lambda架构&quot; class=&quot;headerlink&quot; title=&quot;Lambda架构&quot;&gt;&lt;/a&gt;Lambda架构&lt;/h1&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;batch view = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;all data&lt;/span&gt;)&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;realtime&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;view&lt;/span&gt; = &lt;span class=&quot;title&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;realtime view, new data&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;query&lt;/span&gt; = &lt;span class=&quot;title&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;batch view, realtime view&lt;/span&gt;)&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;batchview = function(all data)；&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;query = function(batch view)。&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;大数据的处理模式大体可以分为批处理（也可称为离线计算）、流式计算（数据实时性高）、在线处理（即时响应）和交互式分析（允许分钟级）四种。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;大数据的4V属性&lt;br&gt;数量（Volume），多样性（Variety），速度（Velocity），真实性（Veracity）&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;HDFS&quot;&gt;&lt;a href=&quot;#HDFS&quot; class=&quot;headerlink&quot; title=&quot;HDFS&quot;&gt;&lt;/a&gt;HDFS&lt;/h1&gt;&lt;h2 id=&quot;组成组件&quot;&gt;&lt;a href=&quot;#组成组件&quot; class=&quot;headerlink&quot; title=&quot;组成组件&quot;&gt;&lt;/a&gt;组成组件&lt;/h2&gt;
    
    </summary>
    
      <category term="分布式" scheme="http://enjoyhot.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="分布式" scheme="http://enjoyhot.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="Apache" scheme="http://enjoyhot.github.io/tags/Apache/"/>
    
  </entry>
  
  <entry>
    <title>Spark计算平台</title>
    <link href="http://enjoyhot.github.io/2017/04/30/Spark%E8%AE%A1%E7%AE%97%E5%B9%B3%E5%8F%B0/"/>
    <id>http://enjoyhot.github.io/2017/04/30/Spark计算平台/</id>
    <published>2017-04-30T09:23:09.000Z</published>
    <updated>2017-04-30T09:29:40.176Z</updated>
    
    <content type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;h2 id=&quot;官方文档&quot;&gt;&lt;a href=&quot;#官方文档&quot; class=&quot;headerlink&quot; title=&quot;官方文档&quot;&gt;&lt;/a&gt;官方文档&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://spark.apache.org/docs/latest/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Spark doc&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;相关平台&quot;&gt;&lt;a href=&quot;#相关平台&quot; class=&quot;headerlink&quot; title=&quot;相关平台&quot;&gt;&lt;/a&gt;相关平台&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://databricks.com/blog&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;databricks blog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://gitter.im/spark-scala/Lobby&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;A place to discuss and ask questions about using Scala for Spark programming&lt;/a&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/SPARK/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Spark jira&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://sparkhub.databricks.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;SPARKHUB&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;学习文档&quot;&gt;&lt;a href=&quot;#学习文档&quot; class=&quot;headerlink&quot; title=&quot;学习文档&quot;&gt;&lt;/a&gt;学习文档&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/JerryLead/SparkInternals/tree/master/markdown&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Spark Internals&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/lw-lin/CoolplaySpark&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;CoolplaySpark&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;注：&lt;/em&gt;&lt;/strong&gt; &lt;em&gt;Spark更新较快，具体操作查看&lt;a href=&quot;http://spark.apache.org/docs/latest/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;官网doc&lt;/a&gt;可能更详细&lt;/em&gt;。&lt;/p&gt;
&lt;h1 id=&quot;架构&quot;&gt;&lt;a href=&quot;#架构&quot; class=&quot;headerlink&quot; title=&quot;架构&quot;&gt;&lt;/a&gt;架构&lt;/h1&gt;&lt;h2 id=&quot;集群基础图&quot;&gt;&lt;a href=&quot;#集群基础图&quot; class=&quot;headerlink&quot; title=&quot;集群基础图&quot;&gt;&lt;/a&gt;集群基础图&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;来自官网说明的集群结构&lt;br&gt;&lt;a href=&quot;http://spark.apache.org/docs/latest/cluster-overview.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://spark.apache.org/docs/latest/cluster-overview.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;Spark applications run as independent sets of processes on a cluster, coordinated by the SparkContext object in your main program (called the driver program).&lt;br&gt;Specifically, to run on a cluster, the SparkContext can connect to several types of cluster managers (either Spark’s own standalone cluster manager, Mesos or YARN), which allocate resources across applications. Once connected, Spark acquires executors on nodes in the cluster, which are processes that run computations and store data for your application. Next, it sends your application code (defined by JAR or Python files passed to SparkContext) to the executors. Finally, SparkContext sends tasks to the executors to run.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;由此可知：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Spark说到底就是集群中的一系列由SparkContext协调的进程，而SparkContext对象驻留在driver程序中；&lt;/li&gt;
&lt;li&gt;SparkContext作为driver程序中最重要的部分，需要连接到cluster manager从而获取资源的分配，资源主要是executor（一种计算资源的抽象，可以理解为进程资源）；&lt;/li&gt;
&lt;li&gt;当你运行Spark程序后，将通过SparkContext提交代码到executor中，并在之后SparkContext通过某种方式指定具体的task分配到executor中运行。&lt;/li&gt;
&lt;/ul&gt;
&lt;center&gt;&lt;br&gt;&lt;img src=&quot;http://spark.apache.org/docs/latest/img/cluster-overview.png&quot; alt=&quot;此处输入图片的描述&quot;&gt;&lt;br&gt;&lt;/center&gt;

&lt;h2 id=&quot;相关组件说明&quot;&gt;&lt;a href=&quot;#相关组件说明&quot; class=&quot;headerlink&quot; title=&quot;相关组件说明&quot;&gt;&lt;/a&gt;相关组件说明&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Driver Program：请求Executor启动Task等，数据归约操作收集端；&lt;/li&gt;
&lt;li&gt;Cluster Manager：standalone 集群管理器或 Mesos/YARN&lt;/li&gt;
&lt;li&gt;Worker Node：一台机器默认一个worker (&lt;strong&gt;multi only for standalone&lt;/strong&gt;)&lt;/li&gt;
&lt;li&gt;Executor Process : 默认一个worker节点的一个JVM实例，服务于单个spark app，执行 Task任务，一个worker可以有多个executor实例，对于yarn而言，可通过–num-executors加以设置，对于standalone而言，可通过–total-executer-cores和–executor-cores结合设置；&lt;br&gt;一个Spark app可以有多个job（action），一个job可以有多个stage（shuffle data）,一个stage可以有多个task（partition, 开发者视角）；&lt;/li&gt;
&lt;li&gt;DAGScheduler：根据Job构建基于Stage的DAG，并提交Stage给TaskScheduler；&lt;/li&gt;
&lt;li&gt;TaskScheduler：将Taskset提交给Worker node 集群运行并返回结果,一个应用对应一个TaskScheduler；&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;启动程序&quot;&gt;&lt;a href=&quot;#启动程序&quot; class=&quot;headerlink&quot; title=&quot;启动程序&quot;&gt;&lt;/a&gt;启动程序&lt;/h2&gt;&lt;h2 id=&quot;运行模式&quot;&gt;&lt;a href=&quot;#运行模式&quot; class=&quot;headerlink&quot; title=&quot;运行模式&quot;&gt;&lt;/a&gt;运行模式&lt;/h2&gt;&lt;p&gt;Spark的运行模式取决于传递给SparkContext的MASTER环境变量的值。master URL可以是以下任一种形式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;local 使用一个Worker线程本地化运行SPARK&lt;ul&gt;
&lt;li&gt;local[*]使用逻辑CPU个数数量的线程来本地化运行Spark&lt;/li&gt;
&lt;li&gt;local[K]使用K个Worker线程本地化运行Spark（理想情况下，K应该根据运行机器的CPU逻辑核数设定）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;standalone&lt;br&gt;官方自己开发的集群模式，地址为spark://HOST:PORT，连接到指定的Spark standalone master。默认端口是7077。利用该模式不能解决单点故障问题，可以使用zookeeper解决该问题。&lt;/li&gt;
&lt;li&gt;yarn&lt;ul&gt;
&lt;li&gt;yarn-client以客户端模式连接YARN集群。&lt;/li&gt;
&lt;li&gt;yarn-cluster 以集群模式连接YARN集群。集群的位置可以在HADOOP_CONF_DIR 环境变量中找到，默认Hadoop namenode 8088端口。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;mesos&lt;br&gt;mesos://HOST:PORT 连接到指定的Mesos集群。默认接口是5050.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;运行方式&quot;&gt;&lt;a href=&quot;#运行方式&quot; class=&quot;headerlink&quot; title=&quot;运行方式&quot;&gt;&lt;/a&gt;运行方式&lt;/h2&gt;&lt;p&gt;&lt;em&gt;该部分查看Spark2.1源码入口程序而知，以后更新版本可能会有所改变不得而知。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Spark程序运行包括交互式运行(除spark-submit和restful api的形式)和脚本提交。以下从交互式方式说起。&lt;/p&gt;
&lt;h3 id=&quot;程序提交&quot;&gt;&lt;a href=&quot;#程序提交&quot; class=&quot;headerlink&quot; title=&quot;程序提交&quot;&gt;&lt;/a&gt;程序提交&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;spark-shell&lt;br&gt;  bash脚本启动交互式scala环境，脚本内部执行main函数，调用spark-submit脚本，指定java程序的中main入口，比如：&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&amp;quot;$&amp;#123;SPARK_HOME&amp;#125;&amp;quot;/bin/spark-submit --class org.apache.spark.repl.Main --name &amp;quot;Spark shell&amp;quot; &amp;quot;$@&amp;quot;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;$@&lt;/strong&gt; 是脚本运行时带的所有参数&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;pyspark&lt;br&gt;  bash脚本启动交互式python环境，脚本内部执行main函数，调用spark-submit脚本，指定java程序的中main入口，比如：&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;exec &amp;quot;$&amp;#123;SPARK_HOME&amp;#125;&amp;quot;/bin/spark-submit pyspark-shell-main --name &amp;quot;PySparkShell&amp;quot; &amp;quot;$@&amp;quot;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;spark-submit探讨&quot;&gt;&lt;a href=&quot;#spark-submit探讨&quot; class=&quot;headerlink&quot; title=&quot;spark-submit探讨&quot;&gt;&lt;/a&gt;spark-submit探讨&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;脚本说明&lt;br&gt;&lt;a href=&quot;https://github.com/apache/spark/blob/branch-2.1/bin/spark-submit&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;程序&lt;/a&gt;很简单，将接收参数转到spark-class脚本的第二个参数。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;exec &amp;quot;$&amp;#123;SPARK_HOME&amp;#125;&amp;quot;/bin/spark-class org.apache.spark.deploy.SparkSubmit &amp;quot;$@&amp;quot;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;spark-class&lt;br&gt;&lt;a href=&quot;https://github.com/apache/spark/blob/branch-2.1/bin/spark-class&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;spark-class&lt;/a&gt;是所有提交程序的入口，代码相比另外的脚本复杂一些，归根到底执行一条命令，通过后面解释可知道，该命令执行scala程序：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;exec &amp;quot;$&amp;#123;CMD[@]&amp;#125;&amp;quot;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;CMD变量的构造关键在这里(调用java程序生成命令行字符串)：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;build_command() &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;quot;$RUNNER&amp;quot; -Xmx128m -cp &amp;quot;$LAUNCH_CLASSPATH&amp;quot; org.apache.spark.launcher.Main &amp;quot;$@&amp;quot;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  printf &amp;quot;%d\0&amp;quot; $?&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;CMD=()&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;while IFS= read -d &amp;apos;&amp;apos; -r ARG; do&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  CMD+=(&amp;quot;$ARG&amp;quot;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;done &amp;lt; &amp;lt;(build_command &amp;quot;$@&amp;quot;)&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/apache/spark/blob/branch-2.1/bin/spark-class#L26-L36&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;$RUNNER&lt;/a&gt;是本地机器java的地址。因此，我们可以知道，整个交互式的spark程序的入口程序类似如下语法：&lt;br&gt;&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;exec (java -Xmx128m -cp xxx org.apache.spark.launcher.Main “org.apache.spark.deploy.SparkSubmit&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;+ pyspark-shell-main --name &quot;PySparkShell&quot; &quot;$@&quot;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;(或 --class org.apache.spark.repl.Main --name &quot;Spark shell&quot; &quot;$@&quot;)”)&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;对于单纯spark-submit的脚本提交方式，只是&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;org.apache.spark.deploy.SparkSubmit&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;后面带的参数不同而已。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;org.apache.spark.launcher.Main&lt;br&gt;该 &lt;a href=&quot;https://github.com/apache/spark/blob/branch-2.1/launcher/src/main/java/org/apache/spark/launcher/Main.java&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Java入口程序&lt;/a&gt; 将输出以’\0’分割的字符串命令&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;org.apache.spark.deploy.SparkSubmit&lt;br&gt;scala程序，真正的 &lt;a href=&quot;https://github.com/apache/spark/blob/branch-2.1/core/src/main/scala/org/apache/spark/deploy/SparkSubmit.scala&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;spark入口&lt;/a&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;提交Spark应用&quot;&gt;&lt;a href=&quot;#提交Spark应用&quot; class=&quot;headerlink&quot; title=&quot;提交Spark应用&quot;&gt;&lt;/a&gt;提交Spark应用&lt;/h2&gt;&lt;p&gt;对于交互式的传给你下，会在启动的时候自动构建SparkContext，名称为sc。其它方式由开发者新建SparkContext对象。&lt;/p&gt;
&lt;h1 id=&quot;基本操作&quot;&gt;&lt;a href=&quot;#基本操作&quot; class=&quot;headerlink&quot; title=&quot;基本操作&quot;&gt;&lt;/a&gt;基本操作&lt;/h1&gt;&lt;h2 id=&quot;程序提交-1&quot;&gt;&lt;a href=&quot;#程序提交-1&quot; class=&quot;headerlink&quot; title=&quot;程序提交&quot;&gt;&lt;/a&gt;程序提交&lt;/h2&gt;&lt;h3 id=&quot;主要方式&quot;&gt;&lt;a href=&quot;#主要方式&quot; class=&quot;headerlink&quot; title=&quot;主要方式&quot;&gt;&lt;/a&gt;主要方式&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;官方方式&lt;ul&gt;
&lt;li&gt;命令行&lt;/li&gt;
&lt;li&gt;REST API&lt;/li&gt;
&lt;li&gt;SparkLauncher类接口&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;相关&lt;a href=&quot;https://spark.apache.org/third-party-projects.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;第三方工具&lt;/a&gt;：&lt;ul&gt;
&lt;li&gt;Spark-jobserver&lt;/li&gt;
&lt;li&gt;Livy&lt;/li&gt;
&lt;li&gt;Oozie&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;使用Spark&quot;&gt;&lt;a href=&quot;#使用Spark&quot; class=&quot;headerlink&quot; title=&quot;使用Spark&quot;&gt;&lt;/a&gt;使用Spark&lt;/h2&gt;&lt;h3 id=&quot;Pyspark&quot;&gt;&lt;a href=&quot;#Pyspark&quot; class=&quot;headerlink&quot; title=&quot;Pyspark&quot;&gt;&lt;/a&gt;Pyspark&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;./spark/bin$ ./pyspark --executor-memory 4G --total-executor-cores 80&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;例子:&lt;/strong&gt;&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;./spark/bin/pyspark --executor-memory 4G --total-executor-cores 20 --packages com.databricks:spark-csv_2.10:1.4.0&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;./spark/bin/spark-shell --executor-memory 4G --total-executor-cores 20 --packages com.databricks:spark-csv_2.10:1.4.0&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;说明：&lt;/strong&gt;&lt;br&gt;通过添加packages，可以使一下转换操作合法，paquet转换为csv格式：&lt;br&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;row_1000_df.write.format(&lt;span class=&quot;string&quot;&gt;&quot;com.databricks.spark.csv&quot;&lt;/span&gt;).save(filepath)&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;Submit&quot;&gt;&lt;a href=&quot;#Submit&quot; class=&quot;headerlink&quot; title=&quot;Submit&quot;&gt;&lt;/a&gt;Submit&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;例子:&lt;/strong&gt;&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;./spark/bin/spark-submit --executor-memory 4G --total-executor-cores 80 --py-files loadDataSetSpark.py mainSpark.py&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;Launcher&quot;&gt;&lt;a href=&quot;#Launcher&quot; class=&quot;headerlink&quot; title=&quot;Launcher&quot;&gt;&lt;/a&gt;Launcher&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;例子:&lt;/strong&gt;&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;Map&amp;lt;String, String&amp;gt; env = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; HashMap&amp;lt;String,String&amp;gt;();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;env.put(&lt;span class=&quot;string&quot;&gt;&quot;SPARK_PRINT_LAUNCH_COMMAND&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;1&quot;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Process spark  = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; SparkLauncher(env)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    .setAppResource(&lt;span class=&quot;string&quot;&gt;&quot;file:/data/home/gujw/projects/spark/jar_test/SparkDataSet-0.0.1-SNAPSHOT.jar&quot;&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    .setMainClass(&lt;span class=&quot;string&quot;&gt;&quot;com.SparkMain&quot;&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    .setConf(&lt;span class=&quot;string&quot;&gt;&quot;spark.cores.max&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;20&quot;&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    .addSparkArg(&lt;span class=&quot;string&quot;&gt;&quot;--verbose&quot;&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    .setMaster(&lt;span class=&quot;string&quot;&gt;&quot;spark://192.168.0.11:7077&quot;&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    .setConf(&lt;span class=&quot;string&quot;&gt;&quot;spark.dynamicAllocation.enabled&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;true&quot;&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    .setConf(SparkLauncher.DRIVER_MEMORY, &lt;span class=&quot;string&quot;&gt;&quot;2g&quot;&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    .setVerbose(&lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    .launch();&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&quot;认识RDD&quot;&gt;&lt;a href=&quot;#认识RDD&quot; class=&quot;headerlink&quot; title=&quot;认识RDD&quot;&gt;&lt;/a&gt;认识RDD&lt;/h2&gt;&lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;RDD：弹性分布式数据集，表示分布在多个计算节点上可以并行操作的元素集合。&lt;/li&gt;
&lt;li&gt;操作：转化操作（transformation，以是否shuffle定stage的边界）和行动操作（action，决定了job的划分），可通过返回值区别，转化操作返回RDD类型，行动操作为其它类型。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如以下lines就是一个RDD：&lt;br&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;lines = sc.parallelize([&lt;span class=&quot;string&quot;&gt;&#39;pandas&#39;&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&#39;i like pandas&#39;&lt;/span&gt;])&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;lines = sc.textFile(&lt;span class=&quot;string&quot;&gt;&#39;readme.md&#39;&lt;/span&gt;)&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;lines是Spark的RDD，第二行的lines包含了在哪些机器上有file文件的块，信息是从HDFS加载而来。每文件块映射到RDD上就是一个分区。如果一个文件块128MB（默认），那么HDFS上一个1GB大小的文件就有8个文件块，由这个文件创建的RDD就会有8个分区。&lt;br&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 能把这个RDD缓存，降低action计算的成本（因为每次新的action操作都要重新计算一次），对应的就有RDD.unpersist()，当内存吃紧时可以用&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# persist(storageLevel=StorageLevel(False, True, False, False, 1))&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;RDD.persist()&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# Persist this RDD with the default storage level (MEMORY_ONLY_SER).&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;RDD.cache()&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;RDD操作流程示例&quot;&gt;&lt;a href=&quot;#RDD操作流程示例&quot; class=&quot;headerlink&quot; title=&quot;RDD操作流程示例&quot;&gt;&lt;/a&gt;RDD操作流程示例&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;lines_data = sc.textFile(&amp;apos;readme.md&amp;apos;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;lines = lines_data.filter()&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;lines.persist()&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;lines.count()&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;lines.first()&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;rdd.collect()操作是将数据存在单台机器的内存（driver）上;&lt;/li&gt;
&lt;li&gt;rdd.filter(lambda x: x &amp;gt; 90)会分发整个self对象;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;RDD基本函数&quot;&gt;&lt;a href=&quot;#RDD基本函数&quot; class=&quot;headerlink&quot; title=&quot;RDD基本函数&quot;&gt;&lt;/a&gt;RDD基本函数&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;&lt;em&gt;更多见官网&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;RDD操作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;distinct()&lt;/li&gt;
&lt;li&gt;union(rdd)&lt;/li&gt;
&lt;li&gt;intersection(rdd) #交集&lt;/li&gt;
&lt;li&gt;substract(rdd) #减去交集&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;转化操作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;map(func)  # 能实现list append&lt;/li&gt;
&lt;li&gt;flatMap(func) # 能实现list expend&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;行动操作:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;reduce(fun)&lt;/li&gt;
&lt;li&gt;top(n),take(n)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;pair RDD转化操作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;mapValues(func): rdd.mapValues(lambda x : x+1) # key不变，value+1&lt;/li&gt;
&lt;li&gt;reduceByKey(func) #接收对相同的key的2个value参数&lt;/li&gt;
&lt;li&gt;keys()&lt;/li&gt;
&lt;li&gt;values()&lt;/li&gt;
&lt;li&gt;combineByKey():该函数用于对key的值进行各种操作，相比其它ByKey更原生，计算(key,mean)例子如下：&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;sumCount = keyValue&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        .combineByKey((&lt;span class=&quot;keyword&quot;&gt;lambda&lt;/span&gt; x: (x,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;),&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                    (&lt;span class=&quot;keyword&quot;&gt;lambda&lt;/span&gt; x,value:(x[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;] + y,x[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;] + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)),&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                    &lt;span class=&quot;keyword&quot;&gt;lambda&lt;/span&gt; x,y: (x[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]+y[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;],x[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]+y[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;])))&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;sumCount.map(&lt;span class=&quot;keyword&quot;&gt;lambda&lt;/span&gt; key,xy:(key,xy[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]/xy[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;])).collectAsMap()&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 其它：&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;rdd.reduceByKey(func) == rdd.groupByKey().mapValues(&lt;span class=&quot;keyword&quot;&gt;lambda&lt;/span&gt; x:x.reduce(func))&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;rdd1.join(rdd2) &lt;span class=&quot;comment&quot;&gt;#&amp;#123;(1,(2,3)),(2,(4,5)),...&amp;#125;&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;pair RDD行动操作：&lt;ul&gt;
&lt;li&gt;rdd.lookup(1) #{(1,2),(1,3),(2,3)}  返回[2,3]&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;存取文件&quot;&gt;&lt;a href=&quot;#存取文件&quot; class=&quot;headerlink&quot; title=&quot;存取文件&quot;&gt;&lt;/a&gt;存取文件&lt;/h2&gt;&lt;h3 id=&quot;存取HDFS并保存为一般格式&quot;&gt;&lt;a href=&quot;#存取HDFS并保存为一般格式&quot; class=&quot;headerlink&quot; title=&quot;存取HDFS并保存为一般格式&quot;&gt;&lt;/a&gt;存取HDFS并保存为一般格式&lt;/h3&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;tow_state = sc.textFile(&lt;span class=&quot;string&quot;&gt;&#39;/user/enjoyhot/town_state.csv&#39;&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;tow_state.saveAsTextFile(&lt;span class=&quot;string&quot;&gt;&#39;/user/enjoyhot/town_state.csv&#39;&lt;/span&gt;)&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在Hadoop namenode 50070端口可查看上传到分布式文件系统的情况。&lt;/p&gt;
&lt;h3 id=&quot;存取pickle文件&quot;&gt;&lt;a href=&quot;#存取pickle文件&quot; class=&quot;headerlink&quot; title=&quot;存取pickle文件&quot;&gt;&lt;/a&gt;存取pickle文件&lt;/h3&gt;&lt;p&gt;&lt;em&gt;python独有&lt;/em&gt;&lt;br&gt;&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;adData = sc.pickleFile(&#39;/user/enjoyhot/2016-06-01’)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;title=Row(&#39;field1&#39;,&#39;field2&#39;,&#39;field3&#39;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;ad_df = sqlContext.createDataFrame(adData.map(lambda e:title(*e)))&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;ad_df.select([&#39;field1&#39;,&#39;field2&#39;]).show()&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&quot;存取parquet格式文件&quot;&gt;&lt;a href=&quot;#存取parquet格式文件&quot; class=&quot;headerlink&quot; title=&quot;存取parquet格式文件&quot;&gt;&lt;/a&gt;存取parquet格式文件&lt;/h2&gt;&lt;p&gt;parquet格式，一种流行的文件列式存储格式，相对高效。&lt;/p&gt;
&lt;h3 id=&quot;转换与保存&quot;&gt;&lt;a href=&quot;#转换与保存&quot; class=&quot;headerlink&quot; title=&quot;转换与保存&quot;&gt;&lt;/a&gt;转换与保存&lt;/h3&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#from pyspark.sql import *&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#sqlc = SQLContext(sc)&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;lines_rdd = sc.textFile(&lt;span class=&quot;string&quot;&gt;&#39;/user/gujw/town_state.csv&#39;&lt;/span&gt;).map(&lt;span class=&quot;keyword&quot;&gt;lambda&lt;/span&gt; line: line.split(&lt;span class=&quot;string&quot;&gt;&quot;,&quot;&lt;/span&gt;))&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;header = lines_rdd.first()&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;rdd = lines_rdd.filter(&lt;span class=&quot;keyword&quot;&gt;lambda&lt;/span&gt; x:x!=header)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;tow_state_df = rdd.toDF([&lt;span class=&quot;string&quot;&gt;&#39;id&#39;&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&#39;town&#39;&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&#39;state&#39;&lt;/span&gt;]) &lt;span class=&quot;comment&quot;&gt;# [&#39;id&#39;,&#39;town&#39;,&#39;state&#39;]&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;tow_state_df.show()&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# tow_state_df.write.parquet(save_path)&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;tow_state_df.saveAsParquetFile(&lt;span class=&quot;string&quot;&gt;&#39;/user/gujw/test/town_state.parquet&#39;&lt;/span&gt;)&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;读取与操作&quot;&gt;&lt;a href=&quot;#读取与操作&quot; class=&quot;headerlink&quot; title=&quot;读取与操作&quot;&gt;&lt;/a&gt;读取与操作&lt;/h3&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; pyspark.sql &lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; *&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;sqlc = SQLContext(sc)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;df = sqlc.read.parquet(&lt;span class=&quot;string&quot;&gt;&quot;/user/gujw/test/town_state.parquet&quot;&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;df.registerTempTable(&lt;span class=&quot;string&quot;&gt;&quot;dft&quot;&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;sqlc.cacheTable(&lt;span class=&quot;string&quot;&gt;&quot;dft&quot;&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;s = &lt;span class=&quot;string&quot;&gt;&quot;select id,town from dft&quot;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;sqlc.sql(s).show()&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;center&gt;&lt;br&gt;&lt;img src=&quot;http://img.blog.csdn.net/20160715192713880&quot; alt=&quot;此处输入图片的描述&quot;&gt;&lt;br&gt;&lt;/center&gt;

&lt;h3 id=&quot;本地打印元素&quot;&gt;&lt;a href=&quot;#本地打印元素&quot; class=&quot;headerlink&quot; title=&quot;本地打印元素&quot;&gt;&lt;/a&gt;本地打印元素&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;id_town_list = sqlc.sql(s).collect()&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;for item in id_town_list:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    print item[0]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    break&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;center&gt;&lt;br&gt;&lt;img src=&quot;http://img.blog.csdn.net/20160715192811268&quot; alt=&quot;此处输入图片的描述&quot;&gt;&lt;br&gt;&lt;/center&gt;

&lt;h3 id=&quot;topK操作&quot;&gt;&lt;a href=&quot;#topK操作&quot; class=&quot;headerlink&quot; title=&quot;topK操作&quot;&gt;&lt;/a&gt;topK操作&lt;/h3&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;hello = sc.parallelize([&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;])&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;mapA = hello.map(&lt;span class=&quot;keyword&quot;&gt;lambda&lt;/span&gt; x:(x,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;))&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;reduceA = mapA.reduceByKey(&lt;span class=&quot;keyword&quot;&gt;lambda&lt;/span&gt; a,b:a+b)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;print&lt;/span&gt; reduceA.collect()&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;sortedA = reduceA.map(&lt;span class=&quot;keyword&quot;&gt;lambda&lt;/span&gt; (x,y):(y,x)).sortByKey(ascending=&lt;span class=&quot;keyword&quot;&gt;False&lt;/span&gt;).take(&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;sortedB = reduceA.map(&lt;span class=&quot;keyword&quot;&gt;lambda&lt;/span&gt; x:(x[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;],x[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;])).sortByKey(ascending=&lt;span class=&quot;keyword&quot;&gt;False&lt;/span&gt;).take(&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;print&lt;/span&gt; sortedA&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;print&lt;/span&gt; sortedB&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;## 结果&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;[(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;), (&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;), (&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;), (&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;)]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;[(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;), (&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;), (&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;)]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;[(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;), (&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;), (&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;)]&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h1 id=&quot;Shuffle&quot;&gt;&lt;a href=&quot;#Shuffle&quot; class=&quot;headerlink&quot; title=&quot;Shuffle&quot;&gt;&lt;/a&gt;Shuffle&lt;/h1&gt;&lt;h2 id=&quot;概念-1&quot;&gt;&lt;a href=&quot;#概念-1&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h2&gt;&lt;p&gt;Shuffle操作介于Map phase和Reduce phase之间，当Map的输出结果要被Reduce使用时，输出结果需要&lt;strong&gt;按key哈希&lt;/strong&gt;，并且分发到每一个Reducer上去，这个过程就是shuffle。由于shuffle涉及到了磁盘的读写和网络的传输，因此shuffle性能的高低直接影响到了整个程序的运行效率。如图：&lt;/p&gt;
&lt;center&gt;&lt;br&gt;&lt;img src=&quot;http://jerryshao.me/img/2014-01-04-spark-shuffle/mapreduce-process.jpg&quot; alt=&quot;此处输入图片的描述&quot;&gt;&lt;br&gt;&lt;/center&gt;&lt;br&gt;可将 map 端划分数据、持久化数据的过程称为 shuffle write，而将 reducer 读入数据、aggregate 数据的过程称为 shuffle read。&lt;br&gt;&lt;br&gt;## 前期Shuffle方式&lt;br&gt;&lt;br&gt;如图所示，为Spark和Hadoop最基本的shuffle方式。&lt;br&gt;&lt;center&gt;&lt;br&gt;&lt;img src=&quot;http://jerryshao.me/img/2014-01-04-spark-shuffle/spark-shuffle.png&quot; alt=&quot;此处输入图片的描述&quot;&gt;&lt;br&gt;&lt;/center&gt;&lt;br&gt;- 每一个Mapper会根据Reducer的数量创建出相应的bucket(一个抽象的概念)，bucket的数量是M×R，其中M是Map的个数，R是Reduce的个数。&lt;br&gt;- Mapper产生的结果会根据设置的partition算法填充到每个bucket中去。这里的partition算法是可以自定义的，默认的算法是根据key哈希到不同的bucket中去。&lt;br&gt;- Reducer启动时，它会根据自己task的id和所依赖的Mapper的id从远端或是本地的block manager中取得相应的bucket作为Reducer的输入进行处理。&lt;br&gt;&lt;br&gt;&amp;gt; bucket是一个抽象概念，在实现中每个bucket可以对应一个文件，可以对应文件的一部分或是其他等。&lt;br&gt;&lt;br&gt;PS:Spark的内存计算是指Job中间输出结果可以保存在内存中，不是说shuffle过程的中间实现，Map结果的分片数据Spark和MapReduce都存放在磁盘上。&lt;br&gt;&lt;br&gt;## 发展&lt;br&gt;### hash-based&lt;br&gt;&lt;a href=&quot;https://github.com/JerryLead/SparkInternals/blob/master/markdown/4-shuffleDetails.md&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/JerryLead/SparkInternals/blob/master/markdown/4-shuffleDetails.md&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://jerryshao.me/architecture/2014/01/04/spark-shuffle-detail-investigation/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://jerryshao.me/architecture/2014/01/04/spark-shuffle-detail-investigation/&lt;/a&gt;&lt;br&gt;&lt;strong&gt;Spark 0.8.1做了改进后还是有缺点：&lt;/strong&gt;&lt;br&gt;&lt;br&gt;- shuffle write过程中会产生大量的shffle文件，总体来说多少个reduce task,一台机器就有多少个文件,封装在shuffleFileGroup概念的文件中（图中横向的一行），不再是MXR，bucket数量依然为MXR，但此时M代表的是一次map的write task数量，即CPU核数，【一个bucket将会对应writer handler的buffer，内存开销依然很大，可能有误】。因此必要的措施是减少Mapper和Reducer的数量。看图：&lt;br&gt;&lt;img src=&quot;http://jerryshao.me/img/2014-01-04-spark-shuffle/spark-shuffle-consolidate.png&quot; alt=&quot;此处输入图片的描述&quot;&gt;&lt;br&gt;- 另一方面，shffle read中在做诸如groupByKey操作时，需要将每个partition中的value都保存到同一key对应的hashMap中，就得确保Map操作对应的partition足够小到内存能够容纳，因此合理的设计是增加task的数量，task数量增多又会带来buffer开销更大的问题，因此陷入了内存使用的两难境地。&lt;br&gt;&lt;br&gt;- 来自知乎&lt;br&gt;&amp;gt; 以前对 shuffle write/read 的分类是 sort-based 和 hash-based。MapReduce 可以说是 sort-based，shuffle write 和 shuffle read 过程都是基于key sorting 的 (buffering records + in-memory sort + on-disk external sorting)。早期的 Spark 是 hash-based，shuffle write 和 shuffle read 都使用 HashMap-like 的数据结构进行 aggregate (without key sorting)。但目前的 Spark 是两者的结合体，shuffle write 可以是 sort-based (only sort partition id, without key sorting)，shuffle read 阶段可以是 hash-based。因此，目前 sort-based 和 hash-based 已经“你中有我，我中有你”，界限已经不那么清晰。&lt;br&gt;参考：&lt;a href=&quot;https://www.zhihu.com/question/27643595&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://www.zhihu.com/question/27643595&lt;/a&gt;&lt;br&gt;&lt;br&gt;### SortBasedShuffle&lt;br&gt;“取代”Hash BasedShuffle作为默认选项的原因是什么？&lt;br&gt;&lt;br&gt;- hashbased shuffle的每个mapper都需要为每个reducer写一个文件，需要产生M&lt;em&gt;R个数量的文件，如果mapper和reducer的数量比较大，产生的文件数会非常多。hashbased shuffle设计的目标之一就是避免不需要的排序（Hadoop Map Reduce被人诟病的地方，很多不需要sort的地方的sort导致了不必要的开销）。但是它在处理超大规模数据集的时候，产生了大量的DiskIO和内存的消耗，这无疑很影响性能。&lt;br&gt;- hashbased shuffle也在不断的优化中，为了更好的解决这个问题，&lt;em&gt;*Spark 1.1&lt;/em&gt;&lt;/em&gt; 引入了Sortbased shuffle。首先，每个Shuffle Map Task不会为每个Reducer生成一个单独的文件；相反，它会将所有的结果写到一个文件里，同时会生成一个index文件，Reducer可以通过这个index文件取得它需要处理的数据。避免产生大量的文件的直接收益就是节省了内存的使用和顺序Disk IO带来的低延时。节省内存的使用可以减少GC的风险和频率。而减少文件的数量可以避免同时写多个文件对系统带来的压力。&lt;br&gt;- Spark2.0中已明确指出移除掉hash-based shuffle，详见&lt;a href=&quot;http://spark.apache.org/releases/spark-release-2-0-0.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;release-note&lt;/a&gt;。&lt;br&gt;&lt;br&gt;&lt;br&gt;# 提高速度的方法&lt;br&gt;&lt;br&gt;## 读取文件&lt;br&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;RDD = sc.textFile(dir | part-*.txt) &lt;span class=&quot;comment&quot;&gt;# 读取目录或正则匹配&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;pairRDD = sc.wholeTextFile(dir | part-*.txt)&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br&gt;&lt;br&gt;wholeTextFile如果是读一个文件，一次读取所有行，返回&lt;br&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;rdd(filepath,contents)&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br&gt;&lt;br&gt;## 代码逻辑层面&lt;br&gt;&lt;br&gt;### 对数据分区&lt;br&gt;- 如pair RDD采用partitionBy(100)进行自定义哈希分区,避免不必要的混洗，但注意需要persist持久化才能避免重新分区；对RDD的结果有分区的是&lt;br&gt;    - cogroup&lt;br&gt;    - groupWith&lt;br&gt;    - join,leftOuterJoin,rightOuterJoin&lt;br&gt;    - groupByKey,reduceByKey,combineByKey&lt;br&gt;    - partitionBy&lt;br&gt;    - sort&lt;br&gt;    - mapValues(父RDD需有分区),flatMapValues(父RDD需有分区)&lt;br&gt;- 自定义分区&lt;br&gt;如下代码，拥有相似的URL页面可能会被分到完全不同的节点上，然而，同一个域名下的网页更有可能相互链接，因此，分区时考虑将rdd中拥有同一个域名的url放在一起。&lt;br&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;print urlparse.urlparse(&quot;http://www.baidu.com&quot;).netloc&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;www.baidu.com&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;print urlparse.urlparse(&quot;http://www.baidu.com/a/b&quot;).netloc&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;www.baidu.com&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&quot;&quot;&quot;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; urlparse&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;hash_domain&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(url)&lt;/span&gt;:&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; hash(urlparse.urlparse(url).netloc)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;rdd.partitionBy(&lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;,hash_domain)&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br&gt;&lt;br&gt;更详细的实战推荐两篇美团的文章：&lt;br&gt;&lt;br&gt;- &lt;a href=&quot;http://tech.meituan.com/spark-tuning-basic.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Spark性能优化指南-基础篇&lt;/a&gt;&lt;br&gt;- &lt;a href=&quot;http://tech.meituan.com/spark-tuning-pro.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Spark性能优化指南-高级篇&lt;/a&gt;&lt;br&gt;&lt;br&gt;# 实时计算相关&lt;br&gt;&lt;br&gt;## Spark Streaming&lt;br&gt;&lt;br&gt;### 消费数据&lt;br&gt;&lt;br&gt;Spark可以接受来自文件系统, Akka actors, rsKafka, Flume, Twitter, ZeroMQ和TCP Socket的数据源或者你自己定义的输入源。&lt;br&gt;&lt;br&gt;- 读取TCP源数据&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Create a DStream that will connect to hostname:port, like localhost:9999&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;JavaReceiverInputDStream&amp;lt;String&amp;gt; lines = jssc.socketTextStream(&lt;span class=&quot;string&quot;&gt;&quot;localhost&quot;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;9999&lt;/span&gt;);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br&gt;&lt;br&gt;简单测试的方法：&lt;br&gt;运行Netcat工具作为数据服务器,在netcat服务器中输入的每一行都会被读取，在Spark streaming程序中做好统计即可。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;$ nc -lk 9999&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br&gt;&lt;br&gt;- 消费kafka数据&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;SparkConf conf = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; SparkConf().setAppName(&lt;span class=&quot;string&quot;&gt;&quot;streaming_top10&quot;&lt;/span&gt;).setMaster(&lt;span class=&quot;string&quot;&gt;&quot;local[4]&quot;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;JavaStreamingContext jssc = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; JavaStreamingContext(conf, Durations.seconds(&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;));&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;jssc.checkpoint(Constants.CHECKPOINT);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;String zk_quorum = Constants.ZK_QUORUM;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;String consumer_group_id=&lt;span class=&quot;string&quot;&gt;&quot;test-consumer-group&quot;&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Map&amp;lt;String, Integer&amp;gt; topicMap = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; HashMap &amp;lt;String, Integer&amp;gt;();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;topicMap.put(&lt;span class=&quot;string&quot;&gt;&quot;topic-kafka&quot;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;JavaPairReceiverInputDStream&amp;lt;String,String&amp;gt; messages =&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        KafkaUtils.createStream(jssc, zk_quorum, consumer_group_id, topicMap);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br&gt;&lt;br&gt;- 待续&lt;br&gt;&lt;br&gt;### Spark Streaming vs Storm&lt;br&gt;Spark流模块先汇聚批量数据然后进行数据块分发（视作不可变数据进行处理），而Storm是只要接收到数据就实时处理并分发。&lt;br&gt;&lt;br&gt;- 延迟&lt;br&gt;    - 根本的区别在于处理模型，Storm处理的是每次传入的一个事件，而Spark Streaming是处理某个时间段窗口内的事件流。因此,Storm处理一个事件可以达到秒内的延迟，而Spark Streaming则有几秒钟的延迟。&lt;br&gt;&lt;br&gt;- 容错性&lt;br&gt;    - Spark Streaming提供了更好的支持容错状态计算。在Storm中,每个单独的记录当它通过系统时必须被跟踪，所以Storm能够至少保证每个记录将被处理一次，但是在从错误中恢复过来时候允许出现重复记录。这意味着可变状态可能不正确地被更新两次。&lt;br&gt;    - 对于Storm而言，其优势在于延迟低，如果对严格的一次处理保证有比较高的要求，此时也可考虑使用Trident。不过这种情况下其他流处理框架如spark streaming也许更适合。&lt;br&gt;&lt;br&gt;## SparkSQL&lt;br&gt;实际上该功能是否真正实时依然由业务具体决定，对于比较轻量级的操作，可以直接返回，做到准实时。&lt;br&gt;&lt;br&gt;&lt;br&gt;# 资源管理系统&lt;br&gt;&lt;br&gt;## Yarn&lt;br&gt;### 结构&lt;br&gt;Hadoop2.0对MapReduce框架做了彻底的设计重构，称Hadoop2.0中的MapReduce为MRv2或者Yarn。&lt;br&gt;&lt;br&gt;- Hadoop1.x主要组件&lt;br&gt;JobTracker和TaskTracker&lt;br&gt;- Hadoop2.X中引入yarn之组件&lt;br&gt;    - ResourceManger：全局的资源管理器进程，它主要由两个组件构成：调度器（Scheduler）和应用程序管理器（Application Manager，ASM）。ResourceManager 将各个资源部分（计算、内存、带宽等）精心安排给基础 NodeManager（YARN 的每节点代理）。ResourceManager 还与 ApplicationMaster 一起分配资源，与 NodeManager 一起启动和监视它们的基础应用程序。&lt;br&gt;        - 应用程序管理器（Application Manager）&lt;br&gt;应用程序管理器负责管理整个系统中所有应用程序，包括应用程序提交、与调度器协商资源以启动ApplicationMaster、监控ApplicationMaster运行状态并在失败时重新启动它等。&lt;br&gt;    - ApplicationMaster：&lt;br&gt;对于Map-Reduce计算模型而言有它自己的ApplicationMaster实现，用于向ResourceManager（全局的）申请计算资源（Containers）并且和NodeManager交互来执行和监控具体的task。&lt;br&gt;    - NodeManager：&lt;br&gt;YARN中每个节点上的代理，管理Hadoop集群中单个计算节点，包括与ResourceManger保持通信，监督Container的生命周期管理，监控每个Container的资源使用（内存、CPU等）情况，追踪节点健康状况，管理日志和不同应用程序用到的附属服务（auxiliary service）。&lt;br&gt;    - container&lt;br&gt;Yarn对计算机计算资源的抽象，它其实就是一组CPU和内存资源。&lt;br&gt;&lt;br&gt;### 调度器&lt;br&gt;在Yarn中有三种调度器可以选择：&lt;br&gt;&lt;br&gt;- FIFO Scheduler&lt;br&gt;可能导致其它应用被阻塞&lt;br&gt;- Capacity Scheduler&lt;br&gt;有一个专门用来运行小任务的队列，意味着一些需要大量资源的任务执行时间会相比可用上所有资源的FIFO调度器时间长。&lt;br&gt;- FairS cheduler&lt;br&gt;资源运行时动态调整。&lt;br&gt;&lt;center&gt;&lt;br&gt;&lt;img src=&quot;http://img.blog.csdn.net/20151030111100329&quot; alt=&quot;此处输入图片的描述&quot;&gt;&lt;br&gt;&lt;/center&gt;

&lt;h3 id=&quot;粗细粒度探讨&quot;&gt;&lt;a href=&quot;#粗细粒度探讨&quot; class=&quot;headerlink&quot; title=&quot;粗细粒度探讨&quot;&gt;&lt;/a&gt;粗细粒度探讨&lt;/h3&gt;&lt;p&gt;细粒度可以提高CPU的利用率，但对于短作业延迟大。待补充……&lt;/p&gt;
&lt;h1 id=&quot;进一步了解Spark&quot;&gt;&lt;a href=&quot;#进一步了解Spark&quot; class=&quot;headerlink&quot; title=&quot;进一步了解Spark&quot;&gt;&lt;/a&gt;进一步了解Spark&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;&lt;em&gt;基于Spark1.6&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;应用调度策略&quot;&gt;&lt;a href=&quot;#应用调度策略&quot; class=&quot;headerlink&quot; title=&quot;应用调度策略&quot;&gt;&lt;/a&gt;应用调度策略&lt;/h2&gt;&lt;h3 id=&quot;两种调度策略&quot;&gt;&lt;a href=&quot;#两种调度策略&quot; class=&quot;headerlink&quot; title=&quot;两种调度策略&quot;&gt;&lt;/a&gt;两种调度策略&lt;/h3&gt;&lt;p&gt;笔者认为，网上各种job的说法其实都是在说应用，而不是spark中的job，在这里我们就将job理解为普通作业，即app即可。&lt;br&gt;实际上，app对应一个调度池，而每个APP每个stage对应一个带有JobId和TaskSetManagerId的TaskSetMananger，调度池先根据JobId进行排序，再根据TaskSetManagerId排序，小的优先调度，因此job依然是通过FIFO进行调度的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;FIFO&lt;br&gt;在默认情况下，Spark的调度器以FIFO（先进先出）方式调度Job的执行，standalone也只支持这一种。第一个Job优先获取所有可用的资源，接下来第二个Job再获取剩余资源。以此类推，如果第一个Job并没有占用所有的资源，则第二个Job还可以继续获取剩余资源，这样多个Job可以并行运行，否则，第二个Job就需要等待第一个任务执行完，释放空余资源，再申请和分配Job。&lt;strong&gt;在mesos和yarn下，有多队列调度器，如本文yarn调度器部分，通过合理设置多个队列分配资源，可以做到多个作业并行执行。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;FAIR&lt;br&gt;在FAIR共享模式调度下，Spark在多Job之间以轮询（round robin）方式为任务分配资源，所有的任务拥有大致相当的优先级来共享集群的资源。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;参数设置&quot;&gt;&lt;a href=&quot;#参数设置&quot; class=&quot;headerlink&quot; title=&quot;参数设置&quot;&gt;&lt;/a&gt;参数设置&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;schedulingMode：该属性的值可以是FIFO或者FAIR，用来控制作业在调度池中排队运行（默认情况下）或者公平分享调度池资源。&lt;/li&gt;
&lt;li&gt;weight：控制调度池在集群之间的分配。默认情况下，所有调度池的weight值都是为1。例如：如果你指定了一个调度池的值为2，那么这个调度池就比其它调度池多获得2倍的资源。设置一个更高的weight值，例如1000，就可以实现线程池之间的优先权——实际上，weight值为1000的调度池无论什么时候作业被激活，它都总是能够最先运行。&lt;/li&gt;
&lt;li&gt;minShare：除了一个整体的权重，如果管理员喜欢，可以给每个调度池指定一个最小的shares值（也就是CPU的核数目）。公平调度器通过权重重新分配资源之前总是试图满足所有活动调度池的最小share。在没有给定一个高优先级的其他集群中，minShare属性是另外的一种方式来确保调度池能够迅速的获得一定数量的资源（例如10核CPU），默认情况下，每个调度池的minShare值都为0。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;（scheduling mode 值是FIFO，weight值为1，minShare值为0）。&lt;/p&gt;
&lt;h2 id=&quot;Spark-map-reduce基本原理&quot;&gt;&lt;a href=&quot;#Spark-map-reduce基本原理&quot; class=&quot;headerlink&quot; title=&quot;Spark map reduce基本原理&quot;&gt;&lt;/a&gt;Spark map reduce基本原理&lt;/h2&gt;&lt;p&gt;RDD可理解为关系数据库里的一个个操作，比如 map，filter，Join 等。在 Spark 里面实现了许多这样的RDD类，即可以看成是操作类。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当我们调用一个map接口，底层实现是会生成一个MapPartitionsRDD对象，当RDD真正执行时，会调用MapPartitionsRDD对象里面的compute方法来执行这个操作的计算逻辑。&lt;/li&gt;
&lt;li&gt;但是不同的是，RDD是lazy模式，只有像count，saveasText这种action动作被调用后再会去触发runJob动作。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;RDD&quot;&gt;&lt;a href=&quot;#RDD&quot; class=&quot;headerlink&quot; title=&quot;RDD&quot;&gt;&lt;/a&gt;RDD&lt;/h2&gt;&lt;h3 id=&quot;基本组成&quot;&gt;&lt;a href=&quot;#基本组成&quot; class=&quot;headerlink&quot; title=&quot;基本组成&quot;&gt;&lt;/a&gt;基本组成&lt;/h3&gt;&lt;p&gt;在 &lt;a href=&quot;https://github.com/apache/spark/blob/branch-1.6/core/src/main/scala/org/apache/spark/rdd/RDD.scala&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Spark1.6&lt;/a&gt; 中，有以下四个函数比较重要：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;def compute(split: Partition, context: TaskContext): Iterator[T]&lt;br&gt;作用：用于计算，主要负责的是父RDD分区数据到子RDD分区数据的变换逻辑&lt;/li&gt;
&lt;li&gt;protected def getPartitions: Array[Partition]&lt;br&gt;作用：获取分片消息&lt;/li&gt;
&lt;li&gt;protected def getDependencies: Seq[Dependency[_]]&lt;br&gt;作用：获取父RDD的依赖关系，依赖分二种——如果RDD的每个分区最多只能被一个Child RDD的一个分区使用，则称之为narrow dependency(如map)；若依赖于多个 Child RDD 分区，则称之为 wide dependency(如join)。&lt;/li&gt;
&lt;li&gt;protected def getPreferredLocations(split: Partition): Seq[String]&lt;br&gt;作用：获取Spark的执行模式，local等。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;RDD-DataFrame-DataSet&quot;&gt;&lt;a href=&quot;#RDD-DataFrame-DataSet&quot; class=&quot;headerlink&quot; title=&quot;RDD,DataFrame,DataSet&quot;&gt;&lt;/a&gt;RDD,DataFrame,DataSet&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;RDD缺点&lt;ul&gt;
&lt;li&gt;序列化和反序列化的性能开销&lt;br&gt;无论是集群间的通信,还是IO操作都需要对对象的&lt;strong&gt;结构和数据&lt;/strong&gt;进行序列化和反序列化。&lt;/li&gt;
&lt;li&gt;GC的性能开销&lt;br&gt;频繁的创建和销毁对象, 势必会增加GC。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;DataFrame特点&lt;ul&gt;
&lt;li&gt;schema&lt;br&gt;RDD每一行的数据,结构都是一样的。这个结构存储在schema中，Spark通过schame就能够读懂数据,因此在通信和IO时就只需要序列化和反序列化数据, 而结构的部分就可以省略了。&lt;/li&gt;
&lt;li&gt;off-heap&lt;br&gt;Spark能够以二进制的形式序列化数据(不包括结构)到off-heap中,内存直接受操作系统管理（而不是JVM）。当要操作数据时, 就直接操作off-heap内存。由于Spark理解schema, 所以知道该如何操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通过schema和off-heap,DataFrame解决了RDD的缺点,但是却丢了RDD的优点。DataFrame不是类型安全的, API也不是面向对象风格的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Dataset&lt;br&gt;DataSet以Catalyst逻辑执行计划表示，Dataset跟RDD相似，但是Dataset并没有使用Java序列化库和Kryo序列化库，而是使用特定Encoder来序列化对象。并且，序列化后数据以编码的二进制形式被存储，不需要反序列化就可以执行sorting、shuffle等操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;blockManager&quot;&gt;&lt;a href=&quot;#blockManager&quot; class=&quot;headerlink&quot; title=&quot;blockManager&quot;&gt;&lt;/a&gt;blockManager&lt;/h2&gt;&lt;p&gt;实现缓存的&lt;a href=&quot;https://github.com/apache/spark/blob/branch-2.1/core/src/main/scala/org/apache/spark/storage/BlockManager.scala&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;重要类&lt;/a&gt;，通过类似于在内部再构建了一个KV系统，K表示每个分区 ID 号，V 表示这个分区计算后的结果。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;例如在streaming计算时，每个batch会去消息队列上拉取这个时间段的数据，每个Recevier接收过来数据形成block块并存放到blockManager上，为了可靠性，这个block块可以远程备份，后续的batch计算就直接在之前已读取的block块上进行计算，这样不断循环迭代来完成流处理。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;计算任务流程的梳理&quot;&gt;&lt;a href=&quot;#计算任务流程的梳理&quot; class=&quot;headerlink&quot; title=&quot;计算任务流程的梳理&quot;&gt;&lt;/a&gt;计算任务流程的梳理&lt;/h2&gt;&lt;h3 id=&quot;划分Stage&quot;&gt;&lt;a href=&quot;#划分Stage&quot; class=&quot;headerlink&quot; title=&quot;划分Stage&quot;&gt;&lt;/a&gt;划分Stage&lt;/h3&gt;&lt;p&gt;当某个操作触发计算，向DAGScheduler提交作业时，DAGScheduler需要从RDD依赖链最末端的RDD出发，遍历整个RDD依赖链，划分Stage任务阶段，并决定各个Stage之间的依赖关系。&lt;/p&gt;
&lt;h3 id=&quot;提交&quot;&gt;&lt;a href=&quot;#提交&quot; class=&quot;headerlink&quot; title=&quot;提交&quot;&gt;&lt;/a&gt;提交&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;理解&lt;br&gt;Stage—&amp;gt;TaskSet&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;DAGScheduler.call(TaskSet)&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;res = TaskScheduler.submit(TaskSet)&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    TaskSetManager(res)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;文字说明&lt;br&gt;每个Stage的提交，最终是转换成一个TaskSet任务集的提交，DAGScheduler通过TaskScheduler接口提交stage(TaskSet)，每个TaskSet最终会触发TaskScheduler构建一个TaskSetManager（调度单位）的实例来管理这个TaskSet的生命周期，对于DAGScheduler来说提交Stage的工作到此就完成了。而TaskScheduler的具体实现则会在得到计算资源的时候，进一步通过 TaskSetManager调度具体的Task到对应的Executor节点上进行运算。&lt;br&gt;&lt;center&gt;&lt;br&gt;&lt;img src=&quot;http://img2.tuicool.com/iENRnmz.png&quot; alt=&quot;1.6.0版本实现&quot;&gt;&lt;br&gt;&lt;/center&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;ExecutorBackend：在Worker上执行Task的线程组&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;SchedulerBackend：主要用来与Worker中的ExecutorBackend建立连接，用来向Executor发送要执行任务，或是接受执行任务的结果，也可以用来创建AppClient(包装App信息，包含可以创建CoarseGrainedExecutorBackend实例Command)，用于向Master汇报资源需求&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;监控&quot;&gt;&lt;a href=&quot;#监控&quot; class=&quot;headerlink&quot; title=&quot;监控&quot;&gt;&lt;/a&gt;监控&lt;/h3&gt;&lt;p&gt;DAGScheduler就必然需要监控当前Job/Stage乃至Task的完成情况。这是通过对外（主要是对TaskScheduler）暴露一系列的回调函数来实现的。&lt;/p&gt;
&lt;h3 id=&quot;任务结果的获取&quot;&gt;&lt;a href=&quot;#任务结果的获取&quot; class=&quot;headerlink&quot; title=&quot;任务结果的获取&quot;&gt;&lt;/a&gt;任务结果的获取&lt;/h3&gt;&lt;p&gt;一个具体的任务在Executor中执行完毕以后，其结果需要以某种形式返回给DAGScheduler，根据任务类型的不同，任务的结果的返回方式也不同：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于FinalStage所对应的任务（触发action的那个，对应的类为ResultTask）返回给DAGScheduler的是运算结果本身；&lt;/li&gt;
&lt;li&gt;而对于 ShuffleMapTask，返回给DAGScheduler的是一个MapStatus对象，MapStatus对象管理了ShuffleMapTask的运算输出结果在BlockManager里的相关存储信息，而非结果本身，这些存储位置信息将作为下一个Stage的任务获取输入数据的依据。&lt;br&gt;参考：&lt;a href=&quot;http://blog.csdn.net/laiwenqiang/article/details/50032171&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.csdn.net/laiwenqiang/article/details/50032171&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;适用场景&quot;&gt;&lt;a href=&quot;#适用场景&quot; class=&quot;headerlink&quot; title=&quot;适用场景&quot;&gt;&lt;/a&gt;适用场景&lt;/h1&gt;&lt;h2 id=&quot;不适合超大数据量的计算&quot;&gt;&lt;a href=&quot;#不适合超大数据量的计算&quot; class=&quot;headerlink&quot; title=&quot;不适合超大数据量的计算&quot;&gt;&lt;/a&gt;不适合超大数据量的计算&lt;/h2&gt;&lt;p&gt;Spark适用于那些在多个并行操作之间重用数据的应用，通过rdd是基于内存的优点免去了传统MapReduce不断读写磁盘的IO损耗，但基于内存的rdd操作，可想而知，数据量一大就容易产生OOM的问题。&lt;/p&gt;
&lt;h2 id=&quot;不适合异步更新模型&quot;&gt;&lt;a href=&quot;#不适合异步更新模型&quot; class=&quot;headerlink&quot; title=&quot;不适合异步更新模型&quot;&gt;&lt;/a&gt;不适合异步更新模型&lt;/h2&gt;&lt;p&gt;由于RDD的特性，Spark不适用那种&lt;strong&gt;异步细粒度&lt;/strong&gt;更新状态的应用，例如增量的web爬虫和索引，以及在一些机器学习和数据挖掘（MLDM）算法上表现并非最优，spark ML与Mahout都是采用Iterative MapReduce架构，都是同步迭代，而关于迭代式算法：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;迭代式算法，许多机器学习算法都用一个函数对相同的数据（优点）进行重复的计算，更新同一个模型（局限）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;同步迭代的缺点，存在木桶效应，可参考该图：&lt;/p&gt;
&lt;center&gt;&lt;br&gt;&lt;img src=&quot;http://7pn4yt.com1.z0.glb.clouddn.com/blog-synchronous.gif&quot; alt=&quot;此处输入图片的描述&quot;&gt;&lt;br&gt;&lt;/center&gt;

&lt;p&gt;图参考：&lt;a href=&quot;http://blog.csdn.net/cyh_24/article/details/50545780&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;就是说，对于那种增量修改的应用模型不太适合。因为rdd的操作可以理解为分散式的，每个分散的任务不是针对同一个共同体。（笔者认为，假如硬是要通过spark共享一个共同体，一般实现是每个任务完成后重写共同体，共同体全局可见，因此对于细粒度而言，任务一多，通信开销可想而知，但这对于CPU密集型，网络开销小的硬件如GPU不是问题）。这是一个模型并行化和数据并行化的问题。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;h2 id=&quot;官方文档&quot;&gt;&lt;a href=&quot;#官方文档&quot; class=&quot;headerlink&quot; title=&quot;官方文档&quot;&gt;&lt;/a&gt;官方文档&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://spark.apache.org/docs/latest/&quot;&gt;Spark doc&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;相关平台&quot;&gt;&lt;a href=&quot;#相关平台&quot; class=&quot;headerlink&quot; title=&quot;相关平台&quot;&gt;&lt;/a&gt;相关平台&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://databricks.com/blog&quot;&gt;databricks blog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://gitter.im/spark-scala/Lobby&quot;&gt;A place to discuss and ask questions about using Scala for Spark programming&lt;/a&gt;
    
    </summary>
    
      <category term="Spark" scheme="http://enjoyhot.github.io/categories/Spark/"/>
    
    
      <category term="Spark" scheme="http://enjoyhot.github.io/tags/Spark/"/>
    
  </entry>
  
  <entry>
    <title>Java高级篇</title>
    <link href="http://enjoyhot.github.io/2017/04/30/Java%E9%AB%98%E7%BA%A7%E7%AF%87/"/>
    <id>http://enjoyhot.github.io/2017/04/30/Java高级篇/</id>
    <published>2017-04-30T09:21:09.000Z</published>
    <updated>2017-04-30T09:29:40.148Z</updated>
    
    <content type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;h2 id=&quot;本系列文章将分为三部分：&quot;&gt;&lt;a href=&quot;#本系列文章将分为三部分：&quot; class=&quot;headerlink&quot; title=&quot;本系列文章将分为三部分：&quot;&gt;&lt;/a&gt;本系列文章将分为三部分：&lt;/h2&gt;&lt;h3 id=&quot;Java基础篇&quot;&gt;&lt;a href=&quot;#Java基础篇&quot; class=&quot;headerlink&quot; title=&quot;Java基础篇&quot;&gt;&lt;/a&gt;Java基础篇&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;语法篇&lt;/li&gt;
&lt;li&gt;数据结构篇&lt;/li&gt;
&lt;li&gt;集合框架&lt;/li&gt;
&lt;/ul&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;Java高级篇&quot;&gt;&lt;a href=&quot;#Java高级篇&quot; class=&quot;headerlink&quot; title=&quot;Java高级篇&quot;&gt;&lt;/a&gt;Java高级篇&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;JVM知识&lt;/li&gt;
&lt;li&gt;多线程&lt;/li&gt;
&lt;li&gt;Java IO&lt;/li&gt;
&lt;li&gt;Java安全&lt;/li&gt;
&lt;li&gt;设计模式&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;Java实践篇&quot;&gt;&lt;a href=&quot;#Java实践篇&quot; class=&quot;headerlink&quot; title=&quot;Java实践篇&quot;&gt;&lt;/a&gt;Java实践篇&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;并发编程相关&lt;/li&gt;
&lt;li&gt;分布式相关&lt;/li&gt;
&lt;li&gt;框架介绍&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;有些【疑问】可能会留在笔记中，在学习中补充…&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&quot;相关链接&quot;&gt;&lt;a href=&quot;#相关链接&quot; class=&quot;headerlink&quot; title=&quot;相关链接&quot;&gt;&lt;/a&gt;相关链接&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/index.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;javase 1.8 online doc&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/index.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;javase 1.7 online doc&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://docs.oracle.com/javase/specs/jvms/se8/html/index.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;javase 1.8 JVM Specification online doc&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://docs.oracle.com/javase/specs/jvms/se7/html/index.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;javase 1.7 JVM Specification online doc&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;JVM知识&quot;&gt;&lt;a href=&quot;#JVM知识&quot; class=&quot;headerlink&quot; title=&quot;JVM知识&quot;&gt;&lt;/a&gt;JVM知识&lt;/h1&gt;&lt;h2 id=&quot;内存模型&quot;&gt;&lt;a href=&quot;#内存模型&quot; class=&quot;headerlink&quot; title=&quot;内存模型&quot;&gt;&lt;/a&gt;内存模型&lt;/h2&gt;&lt;h3 id=&quot;JMM结构&quot;&gt;&lt;a href=&quot;#JMM结构&quot; class=&quot;headerlink&quot; title=&quot;JMM结构&quot;&gt;&lt;/a&gt;JMM结构&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;基本结构&lt;ul&gt;
&lt;li&gt;分为class loader；&lt;/li&gt;
&lt;li&gt;运行时数据区；&lt;/li&gt;
&lt;li&gt;执行引擎；&lt;/li&gt;
&lt;li&gt;本地方法接口&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;基本示意图如下：&lt;/strong&gt;&lt;/p&gt;
&lt;center&gt;&lt;br&gt;&lt;img src=&quot;http://img.blog.csdn.net/20150720152805765?%20%20watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/grav%20%20ity/Center&quot; alt=&quot;此处输入图片的描述&quot;&gt;&lt;br&gt;&lt;/center&gt;

&lt;ul&gt;
&lt;li&gt;类在JVM中的唯一性&lt;br&gt;通过类的全限定名和加载这个类的类加载器ID确定唯一性。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;JVM相关概念&quot;&gt;&lt;a href=&quot;#JVM相关概念&quot; class=&quot;headerlink&quot; title=&quot;JVM相关概念&quot;&gt;&lt;/a&gt;JVM相关概念&lt;/h2&gt;&lt;h3 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;程序计数器（Program Counter Register）：&lt;br&gt;当前线程执行字节码的行号指示器。通过改变这个指示器的值来选取下一条需要执行的字节码指令。由于多线程间切换时要恢复每一个线程的当前执行位置，所以每个线程都有自己的程序计算器。这个内存区域是Java虚拟机唯一一个没有定义OutOfMemeryError情况的区域。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Java虚拟机栈（Java Visual Machine Stacks）：&lt;br&gt;虚拟机栈描述的是Java方法执行的内存模型：每个方法执行是都会创建栈帧（Stack Frame）用于存储局部变量（包括引用变量），操作栈，方法信息，动态链接，方法出口等信息。栈帧由三部分组成：局部变量区（以一个字长为单位，用数组下标实现定位局部变量）、操作数栈（以一个字长为单位，用数组表示，但采用先进后出的策略）、帧数据区（用于常量池解析、正常方法返回以及异常派发机制）。&lt;br&gt;&amp;gt;&lt;br&gt;在java虚拟机规范中，对于这两个区域规定了两种情况的异常：1）如果线程请求的栈深度大于虚拟机所允许的深度将会抛出StackOverFlowError异常; 2）如果Java虚拟机可以动态扩展，当无法申请到足够的内存时会抛出OutOfMemeryError。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;本地方法栈（Native Method Stacks）&lt;br&gt;本地方法栈与Java虚拟机栈区别是Java虚拟机栈为虚拟机执行Java方法服务，而本地方法栈是虚拟机使用到的Native方法服务。如JNI引用的对象。所以本地方法栈也可能出现两种与Java虚拟机栈相同的异常。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Java堆（Java Heap）&lt;br&gt;Java堆是Java虚拟机管理的最大的一块内存区域，java堆是被所有Java线程共享的，在Java虚拟机启动时创建，此内存的唯一目的就是存放对象实例。几乎所有的对象实例都要分配在堆中，垃圾回收的主要区域就是这里（还可能有方法区）。（随着JIT编译器的发展，逃逸分析技术的逐渐成熟，栈上分配，标量替换等优化技术，使得部分对象不再分配在堆上。）JNI调用的程序new的空间不受这里管理。&lt;br&gt;Java堆的大小通过:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;-Xmx和-Xms两个参数控制。但是当堆的内存再无法扩展时，就会出现OutOfMemeryError。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;方法区（Method Area）&lt;br&gt;方法区与Java堆一样，是各个线程共享的内存区域，他用于存储类信息，常量，静态变量以及及时编译后的代码等数据。当方法区无法满足内存分配需求时，将抛出OutOfMemeryError.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;简图&lt;/p&gt;
&lt;center&gt;&lt;br&gt;&lt;img src=&quot;http://img.blog.csdn.net/20170311204212679?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ3VndWd1amlhd2Vp/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;&gt;&lt;br&gt;&lt;/center&gt;&lt;/li&gt;
&lt;li&gt;相关测试方法&lt;center&gt;&lt;br&gt;&lt;img src=&quot;http://img.blog.csdn.net/20170311204320601?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ3VndWd1amlhd2Vp/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;&gt;&lt;br&gt;&lt;/center&gt;

&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;Java类加载机制&quot;&gt;&lt;a href=&quot;#Java类加载机制&quot; class=&quot;headerlink&quot; title=&quot;Java类加载机制&quot;&gt;&lt;/a&gt;Java类加载机制&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;什么是类的加载&lt;br&gt;类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个java.lang.Class对象，用来封装类在方法区内的数据结构。类的加载的最终产品是位于堆区中的Class对象，Class对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口。&lt;/li&gt;
&lt;/ul&gt;
&lt;center&gt;&lt;br&gt;&lt;img src=&quot;http://images2015.cnblogs.com/blog/331425/201606/331425-20160621125941772-1913742708.png&quot; alt=&quot;此处输入图片的描述&quot;&gt;&lt;br&gt;&lt;/center&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;类加载的时机&lt;br&gt;类加载器并不需要等到某个类被“首次主动使用”时再加载它，JVM规范允许类加载器在预料某个类将要被使用时就预先加载它，如果在预先加载的过程中遇到了.class文件缺失或存在错误，类加载器必须在程序首次主动使用该类时才报告错误（LinkageError错误）如果这个类一直没有被程序主动使用，那么类加载器就不会报告错误。&lt;br&gt;参考：&lt;a href=&quot;http://www.cnblogs.com/ityouknow/p/5603287.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.cnblogs.com/ityouknow/p/5603287.html&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;类加载流程&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;装载：查找和导入Class文件；&lt;/li&gt;
&lt;li&gt;链接：把类的二进制数据合并到JRE中；&lt;ol&gt;
&lt;li&gt;校验：检查载入Class文件数据的正确性；&lt;/li&gt;
&lt;li&gt;准备：给类的静态变量分配存储空间，并将其初始化为默认值，普通static为0，final static为设定值；&lt;/li&gt;
&lt;li&gt;解析：将符号引用转成直接引用；&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;初始化：对类的静态变量，静态代码块执行初始化操作&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;在这五个阶段中，加载、验证、准备和初始化这四个阶段发生的顺序是确定的，而解析阶段则不一定，它在某些情况下可以在初始化阶段之后开始，这是为了支持Java语言的运行时绑定（也成为动态绑定或晚期绑定）。&lt;br&gt;另外注意这里的几个阶段是按顺序开始，而不是按顺序进行或完成，因为这些阶段通常都是互相交叉地混合进行的，通常在一个阶段执行的过程中调用或激活另一个阶段。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;三个类加载器&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Bootstrap ClassLoader&lt;br&gt;根类加载器，负责核心类的加载，如System,String等，还有jdk中jre的lib目录的rt.jar,也可以通过指定参数-Xbootclasspath再加;&lt;/li&gt;
&lt;li&gt;Extension ClassLoader&lt;br&gt;扩展类加载器，负责jdk中jre的lib目录下的ext目录，或者通过-Djava.ext.dirs再加；&lt;/li&gt;
&lt;li&gt;Application ClassLoader&lt;br&gt;用于加载用户路径上指定的类库。由-classpath或-cp选项定义,或者是JAR中的Manifest的classpath属性定义。&lt;/li&gt;
&lt;li&gt;Tip:&lt;ul&gt;
&lt;li&gt;用户自定义类加载器，默认情况下父加载器是系统类加载器，也可以指定其它两个。&lt;/li&gt;
&lt;li&gt;Tomcat 为每个 App 创建一个 Loader,里面保存着此 WebApp 的 ClassLoader。需要加载 WebApp 下的类时,就取出 ClassLoader 来使用&lt;/li&gt;
&lt;li&gt;JVM在判定两个class是否相同时（相等包括代表类的Class对象的equals()方法、isAssignableFrom()方法、isInstance()方法、instanceof关键字的结果），不仅要判断两个类名是否相同，而且要判断是否由同一个类加载器实例加载的。&lt;/li&gt;
&lt;li&gt;类加载器相关例子：&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;Object obj = myClassLoader.loadClass(&lt;span class=&quot;string&quot;&gt;&quot;com.test.ClassLoaderTest&quot;&lt;/span&gt;).newInstance();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;System.out.println(obj.getClass());&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// return false&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// com.test.ClassLoaderTest类默认使用Application ClassLoader加载，而obj是通过自定义类加载器加载的，类加载不相同，因此不相等&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;System.out.println(obj &lt;span class=&quot;keyword&quot;&gt;instanceof&lt;/span&gt; com.test.ClassLoaderTest);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;双亲委托模型&lt;br&gt;应用程序都是由以上三种类加载器互相配合进行加载的，还可以加入自己定义的类加载器，称为类加载器的双亲委派模型。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;类加载器之间的父子关系一般不会以继承的关系来实现，而是都使用组合关系来复用父加载器的。&lt;/li&gt;
&lt;li&gt;ClassLoader本身没有父类加载器，但可以用作其它ClassLoader实例的的父类加载器。&lt;ol&gt;
&lt;li&gt;当一个ClassLoader实例需要加载某个类时，先把这个任务委托给它的父类加载器，这个过程是由上至下依次检查的，首先由最顶层的类加载器Bootstrap ClassLoader试图加载，如果没加载到，则把任务转交给Extension ClassLoader试图加载，如果也没加载到，则转交给App ClassLoader 进行加载;&lt;/li&gt;
&lt;li&gt;如果它也没有加载得到的话，则返回给委托的发起者，由它到指定的文件系统或网络等URL中加载该类。如果它们都没有加载到这个类时，则抛出ClassNotFoundException异常。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;为什么要使用双亲委托这种模型呢？&lt;center&gt;&lt;br&gt;&lt;img src=&quot;http://images.cnitblog.com/blog/452797/201504/042100320143771.png&quot; alt=&quot;此处输入图片的描述&quot;&gt;&lt;br&gt;&lt;img src=&quot;http://images.cnitblog.com/blog/452797/201504/042100326398413.png&quot; alt=&quot;此处输入图片的描述&quot;&gt;&lt;br&gt;&lt;/center&gt;

&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;JVM的GC&quot;&gt;&lt;a href=&quot;#JVM的GC&quot; class=&quot;headerlink&quot; title=&quot;JVM的GC&quot;&gt;&lt;/a&gt;JVM的GC&lt;/h2&gt;&lt;h3 id=&quot;垃圾回收算法&quot;&gt;&lt;a href=&quot;#垃圾回收算法&quot; class=&quot;headerlink&quot; title=&quot;垃圾回收算法&quot;&gt;&lt;/a&gt;垃圾回收算法&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Mark-Sweep（标记-清除）算法&lt;br&gt;  分标记和回收两个阶段，内存碎片问题。&lt;/li&gt;
&lt;li&gt;Copying（复制）算法&lt;br&gt;  内存空间利用率不高。&lt;/li&gt;
&lt;li&gt;Mark-Compact（标记-整理）算法&lt;br&gt;  分标记和整理两个阶段，弥补Copying算法的缺陷，标记后移动，再清除。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以上三种是传统最常见的方法，具体演示参考：&lt;br&gt;&lt;a href=&quot;http://www.cnblogs.com/dolphin0520/p/3783345.htm&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.cnblogs.com/dolphin0520/p/3783345.htm&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;分代回收算法&lt;br&gt;在Hotspot JVM中采用分代回收，现在在各种其它JVM中也比较常用。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;JVM区域的划分（Java1.7）&lt;br&gt;从GC的角度，jvm区域总体分两类，heap区（Java堆）和非heap区（其它）。&lt;ul&gt;
&lt;li&gt;heap区：Eden Space（伊甸园）、Survivor Space(幸存者区)、Tenured Gen（老年代-养老区）；eden和survivor默认比例是8:1:1（新生代实际可用的内存空间为 9/10（即90%）的新生代空间）。&lt;/li&gt;
&lt;li&gt;非heap区：CodeCache(代码缓存区)、PermGen（永久代）等。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;关于永久代（主要存放的是Java类定义信息，生成大量动态类可能溢出）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当永久代满时也会引发Full GC，会导致Class、Method元信息的卸载，一般需要避免，因此就不会发生GC了；&lt;/li&gt;
&lt;li&gt;Java8不设永久代，类的元信息等被移到了一个与堆不相连的本地内存区域，这个区域就是元空间（metaspace）。&lt;blockquote&gt;
&lt;p&gt;a. 对永久代进行调优是很困难的，永久代中的元数据可能会随着每一次FullGC发生而进行移动。并且为永久代设置空间大小也是很难确定的，因为这其中有很多影响因素，比如类的总数，常量池的大小和方法数量等。b. 同时，HotSpot虚拟机的每种类型的垃圾回收器都需要特殊处理永久代中的元数据。将元数据从永久代剥离出来，不仅实现了对元空间的无缝管理，还可以简化Full GC以及对以后的并发隔离类元数据等方面进行优化。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如何分代回收&lt;br&gt;&lt;center&gt;&lt;br&gt;&lt;img src=&quot;http://img.blog.csdn.net/20150315170424355?%20%20watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdG9ueXRmamluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/%20%20dissolve/70/gravity/Center&quot; alt=&quot;此处输入图片的描述&quot;&gt;&lt;br&gt;&lt;/center&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Minor GC：&lt;br&gt;当Eden区满时，触发Minor GC。新生代采用了&lt;strong&gt;复制算法&lt;/strong&gt;，分为一个Eden 区域和两个Survivor区域，真正使用的是一个Eden区域和一个Survivor区域，GC的时候，会把存活的对象放入到另外一个Survivor区域中（总有一块保持为空作为to，用于复制，满就复制到老年区），然后再把这个Eden区域和Survivor区域清除。&lt;br&gt;在发生Minor GC之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代(年轻代被分为3个部分——Enden区和两个Survivor区（From和to）)所有对象的总空间（这一段似乎有误，有说法是说survival from和to区是否够）：&lt;ol&gt;
&lt;li&gt;如果大于则进行Minor GC;&lt;/li&gt;
&lt;li&gt;如果小于则看HandlePromotionFailure设置是否允许担保失败。&lt;ol&gt;
&lt;li&gt;如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于则尝试Minor GC（如果尝试失败也会触发Full GC），如果小于则进行Full GC。&lt;/li&gt;
&lt;li&gt;如果不允许，则直接Full GC。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;如何晋升为老年代：多次Minor GC后还存活的对象会晋升。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;Major GC：&lt;br&gt;清理老年代，许多是由 Minor GC 触发的，老年代采用的是Mark-Compact（标记-整理）算法(HotSpot VM，其它的JVM实现并不一定是这样做的)。&lt;/li&gt;
&lt;li&gt;Full GC：&lt;br&gt;老年代空间不足：如上分析，要么是前期的检查，要么是晋升期间。当频繁Full GC时，可通过jstat、GC日志、对象内存工具等查看是什么原因，例如JMap查看。&lt;br&gt;据知乎：&lt;ol&gt;
&lt;li&gt;fullgc频繁说明old区很快满了，即剩余空间不足（来的多或留的多）。&lt;/li&gt;
&lt;li&gt;如果是一次fullgc后，剩余对象不多。那么说明你eden区设置太小，导致短生命周期的对象进入了old区。&lt;/li&gt;
&lt;li&gt;如果一次fullgc后，old区回收率不大，那么说明old区太小。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;哪些对象需要回收&lt;br&gt;每个应用程序都包含一组根（root）。每个根包含指向引用类型对象的一个指针，该指针要么引用托管堆中的一个对象，要么为null，GC会收集那些不是GC roots且没有被GC roots引用的对象。&lt;br&gt;java中可作为GC Root的对象有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;虚拟机栈中引用的对象（本地变量表）；&lt;/li&gt;
&lt;li&gt;本地方法栈中引用的对象（Native对象）;&lt;/li&gt;
&lt;li&gt;方法区中静态属性引用的对象；&lt;/li&gt;
&lt;li&gt;方法区中常量引用的对象（对比而言单例可能会被回收）；&lt;br&gt;参考： &lt;a href=&quot;http://www.importnew.com/15820.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.importnew.com/15820.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;垃圾回收器&quot;&gt;&lt;a href=&quot;#垃圾回收器&quot; class=&quot;headerlink&quot; title=&quot;垃圾回收器&quot;&gt;&lt;/a&gt;垃圾回收器&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Serial/Serial Old&lt;/li&gt;
&lt;li&gt;ParNew&lt;/li&gt;
&lt;li&gt;Parallel Scavenge&lt;/li&gt;
&lt;li&gt;Parallel Old&lt;/li&gt;
&lt;li&gt;CMS&lt;br&gt;CMS（Current Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器，它是一种并发收集器，采用的是Mark-Sweep算法，默认的回收线程数是(CPU个数+3)/4。CMS的缺点也比较明显，CMS会牺牲更多的硬件资源、吞吐量及Heap使用量等，所以在Java1.7之后引入了G1 收集器来全面替代CMS。&lt;/li&gt;
&lt;li&gt;G1(1.7开始引进)&lt;br&gt;G1收集器是当今收集器技术发展最前沿的成果，它是一款面向服务端应用的收集器，它能充分利用多CPU、多核环境。因此它是一款并行与并发收集器，并且它能建立可预测的停顿时间模型。整体上是基于标记整理，局部采用复制回收算法。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;什么时候触发GC：&lt;a href=&quot;http://www.tuicool.com/articles/3yuqMzz&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.tuicool.com/articles/3yuqMzz&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;泛型擦除&quot;&gt;&lt;a href=&quot;#泛型擦除&quot; class=&quot;headerlink&quot; title=&quot;泛型擦除&quot;&gt;&lt;/a&gt;泛型擦除&lt;/h2&gt;&lt;p&gt;泛型可以说是Java中最常用的语法糖之一，因此虚拟机是不支持这些语法，在编译时转化为Object，继承的时候利用桥方法动态调用，据此应考虑泛型在开发过程中的约束和局限性。具体用法解释可参考&lt;strong&gt;【Java基础篇】&lt;/strong&gt;。&lt;/p&gt;
&lt;h1 id=&quot;多线程&quot;&gt;&lt;a href=&quot;#多线程&quot; class=&quot;headerlink&quot; title=&quot;多线程&quot;&gt;&lt;/a&gt;多线程&lt;/h1&gt;&lt;p&gt;&lt;em&gt;更多内容请查看Java实践篇&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&quot;锁&quot;&gt;&lt;a href=&quot;#锁&quot; class=&quot;headerlink&quot; title=&quot;锁&quot;&gt;&lt;/a&gt;锁&lt;/h2&gt;&lt;h3 id=&quot;内置锁&quot;&gt;&lt;a href=&quot;#内置锁&quot; class=&quot;headerlink&quot; title=&quot;内置锁&quot;&gt;&lt;/a&gt;内置锁&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;synchronized&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于类而言，静态方法的锁是Test.class,而普通方法的锁是this。如果对类中的两个方法用synchronized进行修饰，要么都是静态的，或都是成员方法，这两个方法才会同步，如下例子，类中的普通成员方法都采用this作为锁对象。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Test&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; in value;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;synchronized&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; value;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;sychronized &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; value)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.value = value;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;显式锁&quot;&gt;&lt;a href=&quot;#显式锁&quot; class=&quot;headerlink&quot; title=&quot;显式锁&quot;&gt;&lt;/a&gt;显式锁&lt;/h3&gt;&lt;p&gt;java.util.concurrent.locks包中定义了两个锁类，ReentrantLock和ReentrantReadWriteLock类。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;ReentrantReadWriteLock&lt;br&gt;在读多于写的情况下，利用读写锁分离访问。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; ReentrantReadWriteLock rwl = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ReentrantReadWriteLock();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; Lock readLock = rwl.readLock();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; Lock writeLock = rwl.writeLock();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;getTotalBalance&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    readLock.lock();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt;&amp;#123;...&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;finally&lt;/span&gt;&amp;#123;readLock.unlock();&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;setBalance&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    writeLock.lock();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt;&amp;#123;...&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;finally&lt;/span&gt;&amp;#123;writeLock.unlock();&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;ReentantLock&lt;br&gt;类似的，也是需要lock(),并在finally中unlock(),而一般常用的方法，是将其与Condition配合使用，使线程在某些情况下，挂起等待，某些情况下，被唤醒。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; Lock suspendLock = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ReentranLock();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; Condition suspendCondition = suspendLock.newCondition();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 在某个安全操作下&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;getTotalBalance&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    suspendLock.lock();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(a==&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            suspendCondition.await(); &lt;span class=&quot;comment&quot;&gt;// 暂时放弃锁&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;finally&lt;/span&gt;&amp;#123;suspendLock.unlock();&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;setBalance&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    suspendLock.lock(); &lt;span class=&quot;comment&quot;&gt;// 尝试获得锁，假如某个操作线程放弃锁就继续执行&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// do someting&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        a++;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        suspendCondition.signalAll(); &lt;span class=&quot;comment&quot;&gt;// 唤醒其它线程&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;finally&lt;/span&gt;&amp;#123;suspendLock.unlock();&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;原子操作&quot;&gt;&lt;a href=&quot;#原子操作&quot; class=&quot;headerlink&quot; title=&quot;原子操作&quot;&gt;&lt;/a&gt;原子操作&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;除了long型字段和double型字段外，Java内存模型确保访问任意类型字段所对应的内存单元都是原子的。此外，volatile long 和volatile double也具有原子性。&lt;a href=&quot;http://docs.oracle.com/javase/specs/jls/se8/html/jls-17.html#jls-17.7&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Java编程规范的文档说明&lt;/a&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;对于64big的环境来说，单次操作可以操作64bit的数据，但在32bit操作系统下，指令单次操作能处理的最长长度为32bit，因此在读写的时候，JVM分成两次操作，每次读写32位。因为采用了这种策略，所以64位的long和double的读与写都不是原子操作。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;原子性不能确保获得的是任意线程写入之后的最新值，需要额外编程实现同步（原子和同步是不同的概念）。因此，原子性保证通常对并发程序设计的影响很小。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;协定&quot;&gt;&lt;a href=&quot;#协定&quot; class=&quot;headerlink&quot; title=&quot;协定&quot;&gt;&lt;/a&gt;协定&lt;/h3&gt;&lt;p&gt;每个共享的和可变的变量都应该只由一个锁来保护，从而维护人员知道是哪一个锁。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一种常见的加锁规定是，将所有的可变状态都封装在对象内部，并通过对象的内置锁对所有访问可变状态的代码路径进行同步，使得在该对象上不会发生并发访问。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;同步队列&quot;&gt;&lt;a href=&quot;#同步队列&quot; class=&quot;headerlink&quot; title=&quot;同步队列&quot;&gt;&lt;/a&gt;同步队列&lt;/h2&gt;&lt;h3 id=&quot;基本操作&quot;&gt;&lt;a href=&quot;#基本操作&quot; class=&quot;headerlink&quot; title=&quot;基本操作&quot;&gt;&lt;/a&gt;基本操作&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;peek：返回头元素，不删除，队列空为null&lt;br&gt;poll：返回头元素，删除，队列空为null&lt;br&gt;take：返回头元素，删除，队列空阻塞&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;offer：添加元素，队列满为false&lt;br&gt;put：添加元素，队列满阻塞&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;常用类&quot;&gt;&lt;a href=&quot;#常用类&quot; class=&quot;headerlink&quot; title=&quot;常用类&quot;&gt;&lt;/a&gt;常用类&lt;/h3&gt;&lt;p&gt;&lt;em&gt;每一个BlockingQueue都有一个容量，让容量满时往BlockingQueue中添加数据时会造成阻塞，当容量为空时取元素操作会阻塞。&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;LinkedBockingQueue&lt;br&gt;默认容量没有上限，也可以指定最大容量&lt;/li&gt;
&lt;li&gt;ArrayBlockingQueue&lt;br&gt;构造时需要指定容量&lt;/li&gt;
&lt;li&gt;PriorityBlockingQueue&lt;br&gt;堆的实现可利用PriorityQueue，这里加了Blocking，可以认为是多线程的版本。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;ArrayBlockingQueue-VS-LinkedBlockingQueue&quot;&gt;&lt;a href=&quot;#ArrayBlockingQueue-VS-LinkedBlockingQueue&quot; class=&quot;headerlink&quot; title=&quot;ArrayBlockingQueue VS LinkedBlockingQueue&quot;&gt;&lt;/a&gt;ArrayBlockingQueue VS LinkedBlockingQueue&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;队列中锁的实现不同&lt;br&gt;  ArrayBlockingQueue实现的队列中的锁是没有分离的，即生产和消费用的是同一个锁；&lt;br&gt;  LinkedBlockingQueue实现的队列中的锁是分离的，即生产用的是putLock，消费是takeLock，而在遍历以及删除元素则要两把锁都锁住。&lt;/li&gt;
&lt;li&gt;在生产或消费时操作不同&lt;br&gt;  ArrayBlockingQueue实现的队列中在生产和消费的时候，是直接将枚举对象插入或移除的；&lt;br&gt;  LinkedBlockingQueue实现的队列中在生产和消费的时候，需要把枚举对象转换为Node&lt;e&gt;进行插入或移除，会影响性能&lt;/e&gt;&lt;/li&gt;
&lt;li&gt;队列大小初始化方式不同&lt;br&gt;  ArrayBlockingQueue实现的队列中必须指定队列的大小；&lt;br&gt;  LinkedBlockingQueue实现的队列中可以不指定队列的大小，但是默认是Integer.MAX_VALUE（如果生产者的速度一旦大于消费者的速度，也许还没有等到队列满阻塞产生，系统内存就有可能已被消耗殆尽）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;线程间数据交互&quot;&gt;&lt;a href=&quot;#线程间数据交互&quot; class=&quot;headerlink&quot; title=&quot;线程间数据交互&quot;&gt;&lt;/a&gt;线程间数据交互&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Exchanger&lt;br&gt;同步的主要作用是保证一致性，或者说逻辑上的顺序性。但某些场景我们只是想两个线程共享数据，利用锁保证读写分离是没问题的，但还有更优雅的方式。&lt;br&gt;可在两个线程之间交换数据，只能是2个线程，他不支持更多的线程之间互换数据。实际上，一个线程向缓冲区填入数据，另一个线程消耗这些数据，一方线程完成操作，通过交换缓冲区的方式让另一个线程消费数据。如下，我们不必关系同步不同步的问题。&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;Exchanger&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; exchanger = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Exchanger&amp;lt;&amp;gt;();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Consumer(exchanger).start();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Producer(exchanger).start();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 内部操作&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;list = exchanger.exchange(list);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;具体例子参考：&lt;a href=&quot;http://blog.csdn.net/andycpp/article/details/8854593&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.csdn.net/andycpp/article/details/8854593&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;障栅&lt;br&gt;例如我们想所有线程运行到某个点，再做合并操作（类似MapReduce），可以考虑用CyclicBarrier类，与内存栅障类似：运算线程集内的线程必须等待该集合中所有其他线程都执行完某个运算后，才能继续向下执行。确保在所有线程全部到达某个逻辑执行点前，任何线程都不能越过该逻辑点。当一个线程运行完它那部分，则让其运行到障栅出，&lt;strong&gt;一旦所有线程都到达了这个障栅，障栅自动撤销，所有线程继续运行&lt;/strong&gt;。&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 表示至少三个线程到障栅才释放&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;CyclicBarrier barrier = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; CyclicBarrier(&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 传到每个线程的run方法中&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;doWork();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;barrier.await();&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对比CountDownLatch：闭锁用来等待事件，而栅栏用于等待其他线程，大家相互等待，只要有一个没完成，所有人都得等着。即闭锁用来等待的事件就是countDown事件,只有该countDown事件执行后所有之前在等待的线程才有可能继续执行;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;信号量（Semaphores）&lt;br&gt;当一个线程想要访问某个共享资源，首先，它必须获得semaphore。如果semaphore的内部计数器的值大于0，那么semaphore减少计数器的值并允许访问共享的资源。计数器的值大于0表示，有可以自由使用的资源，所以线程可以访问并使用它们。&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; Semaphore semaphore;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Class&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    semaphore = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Semaphore(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// in function&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    semaphore.acquire();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// do something&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125; &lt;span class=&quot;keyword&quot;&gt;catch&lt;/span&gt; (InterruptedException e) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    e.printStackTrace();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;span class=&quot;keyword&quot;&gt;finally&lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    semaphore.release();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;线程池&quot;&gt;&lt;a href=&quot;#线程池&quot; class=&quot;headerlink&quot; title=&quot;线程池&quot;&gt;&lt;/a&gt;线程池&lt;/h2&gt;&lt;p&gt;常用例子:&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; java.util.concurrent.ExecutorService;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; java.util.concurrent.Executors;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;ExecutorService executor = Executors.newFixedThreadPool(&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 实现Runnable接口&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Runnable runner = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ExecutorThread();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;executor.execute(runner);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;类的介绍&quot;&gt;&lt;a href=&quot;#类的介绍&quot; class=&quot;headerlink&quot; title=&quot;类的介绍&quot;&gt;&lt;/a&gt;类的介绍&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Executor&lt;br&gt;接口，该 &lt;a href=&quot;https://github.com/enjoyhot/jdk-online/blob/master/1.8/java/util/concurrent/Executor.java&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;接口&lt;/a&gt; 只包含一个方法：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;execute&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Runnable command)&lt;/span&gt;&lt;/span&gt;;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;ExecutorService&lt;br&gt;也是一个接口，继承Executor接口。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ExecutorService&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Executor&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Executors&lt;br&gt;Executors类，提供了一系列工厂方法用于创建线程池，返回的线程池都实现了ExecutorService接口。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;ThreadPoolExecutor&quot;&gt;&lt;a href=&quot;#ThreadPoolExecutor&quot; class=&quot;headerlink&quot; title=&quot;ThreadPoolExecutor&quot;&gt;&lt;/a&gt;ThreadPoolExecutor&lt;/h3&gt;&lt;p&gt;继承ExecutorService接口，Executors工厂类中提供的线程池的底层实现，所以自定义灵活度高，通常建议用Executors已经配置好了的。继承关系简单如下所示：&lt;/p&gt;
&lt;center&gt;&lt;br&gt;&lt;img src=&quot;http://mingxinglai.com/cn/image/executor1.png&quot; alt=&quot;此处输入图片的描述&quot;&gt;&lt;br&gt;&lt;/center&gt;

&lt;p&gt;如下最常见的newFixedThreadPool方法&lt;a href=&quot;https://github.com/enjoyhot/jdk-online/blob/master/1.8/java/util/concurrent/Executors.java#L88&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;源码&lt;/a&gt;:&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; ExecutorService &lt;span class=&quot;title&quot;&gt;newFixedThreadPool&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; nThreads)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ThreadPoolExecutor(nThreads, nThreads,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                                  &lt;span class=&quot;number&quot;&gt;0L&lt;/span&gt;, TimeUnit.MILLISECONDS,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                                  &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; LinkedBlockingQueue&amp;lt;Runnable&amp;gt;());&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;corePoolSize&lt;br&gt;线程池的基本大小，如果当前线程数目小于该配置，无论是否其中有空闲的线程，都会给新的任务产生新的线程。&lt;br&gt;如果刚好等于或大于，会尝试将新任务添加到任务缓存队列当中，若添加成功，则该任务会等待空闲线程将其取出去执行；若添加失败（一般来说是任务缓存队列已满），则会尝试创建新的线程去执行这个任务；&lt;/li&gt;
&lt;li&gt;maximumPoolSize&lt;br&gt;线程池中允许的最大线程数，线程池中的当前线程数目不会超过该值。如果队列中任务已满，并且当前线程个数小于maximumPoolSize，那么会创建新的线程来执行任务。如果线程数目达到maximumPoolSize，一般意味着队列也已经满了，则会采取任务拒绝策略进行处理。形象一点可看下图；&lt;/li&gt;
&lt;li&gt;keepAliveTime&lt;br&gt;线程空闲时间超过keepAliveTime，线程将被终止。&lt;/li&gt;
&lt;li&gt;poolSize&lt;br&gt;线程池中当前线程的数量。&lt;/li&gt;
&lt;/ul&gt;
&lt;center&gt;&lt;br&gt;&lt;img src=&quot;http://cdn4.infoqstatic.com/statics_s2_20150819-0313/resource/articles/java-threadPool/zh/resources/threadpool.jpg&quot; alt=&quot;此处输入图片的描述&quot;&gt;&lt;br&gt;&lt;/center&gt;

&lt;p&gt;&lt;strong&gt;线程池中的线程初始化：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;默认情况下，创建线程池之后，线程池中是没有线程的，需要提交任务之后才会创建线程。在实际中如果需要线程池创建之后立即创建线程，可以通过以下两个方法做到：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;prestartCoreThread()&lt;br&gt;初始化一个核心线程；&lt;/li&gt;
&lt;li&gt;prestartAllCoreThreads()&lt;br&gt;初始化所有核心线程&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;重要的方法：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;execute()&lt;br&gt;无返回值。&lt;/li&gt;
&lt;li&gt;submit()&lt;br&gt;利用了Future来获取任务执行结果。&lt;/li&gt;
&lt;li&gt;shutdown()&lt;br&gt;关闭线程池。&lt;/li&gt;
&lt;li&gt;shutdownNow()&lt;br&gt;关闭线程池。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;创建线程池的常用方法&quot;&gt;&lt;a href=&quot;#创建线程池的常用方法&quot; class=&quot;headerlink&quot; title=&quot;创建线程池的常用方法&quot;&gt;&lt;/a&gt;创建线程池的常用方法&lt;/h3&gt;&lt;p&gt;正如例子所述，可利用Executors工厂类快速创建线程池。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;newCachedThreadPool&lt;br&gt;创建一个无界可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。&lt;/li&gt;
&lt;li&gt;newFixedThreadPool&lt;br&gt;创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。corePoolSize和maximumPoolSize的大小是一样的，而queue是无界的&lt;/li&gt;
&lt;li&gt;newScheduledThreadPool&lt;br&gt;创建一个定长线程池，支持定时及周期性任务执行。&lt;/li&gt;
&lt;li&gt;newSingleThreadExecutor&lt;br&gt;创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;Tips&quot;&gt;&lt;a href=&quot;#Tips&quot; class=&quot;headerlink&quot; title=&quot;Tips&quot;&gt;&lt;/a&gt;Tips&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;如果你提交任务时，线程池队列已满。会时发会生什么？&lt;br&gt;许多人可能会认为该任务会阻塞直到线程池队列有空位。事实上如果一个任务不能被调度执行那么ThreadPoolExecutor的submit()方法将会抛出一个RejectedExecutionException异常。&lt;/li&gt;
&lt;li&gt;Java线程池中submit() 和 execute()方法有什么区别？&lt;br&gt;两个方法都可以向线程池提交任务，execute()方法的返回类型是void，它定义在Executor接口中,而submit()方法可以返回持有计算结果的Future对象，它定义在ExecutorService接口中，它扩展了Executor接口，其它线程池类像ThreadPoolExecutor和ScheduledThreadPoolExecutor都有这些方法。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;Java-IO&quot;&gt;&lt;a href=&quot;#Java-IO&quot; class=&quot;headerlink&quot; title=&quot;Java IO&quot;&gt;&lt;/a&gt;Java IO&lt;/h1&gt;&lt;h2 id=&quot;同步与阻塞&quot;&gt;&lt;a href=&quot;#同步与阻塞&quot; class=&quot;headerlink&quot; title=&quot;同步与阻塞&quot;&gt;&lt;/a&gt;同步与阻塞&lt;/h2&gt;&lt;p&gt;参考：&lt;a href=&quot;http://www.cnblogs.com/dolphin0520/p/3916526.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.cnblogs.com/dolphin0520/p/3916526.html&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;IO请求分两个阶段：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;查看数据是否就绪；&lt;/li&gt;
&lt;li&gt;进行数据拷贝（内核将数据拷贝到用户线程）；&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;同步与异步&quot;&gt;&lt;a href=&quot;#同步与异步&quot; class=&quot;headerlink&quot; title=&quot;同步与异步&quot;&gt;&lt;/a&gt;同步与异步&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;关键：内核发送通知&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;多个任务和事件发生时，一个事件的发生或执行是否会导致整个流程的暂时等待。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于同步而言，是需要用户线程或内核去轮询，当数据就绪时，再将数据从内核拷贝到用户空间。&lt;/li&gt;
&lt;li&gt;对于异步而言，IO两个阶段都由内核完成，然后&lt;strong&gt;发送通知&lt;/strong&gt;告知用户，由内核主动拷贝数据到用户线程，可见异步需要操作系统底层的支持；&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;阻塞与非阻塞&quot;&gt;&lt;a href=&quot;#阻塞与非阻塞&quot; class=&quot;headerlink&quot; title=&quot;阻塞与非阻塞&quot;&gt;&lt;/a&gt;阻塞与非阻塞&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;关键：操作返回标志位&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于阻塞而言，用户线程一直等待数据，直到就绪；&lt;/li&gt;
&lt;li&gt;对于非阻塞而言，用户线程读取数据，立即返回标志位告知用户线程当前IO状态，下次再读取数据了，一旦就绪，内核就将数据拷贝到用户线程。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;多路复用&quot;&gt;&lt;a href=&quot;#多路复用&quot; class=&quot;headerlink&quot; title=&quot;多路复用&quot;&gt;&lt;/a&gt;多路复用&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;select&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;遍历，效率线性下降；&lt;/li&gt;
&lt;li&gt;支持的文件描述符数量太小，为1024；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;poll&lt;br&gt;使用pollfd结构而不是select的fd_set结构,其它方面非常相似&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;epoll&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;水平触发&lt;br&gt;LT(level triggered)水平触发：是缺省的工作方式，并且同时支持block和no-block socket.当被监控的文件描述符上有可读写事件发生时，epoll_wait()会通知处理程序去读写。如果你不作任何操作或没读写完，那么下次调用 epoll_wait()时，内核还是会继续通知你的，所以，这种模式编程出错误可能性要小一点。&lt;/li&gt;
&lt;li&gt;边缘触发&lt;br&gt;ET(edge-triggered)边缘触发：是高速工作方式，只支持no-block socket。在这种模式下，当描述符从未就绪变为就绪时，内核通过epoll告诉你。然后它会假设你知道文件描述符已经就绪，并且不会再为那个文件描述符发送更多的就绪通知，直到你做了某些操作导致那个文件描述符不再为就绪状态了。这种模式比水平触发效率高，系统不会充斥大量你不关心的就绪文件描述符。&lt;br&gt;参考 &lt;a href=&quot;http://www.tuicool.com/articles/VvU7fum&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.tuicool.com/articles/VvU7fum&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在Netty权威指南中写道：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;socket描述符数量受限&lt;/li&gt;
&lt;li&gt;需要扫描所有的socket集合，在网络较差（如Wide Area Network-WAN），epoll效率远在前者之上，得益于epoll只有在活跃的socket上才会调用callback函数，而不是轮询。&lt;/li&gt;
&lt;li&gt;epoll是将内核和用户空间通过mmap（内存映射）同一块内存实现FD消息在内核和用户空间的交互，从而避免不必要的内存拷贝。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;BIO-NIO-AIO&quot;&gt;&lt;a href=&quot;#BIO-NIO-AIO&quot; class=&quot;headerlink&quot; title=&quot;BIO,NIO,AIO&quot;&gt;&lt;/a&gt;BIO,NIO,AIO&lt;/h2&gt;&lt;p&gt;推荐阅读：&lt;a href=&quot;http://tutorials.jenkov.com/java-nio/index.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;java-nio tutorials&lt;/a&gt;，更多补充及应用场景参考【Java实践篇】。&lt;/p&gt;
&lt;h3 id=&quot;BIO&quot;&gt;&lt;a href=&quot;#BIO&quot; class=&quot;headerlink&quot; title=&quot;BIO&quot;&gt;&lt;/a&gt;BIO&lt;/h3&gt;&lt;p&gt;同步并阻塞，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，当然可以通过线程池机制改善。&lt;/p&gt;
&lt;h3 id=&quot;NIO&quot;&gt;&lt;a href=&quot;#NIO&quot; class=&quot;headerlink&quot; title=&quot;NIO&quot;&gt;&lt;/a&gt;NIO&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;同步非阻塞IO(Java NIO)&lt;br&gt;服务器实现模式为一个请求一个线程，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I/O请求时才启动一个线程进行处理。用户进程也需要时不时的询问IO操作是否就绪，这就要求用户进程不停的去询问。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;异步阻塞IO（Java NIO）&lt;br&gt;应用发起一个IO操作以后，不等待内核IO操作的完成，等内核完成IO操作以后会通知应用程序，这其实就是同步和异步最关键的区别，同步必须等待或者主动的去询问IO是否完成，那么为什么说是阻塞的呢？因为此时是通过select系统调用来完成的，而select函数本身的实现方式是阻塞的，而采用select函数有个好处就是它可以同时监听多个文件句柄（如果从UNP的角度看，select属于同步操作。因为select之后，进程还需要读写数据），从而提高系统的并发性。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;Java-AIO-NIO-2&quot;&gt;&lt;a href=&quot;#Java-AIO-NIO-2&quot; class=&quot;headerlink&quot; title=&quot;Java AIO(NIO.2)&quot;&gt;&lt;/a&gt;Java AIO(NIO.2)&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;异步非阻塞IO&lt;br&gt;在此种模式下，用户进程只需要发起一个IO操作然后立即返回，等IO操作真正的完成以后，应用程序会得到IO操作完成的通知，此时用户进程只需要对数据进行处理就好了，不需要进行实际的IO读写操作，因为真正的IO读取或者写入操作已经由内核完成了。&lt;/li&gt;
&lt;/ul&gt;
&lt;center&gt;&lt;br&gt;&lt;img src=&quot;http://ifeve.com/wp-content/uploads/2013/06/overview-selectors.png&quot; alt=&quot;此处输入图片的描述&quot;&gt;&lt;br&gt;&lt;/center&gt;

&lt;h1 id=&quot;Java安全&quot;&gt;&lt;a href=&quot;#Java安全&quot; class=&quot;headerlink&quot; title=&quot;Java安全&quot;&gt;&lt;/a&gt;Java安全&lt;/h1&gt;&lt;p&gt;&lt;em&gt;待补充&lt;/em&gt;&lt;/p&gt;
&lt;h1 id=&quot;设计模式&quot;&gt;&lt;a href=&quot;#设计模式&quot; class=&quot;headerlink&quot; title=&quot;设计模式&quot;&gt;&lt;/a&gt;设计模式&lt;/h1&gt;&lt;h2 id=&quot;分类&quot;&gt;&lt;a href=&quot;#分类&quot; class=&quot;headerlink&quot; title=&quot;分类&quot;&gt;&lt;/a&gt;分类&lt;/h2&gt;&lt;p&gt;共23种设计模式可分为三类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;创建型模式&lt;br&gt;简单工厂模式（Simple Factory）(不属于23种设计模式)&lt;br&gt;工厂方法模式（Factory Method）&lt;br&gt;抽象工厂模式（Abstract Factory）&lt;br&gt;创建者模式（Builder）&lt;br&gt;原型模式（Prototype）&lt;br&gt;单例模式（Singleton）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;结构型模式&lt;br&gt;外观模式/门面模式（Facade门面模式）&lt;br&gt;适配器模式（Adapter）&lt;br&gt;代理模式（Proxy）&lt;br&gt;装饰模式（Decorator）&lt;br&gt;桥梁模式/桥接模式（Bridge）&lt;br&gt;组合模式（Composite）&lt;br&gt;享元模式（Flyweight）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;行为型模式&lt;br&gt;模板方法模式（Template Method）&lt;br&gt;观察者模式（Observer）&lt;br&gt;状态模式（State）&lt;br&gt;策略模式（Strategy）&lt;br&gt;职责链模式（Chain of Responsibility）&lt;br&gt;命令模式（Command）&lt;br&gt;访问者模式（Visitor）&lt;br&gt;调停者模式（Mediator）&lt;br&gt;备忘录模式（Memento）&lt;br&gt;迭代器模式（Iterator）&lt;br&gt;解释器模式（Interpreter）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;几种常见设计模式&quot;&gt;&lt;a href=&quot;#几种常见设计模式&quot; class=&quot;headerlink&quot; title=&quot;几种常见设计模式&quot;&gt;&lt;/a&gt;几种常见设计模式&lt;/h2&gt;&lt;h3 id=&quot;观察者模式&quot;&gt;&lt;a href=&quot;#观察者模式&quot; class=&quot;headerlink&quot; title=&quot;观察者模式&quot;&gt;&lt;/a&gt;观察者模式&lt;/h3&gt;&lt;p&gt;一个实现主题接口Observable的类subject，可以往里面注册多个观察者Observer（List维护），名义上由观察者传入(订阅)subject，实际上观察者中还要调用subject的方法register：&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;subject s = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; subject();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; observer(s);  &lt;span class=&quot;comment&quot;&gt;// 其中调用register(this)，s.get等&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;s 做其它事情，并触发其中的方法把List中的对象进行逐一调用。&lt;/p&gt;
&lt;h3 id=&quot;装饰者模式&quot;&gt;&lt;a href=&quot;#装饰者模式&quot; class=&quot;headerlink&quot; title=&quot;装饰者模式&quot;&gt;&lt;/a&gt;装饰者模式&lt;/h3&gt;&lt;p&gt;（如Java Stream各种类）&lt;br&gt;本质上通过使用虚类（强制实现方法，例如cost），不断继承形成“种类”，装饰器是继承虚类最终的方法类，组合“种类”和“装饰器”：构造函数传入“种类”对象即可构造新种类对象，配合该被装饰对象实现cost方法。&lt;/p&gt;
&lt;h3 id=&quot;工厂模式&quot;&gt;&lt;a href=&quot;#工厂模式&quot; class=&quot;headerlink&quot; title=&quot;工厂模式&quot;&gt;&lt;/a&gt;工厂模式&lt;/h3&gt;&lt;p&gt;（包括简单工厂，工厂方法，抽象工厂）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;本质上通过定义接口，将new对象封装在工厂中，而不是暴露在外面具体方法，通过传入type判断需要new什么对象（工厂方法对这些类实现共同接口），缺点就是对于新加类需要修改工厂创建对象的方法；&lt;/li&gt;
&lt;li&gt;工厂方法就是直接在外面new一个对象，这个对象实现某个接口，然后通过固定方法返回特定类型对象；&lt;/li&gt;
&lt;li&gt;抽象工厂方法侧重表示通过顶级接口、接口中工厂方法，来强制所有具体工厂需要实现某些方法。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;单例模式&quot;&gt;&lt;a href=&quot;#单例模式&quot; class=&quot;headerlink&quot; title=&quot;单例模式&quot;&gt;&lt;/a&gt;单例模式&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;优点：&lt;ol&gt;
&lt;li&gt;节省内存资源（只有在用这个实例调用方法时，方法才被加入到内存中，当对象不用的时候，gc会将方法回收，效率高了很多，而static常驻内存，但话不能这么说，单例需要在堆中申请资源，static不用）；&lt;/li&gt;
&lt;li&gt;提供了对唯一实例的受控访问，因此便于控制；&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;主要缺点：&lt;ol&gt;
&lt;li&gt;由于单例模式中没有抽象层（个人认为Java中的通过接口，虚类等实现的逻辑就是抽象层的表现），因此单例类的扩展有很大的困难。&lt;/li&gt;
&lt;li&gt;单例类的职责过重，在一定程度上违背了“单一职责原则”。（记住数据库不要用，否则效率）&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;例子&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;饱汉式&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 线程安全的懒汉式=饱汉式（lazy loading）：&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Singleton&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; Singleton instance;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Singleton&lt;/span&gt; &lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;synchronized&lt;/span&gt; Singleton &lt;span class=&quot;title&quot;&gt;getInstance&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (instance == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        instance = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Singleton();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; instance;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;特点：加锁会影响效率，一般不用这种方法。不加线程同步可能get的时候会生成多个。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;饿汉式&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 饿汉式（not lazy loading占内存）：&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Singleton&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; Singleton instance = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Singleton();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Singleton&lt;/span&gt; &lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; Singleton &lt;span class=&quot;title&quot;&gt;getInstance&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; instance;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;特点：常用，线程安全；容易产生垃圾对象，可能存在多个类加载器的情况，如一些servlet容器对每个servlet使用完全不同的类装载器。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;静态内部类&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 静态内部类&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Singleton&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;     &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;SingletonHolder&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; Singleton INSTANCE = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Singleton();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;     &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;     &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Singleton&lt;/span&gt; &lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;     &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; Singleton &lt;span class=&quot;title&quot;&gt;getInstance&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;         &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; SingletonHolder.INSTANCE;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;     &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; &amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;区别：这种达到lazy loading的效果，Singleton类被装载了，instance不一定被初始化。因为SingletonHolder类没有被主动使用，只有显示通过调用getInstance方法时，才会显示装载SingletonHolder类，从而实例化instance。&lt;/p&gt;
&lt;p&gt;想象一下，如果实例化instance很消耗资源，我想让他延迟加载，另外一方面，我不希望在Singleton类加载时就实例化，因为我不能确保Singleton类还可能在其他的地方被主动使用从而被加载，那么这个时候实例化instance显然是不合适的。这个时候，这种方式相比就显得很合理。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;双重锁形式&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 可能是单例模式最优方案（双重锁形式）：&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;SingletonTest&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;SingletonTest&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123; &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//定义一个静态私有变量(不初始化，不使用final关键字，使用volatile保证了多线程访问时instance变量的可见性，避免了instance初始化时其他变量属性还没赋值完时，被另外线程调用)&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;volatile&lt;/span&gt; SingletonTest instance;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//定义一个共有的静态方法，返回该类型实例&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; SingletonTest &lt;span class=&quot;title&quot;&gt;getIstance&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 对象实例化时与否判断（不使用同步代码块，instance不等于null时，直接返回对象，提高运行效率）&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (instance == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;//同步代码块（对象未初始化时，使用同步代码块，保证多线程访问时对象在第一次创建后，不再重复被创建）&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;synchronized&lt;/span&gt; (SingletonTest.class) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                &lt;span class=&quot;comment&quot;&gt;//未初始化，则初始instance变量&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (instance == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                    instance = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; SingletonTest();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; instance;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;注意，反射可以调用private构造方法，然而我们不管它。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;双重锁为什么使用volatile，而C++不用&lt;br&gt;答案：禁止指令重排序。&lt;br&gt;参考：&lt;br&gt;&lt;a href=&quot;http://www.cnblogs.com/dolphin0520/p/3920373.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.cnblogs.com/dolphin0520/p/3920373.html&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://blog.csdn.net/dl88250/article/details/5439024&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.csdn.net/dl88250/article/details/5439024&lt;/a&gt;&lt;br&gt;volatile可以保证Java虚拟机对代码执行的指令重排序，也会保证它的正确性。 synchronized虽然保证了原子性，但却没有保证指令重排序的正确性。因此，线程A对单例中的对象进行初始化过程中，可能出现构造函数里面的操作太多了（在 Java 中双重检查模式无效的原因是在不同步的情况下&lt;strong&gt;引用类型&lt;/strong&gt;不是线程安全的），经过重排序之后，A线程单例实例还没有造出来，但已经被赋值了。而B线程这时过来了，错以为单例被实例化出来，一用才发现其中的功能并不完善（出现不可预知的结果），尚未被初始化。&lt;br&gt;我们的线程虽然可以保证原子性，但程序可能是在多核CPU上执行，JVM进行指令重排序的可能性就更大。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;适配器模式&quot;&gt;&lt;a href=&quot;#适配器模式&quot; class=&quot;headerlink&quot; title=&quot;适配器模式&quot;&gt;&lt;/a&gt;适配器模式&lt;/h3&gt;&lt;p&gt;适配器模式有类的适配器模式和对象的适配器模式两种不同的形式。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;类适配器模式：&lt;/p&gt;
&lt;center&gt;&lt;br&gt;&lt;img src=&quot;http://img.blog.csdn.net/20170311233405963?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ3VndWd1amlhd2Vp/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;&gt;&lt;br&gt;&lt;/center&gt;

&lt;ul&gt;
&lt;li&gt;目标(Target)角色：这就是所期待得到的接口。注意：由于这里讨论的是类适配器模式，因此目标不可以是类。&lt;/li&gt;
&lt;li&gt;源(Adapee)角色：现在需要适配的接口。&lt;/li&gt;
&lt;li&gt;适配器(Adaper)角色：适配器类是本模式的核心。适配器把源接口转换成目标接口。显然，这一角色不可以是接口，而必须是具体类。&lt;br&gt;本质上：继承Adaptee父类同时实现Target接口；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;对象适配器模式：&lt;br&gt;实现接口，构造函数中传入源，装饰为Adapter类，实现更多方法以适配，与装饰者模式类似；&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;h2 id=&quot;本系列文章将分为三部分：&quot;&gt;&lt;a href=&quot;#本系列文章将分为三部分：&quot; class=&quot;headerlink&quot; title=&quot;本系列文章将分为三部分：&quot;&gt;&lt;/a&gt;本系列文章将分为三部分：&lt;/h2&gt;&lt;h3 id=&quot;Java基础篇&quot;&gt;&lt;a href=&quot;#Java基础篇&quot; class=&quot;headerlink&quot; title=&quot;Java基础篇&quot;&gt;&lt;/a&gt;Java基础篇&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;语法篇&lt;/li&gt;
&lt;li&gt;数据结构篇&lt;/li&gt;
&lt;li&gt;集合框架&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Java" scheme="http://enjoyhot.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="http://enjoyhot.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java基础篇</title>
    <link href="http://enjoyhot.github.io/2017/04/30/Java%E5%9F%BA%E7%A1%80%E7%AF%87/"/>
    <id>http://enjoyhot.github.io/2017/04/30/Java基础篇/</id>
    <published>2017-04-30T09:20:09.000Z</published>
    <updated>2017-04-30T09:29:40.144Z</updated>
    
    <content type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;h2 id=&quot;本系列文章将分为三部分：&quot;&gt;&lt;a href=&quot;#本系列文章将分为三部分：&quot; class=&quot;headerlink&quot; title=&quot;本系列文章将分为三部分：&quot;&gt;&lt;/a&gt;本系列文章将分为三部分：&lt;/h2&gt;&lt;h3 id=&quot;Java基础篇&quot;&gt;&lt;a href=&quot;#Java基础篇&quot; class=&quot;headerlink&quot; title=&quot;Java基础篇&quot;&gt;&lt;/a&gt;Java基础篇&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;语法篇&lt;/li&gt;
&lt;li&gt;数据结构篇&lt;/li&gt;
&lt;li&gt;集合框架&lt;/li&gt;
&lt;/ul&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;Java高级篇&quot;&gt;&lt;a href=&quot;#Java高级篇&quot; class=&quot;headerlink&quot; title=&quot;Java高级篇&quot;&gt;&lt;/a&gt;Java高级篇&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;JVM知识&lt;/li&gt;
&lt;li&gt;多线程&lt;/li&gt;
&lt;li&gt;Java IO&lt;/li&gt;
&lt;li&gt;Java安全&lt;/li&gt;
&lt;li&gt;设计模式&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;Java实践篇&quot;&gt;&lt;a href=&quot;#Java实践篇&quot; class=&quot;headerlink&quot; title=&quot;Java实践篇&quot;&gt;&lt;/a&gt;Java实践篇&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;并发编程相关&lt;/li&gt;
&lt;li&gt;分布式相关&lt;/li&gt;
&lt;li&gt;框架介绍&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;有些【疑问】可能会留在笔记中，在学习中补充…&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&quot;相关链接&quot;&gt;&lt;a href=&quot;#相关链接&quot; class=&quot;headerlink&quot; title=&quot;相关链接&quot;&gt;&lt;/a&gt;相关链接&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/index.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;javase 1.8 online doc&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/index.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;javase 1.7 online doc&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://docs.oracle.com/javase/specs/jvms/se8/html/index.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;javase 1.8 JVM Specification online doc&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://docs.oracle.com/javase/specs/jvms/se7/html/index.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;javase 1.7 JVM Specification online doc&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;语法章&quot;&gt;&lt;a href=&quot;#语法章&quot; class=&quot;headerlink&quot; title=&quot;语法章&quot;&gt;&lt;/a&gt;语法章&lt;/h1&gt;&lt;h2 id=&quot;手动编译Java工程&quot;&gt;&lt;a href=&quot;#手动编译Java工程&quot; class=&quot;headerlink&quot; title=&quot;手动编译Java工程&quot;&gt;&lt;/a&gt;手动编译Java工程&lt;/h2&gt;&lt;p&gt;目前的代码打包工具很多，前有ant，后有Maven, Gradle, SBT, Ivy, Grape…，手动编译运行，是怎样的。这里简单举个例子，假如文件组织如下:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;src/&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;classes/&lt;ul&gt;
&lt;li&gt;a.java&lt;/li&gt;
&lt;li&gt;b.java&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;test/&lt;ul&gt;
&lt;li&gt;main.java(import classes)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;编译java文件&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;javac a.java b.java main.java&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;无顺序之分&lt;/li&gt;
&lt;li&gt;生成的class文件默认在原目录&lt;/li&gt;
&lt;li&gt;-s 能指定编译结果要置于哪个目录（directory）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;运行&lt;br&gt;进入src目录&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;// -cp: 等价于-classpath，多个则用分号；分开，也可带上jar包&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;java -cp . test.main&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;于是，当需要对工程进行编译，则需要先编译好，在打包时，为了能带上环境变量，往往把包路径移至import的那一层，然后打成war包或jar包等。&lt;/p&gt;
&lt;h2 id=&quot;数组常用操作&quot;&gt;&lt;a href=&quot;#数组常用操作&quot; class=&quot;headerlink&quot; title=&quot;数组常用操作&quot;&gt;&lt;/a&gt;数组常用操作&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;填充&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; test[] = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;[&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; testDeep[][] = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;[&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;][&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 仅限一维&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Arrays.fill(test, &lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;打印&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// [8, 8, 8, 8]&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;System.out.println(Arrays.toString(test));&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// [[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]]&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;System.out.println(Arrays.deepToString(testDeep));&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;拷贝&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; test_copy[] = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;[test.length];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;System.arraycopy(test, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, test_copy, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, test.length);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;test[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;] = &lt;span class=&quot;number&quot;&gt;9&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// [8, 8, 8, 8]&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;System.out.println(Arrays.toString(test_copy));&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;[] test_copy_v2 = Arrays.copyOf(test, test.length);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;test[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;] = &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// [9, 8, 8, 8]&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;System.out.println(Arrays.toString(test_copy_v2));&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;效率:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;System.arraycopy &amp;gt; Arrays.copyOf(本质上新建了数组，并调用了前者) &amp;gt; for循环赋值&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;构造函数&quot;&gt;&lt;a href=&quot;#构造函数&quot; class=&quot;headerlink&quot; title=&quot;构造函数&quot;&gt;&lt;/a&gt;构造函数&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;类中的普通方法可以和类名同名，和构造方法唯一的区分是，构造方法没有返回值；&lt;/li&gt;
&lt;li&gt;抽象类可以有构造方法，接口中不能有构造方法。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;类的继承&quot;&gt;&lt;a href=&quot;#类的继承&quot; class=&quot;headerlink&quot; title=&quot;类的继承&quot;&gt;&lt;/a&gt;类的继承&lt;/h2&gt;&lt;h3 id=&quot;方法的重写-override-，两同两小一大原则：&quot;&gt;&lt;a href=&quot;#方法的重写-override-，两同两小一大原则：&quot; class=&quot;headerlink&quot; title=&quot;方法的重写(override)，两同两小一大原则：&quot;&gt;&lt;/a&gt;方法的重写(override)，两同两小一大原则：&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;方法名相同，参数类型相同&lt;/li&gt;
&lt;li&gt;子类返回类型小于等于父类方法返回类型，&lt;/li&gt;
&lt;li&gt;子类抛出异常小于等于父类方法抛出异常，&lt;/li&gt;
&lt;li&gt;子类访问权限大于等于父类方法访问权限。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;程序中代码的加载顺序&quot;&gt;&lt;a href=&quot;#程序中代码的加载顺序&quot; class=&quot;headerlink&quot; title=&quot;程序中代码的加载顺序&quot;&gt;&lt;/a&gt;程序中代码的加载顺序&lt;/h3&gt;&lt;p&gt;假设在主函数中new一个子类构造函数，执行顺序为：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;父类Ｂ静态代码块-&amp;gt;子类Ａ静态代码块-&amp;gt;父类Ｂ非静态代码块-&amp;gt;父类Ｂ构造函数-&amp;gt;子类Ａ非静态代码块-&amp;gt;子类Ａ构造函数。&lt;/li&gt;
&lt;li&gt;静态代码块和静态变量的加载看书写顺序；&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;原因：&lt;/strong&gt;涉及类加载过程中初始化顺序，详看【高级篇】&lt;/p&gt;
&lt;h3 id=&quot;静态类&quot;&gt;&lt;a href=&quot;#静态类&quot; class=&quot;headerlink&quot; title=&quot;静态类&quot;&gt;&lt;/a&gt;静态类&lt;/h3&gt;&lt;p&gt;静态类只能是内部类，可以被继承&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;InterfaceTest&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Sun&lt;/span&gt;&lt;/span&gt;&amp;#123;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Ak&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;InterfaceTest&lt;/span&gt;.&lt;span class=&quot;title&quot;&gt;Sun&lt;/span&gt;&lt;/span&gt;&amp;#123;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;继承需要注意的&quot;&gt;&lt;a href=&quot;#继承需要注意的&quot; class=&quot;headerlink&quot; title=&quot;继承需要注意的&quot;&gt;&lt;/a&gt;继承需要注意的&lt;/h3&gt;&lt;p&gt;子类定义了父类没有的方法，而用父类指向子类对象，不能直接调用子类方法，需要强制转换：&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;(SON)base.methodB();&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;例子&quot;&gt;&lt;a href=&quot;#例子&quot; class=&quot;headerlink&quot; title=&quot;例子&quot;&gt;&lt;/a&gt;例子&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;父类构造函数调用自己的方法，若子类继承其方法，则运行时调用的是子类的方法，如下输出为null，纵使Sub是静态内部类：&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Base&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; String baseName = &lt;span class=&quot;string&quot;&gt;&quot;base&quot;&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Base&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        callName();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;callName&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        System.out.println(baseName);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Sub&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Base&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; String baseName = &lt;span class=&quot;string&quot;&gt;&quot;sub&quot;&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;callName&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            System.out.println (baseName) ;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        Base b = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Sub();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;包访问权限&quot;&gt;&lt;a href=&quot;#包访问权限&quot; class=&quot;headerlink&quot; title=&quot;包访问权限&quot;&gt;&lt;/a&gt;包访问权限&lt;/h2&gt;&lt;p&gt;类似C++中的friendly，不过还是有人吐槽，包访问权限就是个鸡肋的存在。主要有几个要点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于其它包类，该成员为private；&lt;/li&gt;
&lt;li&gt;继承者与被继承者都处于同一个包才能访问包访问权限成员；&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;接口与抽象类&quot;&gt;&lt;a href=&quot;#接口与抽象类&quot; class=&quot;headerlink&quot; title=&quot;接口与抽象类&quot;&gt;&lt;/a&gt;接口与抽象类&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;抽象类的修饰符可以为public或abstract&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 以下合法，public和abstract都可以&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;abstract&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;InterfaceTest&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;内部接口修饰符还可以protected,private&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;TT&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;KL&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;teset&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;接口可以继承接口，不可以继承类&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 接口可以继承接口，不可以继承类&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;CallableStatement&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;PreparedStatement&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;接口的成员特点：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Inteface1&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;sayHello&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    String name = &lt;span class=&quot;string&quot;&gt;&quot;enjoyhot&quot;&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Enjoyhot&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Inteface1&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;@Override&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;sayHello&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// TODO Auto-generated method stub&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// enjoyhot&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;System.out.println(Inteface1.name);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;成员变量: 只能是常量。默认自动添加(也只能是)修饰符&lt;br&gt;&lt;strong&gt;public static final&lt;/strong&gt;&lt;br&gt;成员方法: 只能是抽象方法。默认自动添加(也只能是)修饰符&lt;br&gt;&lt;strong&gt;public abstract&lt;/strong&gt;&lt;br&gt;内部类：自动地(也只能是)修饰符&lt;br&gt;&lt;strong&gt;public static&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;内部类&quot;&gt;&lt;a href=&quot;#内部类&quot; class=&quot;headerlink&quot; title=&quot;内部类&quot;&gt;&lt;/a&gt;内部类&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;可声明为public，然后在外部调用：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;父.子 test = 父.new 子();&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;内部类操作可直接引用外部类域(包括private),内部类可以直接访问外部类属性，包括private修饰的属性，可通过类似MyOuterClass.this的操作来获得外部类的引用；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;内部类是一种编译器现象，JVM毫不知情；值得注意的是，当内部类调用外部类的私有域时候，编译器将产生一个static方法，该方法具有包访问权限，因此就提供给黑客一个修改私有域方法的切入点:-D；&lt;/li&gt;
&lt;li&gt;在内部类不需要访问外部类对象时，应使用静态内部类，这样该内部类就不能随意访问外部非static域，达到安全的目的，否则如上点，自动转为static方法；&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;局部类&quot;&gt;&lt;a href=&quot;#局部类&quot; class=&quot;headerlink&quot; title=&quot;局部类&quot;&gt;&lt;/a&gt;局部类&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;例子&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;LocalClass&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;AA&lt;/span&gt;&lt;/span&gt;&amp;#123;&amp;#125;&lt;span class=&quot;comment&quot;&gt;//块内局部类&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;LocalClass&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;AA&lt;/span&gt;&lt;/span&gt;&amp;#123;&amp;#125;&lt;span class=&quot;comment&quot;&gt;//构造器内局部类&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;localClass&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;AA&lt;/span&gt;&lt;/span&gt;&amp;#123;&amp;#125;&lt;span class=&quot;comment&quot;&gt;//方法内局部类&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//编译后，形成诸如：外部类名称+$+同名顺序+局部类名称&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//LocalClass$1AA.class  LocalClass$2AA.class  LocalClass$3AA.class  LocalClass.class&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;特点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;局部类的修饰符一定是包权限；&lt;/li&gt;
&lt;li&gt;此时不能访问外部类域，访问外部调用的参数需要声明为final，编译后该final局部变量为该内部类的final实值域；&lt;ul&gt;
&lt;li&gt;原因：假如只是外部传递过来的普通变量，调用外部方法后，这个变量将因返回而释放内存消失，这时就会出现内部类引用非法。而用final修饰后，编译器会在内部类中生成一个外部变量的拷贝。&lt;/li&gt;
&lt;li&gt;总结而言，封闭的作用域引用了外部变量必须定义为final，在做spark的MapReduce操作时经常会遇到。网上一个应用例子如图所示：&lt;center&gt;&lt;br&gt;&lt;img src=&quot;http://hi.csdn.net/attachment/201103/15/0_1300176759Dsv5.gif&quot; alt=&quot;此处输入图片的描述&quot;&gt;&lt;br&gt;&lt;/center&gt;

&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;自动拆箱装箱&quot;&gt;&lt;a href=&quot;#自动拆箱装箱&quot; class=&quot;headerlink&quot; title=&quot;自动拆箱装箱&quot;&gt;&lt;/a&gt;自动拆箱装箱&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;自动装箱和拆箱从Java1.5开始引入，将int的变量转换成Integer对象，这个过程叫做装箱，反之将Integer对象转换成int类型值，这个过程叫做拆箱。装箱和拆箱是自动进行的非人为转换，所以就称作为自动装箱和拆箱。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;byte&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;short&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;char&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;int&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;long&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;float&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;double&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;boolean&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;Byte&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;Short&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;Character&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;Integer&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;Long&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;Float&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;Double&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;Boolean&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;举例说明&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;Integer i01=&lt;span class=&quot;number&quot;&gt;59&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Integer i011=59; //与io01比较也会自动拆装箱，范围-128~127&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i02=&lt;span class=&quot;number&quot;&gt;59&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Integer i03=Integer.valueOf(&lt;span class=&quot;number&quot;&gt;59&lt;/span&gt;);&lt;span class=&quot;comment&quot;&gt;// 地址比较，1字节内才使用常量池，所以范围(-128~127)&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Integer i04=&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Integer(&lt;span class=&quot;number&quot;&gt;59&lt;/span&gt;); &lt;span class=&quot;comment&quot;&gt;// 自动拆装箱，对i03不拆装箱&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;i01和i02相比将自动拆装箱，数值相比; // 那究竟是拆还是装【疑问】&lt;/li&gt;
&lt;li&gt;i01和i03比的是地址（在编译前定义的数值一般会从常量获取，除了valueOf操作需要值的范围-128~127（1字节）才是从常量中获取，为什么【疑问】），i01和i03都是编译之前定义的，所以是常量池中的同一个对象;&lt;/li&gt;
&lt;li&gt;i03和i04比较的是地址，因为i04是编译之后又new出来的对象，所以它的地址必然不在常量池中，所以i03==i04的结果为false。&lt;/li&gt;
&lt;li&gt;类型Integer和int采用进行自动拆装箱比较，而equals是比值操作，无所谓引用不引用。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;总而言之：&lt;br&gt;a. 只要比较双方类型或者值有一方是基本类型，就会进行自动拆装箱比较。&lt;br&gt;b. 当类型都是Integer时，不管值是什么类型，怎样生成的，都需要注意范围-128~127；&lt;/p&gt;
&lt;h2 id=&quot;Iterator-vs-Iterable&quot;&gt;&lt;a href=&quot;#Iterator-vs-Iterable&quot; class=&quot;headerlink&quot; title=&quot;Iterator vs Iterable&quot;&gt;&lt;/a&gt;Iterator vs Iterable&lt;/h2&gt;&lt;p&gt;Iterable：&lt;a href=&quot;https://github.com/enjoyhot/jdk-online/blob/master/1.8/java/lang/Iterable.java&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;jdk1.8源码&lt;/a&gt;&lt;br&gt;Iterator：&lt;a href=&quot;https://github.com/enjoyhot/jdk-online/blob/master/1.8/java/util/Iterator.java&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;jdk1.8源码&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;二者都是接口，foreach操作可用于任何实现Iterable接口的类对象，集合Collection、List、Set都是Iterable的实现类，所以他们及其他们的子类都可以使用for循环增强进行迭代；&lt;/li&gt;
&lt;li&gt;通过源码可看到，Iterable调用Iterator()方法将返回一个Iterator对象。而实现了Iterator接口的对象在不同方法间进行传递的时候，由于当前迭代位置不可知，所以next()的结果也不可知。除非再为Iterator接口添加一个reset()方法，用来重置当前迭代位置。&lt;/li&gt;
&lt;li&gt;实现Iterable接口的对象则不然：&lt;br&gt;func(A){&lt;br&gt;A.Iterator()&lt;br&gt;}&lt;br&gt;每次调用都返回一个从头开始的迭代器，各个迭代器之间互不影响。&lt;/li&gt;
&lt;li&gt;在jdk1.8中可看到，Iterable多了两个default具体方法&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; *&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; * 为了Lambda操作&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; * items.forEach(k -&amp;gt; System.out.println(&quot;Item:&quot;+k));&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; *&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; */&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;default&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;forEach&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Consumer&amp;lt;? &lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt; T&amp;gt; action)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    Objects.requireNonNull(action);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (T t : &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        action.accept(t);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Spliterator(splitable iterator可分割迭代器)接口是Java为了并行遍历数据源中的元素而设计的迭代器&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;default&lt;/span&gt; Spliterator&amp;lt;T&amp;gt; &lt;span class=&quot;title&quot;&gt;spliterator&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; Spliterators.spliteratorUnknownSize(iterator(), &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;Object&quot;&gt;&lt;a href=&quot;#Object&quot; class=&quot;headerlink&quot; title=&quot;Object&quot;&gt;&lt;/a&gt;Object&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;JDK7中所有方法&lt;br&gt;clone,equals,finalize,getClass,notify,notifyAll,hashCode,toString,wait&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;finalize()：&lt;br&gt;一旦垃圾回收器准备好释放对象占用的存储空间，GC会判断该对象是否覆盖了finalize方法，若未覆盖，直接回收；若覆盖，将对象放入F-Queue队列，由一低优先级线程执行该队列中对象的finalize方法。并且在&lt;strong&gt;下一次&lt;/strong&gt;垃圾回收动作发生时，如果对象还没复活，才会真正回收对象占用的内存。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;基本类型不是扩展于Object类，而数组类型[]是;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;Objects.equals(a,b)可以防止一方为null的情况，使用a.equals(b)前提是&lt;strong&gt;a!=null&lt;/strong&gt;;&lt;/li&gt;
&lt;li&gt;一般而言，继承Object重写equals需重写hashCode()方法，这是一种常规协定，可参考hashMap原理理解为什么；（参考Java核心技术卷I第9版, 5.2.3）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;IntHolder&quot;&gt;&lt;a href=&quot;#IntHolder&quot; class=&quot;headerlink&quot; title=&quot;IntHolder&quot;&gt;&lt;/a&gt;IntHolder&lt;/h2&gt;&lt;p&gt;Integer与int一样，在方法参数中属于按值传递，而Integer对象不可变，因此包装器内容不会变。假如想编写一个修改数据值参数的方法就需要使用持有者类型。&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Test&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        IntHolder a = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; IntHolder(&lt;span class=&quot;number&quot;&gt;1000&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        change(a);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        System.out.println(a.value);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;change&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(IntHolder a)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        a.value = a.value * &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&quot;String&quot;&gt;&lt;a href=&quot;#String&quot; class=&quot;headerlink&quot; title=&quot;String&quot;&gt;&lt;/a&gt;String&lt;/h2&gt;&lt;h3 id=&quot;引用&quot;&gt;&lt;a href=&quot;#引用&quot; class=&quot;headerlink&quot; title=&quot;引用&quot;&gt;&lt;/a&gt;引用&lt;/h3&gt;&lt;p&gt;对Java中的一个变量引用一个字符串时，可能创建对象：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果”ABC”这个字符串在java String池里不存在，会在java String池创建这个一个String对象；&lt;/li&gt;
&lt;li&gt;如果存在，变量直接引用这个String池里的对象，因为String是final的，可以共用。&lt;/li&gt;
&lt;li&gt;举个说明&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;String a = &lt;span class=&quot;string&quot;&gt;&quot;ABC&quot;&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;String b = &lt;span class=&quot;string&quot;&gt;&quot;AB&quot;&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;String c = b+&lt;span class=&quot;string&quot;&gt;&quot;C&quot;&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;String d = &lt;span class=&quot;string&quot;&gt;&quot;A&quot;&lt;/span&gt; + &lt;span class=&quot;string&quot;&gt;&quot;BC&quot;&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;String e = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; String(&lt;span class=&quot;string&quot;&gt;&quot;ABC&quot;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;System.out.println(a==c); &lt;span class=&quot;comment&quot;&gt;// false&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;System.out.println(a==d); &lt;span class=&quot;comment&quot;&gt;// true&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;System.out.println(e==d); &lt;span class=&quot;comment&quot;&gt;// false&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;a和b都是字符串常量，所以在编译期就被确定了，c中有个b是引用不是字符串常量所以不会在编译期确定，因此前者false后者true;&lt;/li&gt;
&lt;li&gt;e会在java heap先创建一个String对象，如果”ABC”这个字符串在java String池里不存在，则在String池中再新建一个【疑问】&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;String-intern&quot;&gt;&lt;a href=&quot;#String-intern&quot; class=&quot;headerlink&quot; title=&quot;String.intern()&quot;&gt;&lt;/a&gt;String.intern()&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;String.intern()方法是native方法，用来检测在String pool是否已经有这个String存在,java1.7介绍道：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;　　When the intern method is invoked, if the pool already contains a string equal to this String object as determined by the equals(Object) method, then the string from the pool is returned. Otherwise, this String object is added to the pool and a reference to this String object is returned.&lt;br&gt;　　It follows that for any two strings s and t, s.intern() == t.intern() is true if and only if s.equals(t) is true.&lt;br&gt;　　All literal strings and string-valued constant expressions are interned. String literals are defined in section 3.10.5 of the The Java™ Language Specification.&lt;br&gt;&lt;strong&gt;Returns:&lt;/strong&gt;&lt;br&gt;　　a string that has the same contents as this string, but is guaranteed to be from a pool of unique strings.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;参考美团技术团队一篇文章&lt;br&gt;&lt;a href=&quot;http://tech.meituan.com/in_depth_understanding_string_intern.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://tech.meituan.com/in_depth_understanding_string_intern.html&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;JAVA 使用 jni 调用c++实现的StringTable的intern方法,StringTable的intern方法跟Java中的HashMap的实现是差不多的, 只是不能自动扩容。默认大小是1009，如果放进String Pool的String非常多，就会造成Hash冲突严重，从而导致链表会很长，而链表长了后直接会造成的影响就是当调用String.intern时性能会大幅下降，&lt;strong&gt;可参考本文HashMap介绍&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;intern()的实现&lt;br&gt;&lt;strong&gt;&lt;em&gt;JDK1.6和JDK1.7实现不同，为了避免干扰，我们主要关心1.7以后的&lt;/em&gt;&lt;/strong&gt;。jdk7的版本中，字符串常量池从Perm区移到正常的Java Heap区域了，jdk8直接取消了Perm区，详情参考&lt;strong&gt;Java高级篇&lt;/strong&gt;；下面通过例子说明一下。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;String s = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; String(&lt;span class=&quot;string&quot;&gt;&quot;1&quot;&lt;/span&gt;); &lt;span class=&quot;comment&quot;&gt;//生成了2个对象，常量池中的“1” 和JAVA Heap中的字符串对象&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;s.intern(); &lt;span class=&quot;comment&quot;&gt;//s对象去常量池中寻找后发现 “1” 已经在常量池里了&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;String s2 = &lt;span class=&quot;string&quot;&gt;&quot;1&quot;&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;//生成一个s2的引用指向常量池中的“1”对象&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;System.out.println(s == s2); &lt;span class=&quot;comment&quot;&gt;// false,Object和引用相比，不相等&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;s = s.intern();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;System.out.println(s == s2); &lt;span class=&quot;comment&quot;&gt;// true&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//生成字符串常量池中的“1”和JAVA Heap中的s3引用指向的对象StringObj(其实还有两个匿名对象，不过已经失去引用)&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//此时s3引用对象内容是&quot;11&quot;，但此时常量池中是没有 “11”对象的。&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;String s3 = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; String(&lt;span class=&quot;string&quot;&gt;&quot;1&quot;&lt;/span&gt;) + &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; String(&lt;span class=&quot;string&quot;&gt;&quot;1&quot;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;s3.intern(); &lt;span class=&quot;comment&quot;&gt;//将s3中的“11”字符串放入String常量池中,现在s3间接指向了“11”&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 下图应该有误，经过intern之后，jdk7能使s3直接指向常量池，不经过StringObj&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;String s4 = &lt;span class=&quot;string&quot;&gt;&quot;11&quot;&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;//创建的时候发现已经有这个对象了&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;System.out.println(s3 == s4); &lt;span class=&quot;comment&quot;&gt;//false&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;s3 = s3.intern();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;System.out.println(s3 == s4); &lt;span class=&quot;comment&quot;&gt;//true&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;center&gt;&lt;br&gt;&lt;img src=&quot;http://img.blog.csdn.net/20160823155446893&quot; alt=&quot;此处输入图片的描述&quot;&gt;&lt;br&gt;&lt;/center&gt;

&lt;h3 id=&quot;String、StringBuffer、StringBuilder&quot;&gt;&lt;a href=&quot;#String、StringBuffer、StringBuilder&quot; class=&quot;headerlink&quot; title=&quot;String、StringBuffer、StringBuilder&quot;&gt;&lt;/a&gt;String、StringBuffer、StringBuilder&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;可变与不可变&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;String内部采用final,所以是不可变的；&lt;/li&gt;
&lt;li&gt;StringBuilder与StringBuffer可变；&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;是否多线程安全&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;String内部是常量，所以是线程安全的；&lt;/li&gt;
&lt;li&gt;StringBuilder并没有加同步的操作，不是线程安全的；&lt;/li&gt;
&lt;li&gt;StringBuffer操作加了内置同步锁，因而是线程安全的；&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;final的常见使用场景&quot;&gt;&lt;a href=&quot;#final的常见使用场景&quot; class=&quot;headerlink&quot; title=&quot;final的常见使用场景&quot;&gt;&lt;/a&gt;final的常见使用场景&lt;/h2&gt;&lt;h3 id=&quot;final-class&quot;&gt;&lt;a href=&quot;#final-class&quot; class=&quot;headerlink&quot; title=&quot;final class&quot;&gt;&lt;/a&gt;final class&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;阻止被继承，其中方法将自动转为final，域不会自动转；&lt;/li&gt;
&lt;li&gt;不能修饰接口，抽象类，原因显而易见，二者都是需要“继承”来发挥作用；&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;final-method&quot;&gt;&lt;a href=&quot;#final-method&quot; class=&quot;headerlink&quot; title=&quot;final method&quot;&gt;&lt;/a&gt;final method&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;阻止继承之后的重写，不允许子类插手一些重要的处理，因此该方法就“失去虚拟特征”，意义：&lt;blockquote&gt;
&lt;p&gt;没有动态绑定 ——&amp;gt; 编译器优化为内联函数 ——&amp;gt; 例如(e.getName转为e.name)&lt;br&gt;拓展：虚拟机中的即时编译器处理能力不断增强，如果方法很简短，被频繁调用且没有真正地被覆盖(如经常调用父类的方法)，则即时编译器就会将这个方法进行内联处理。而如果子类这里被JVM加载进来，覆盖了内联方法，优化器将取消内联，这个过程很慢，但很少发生，所以即时编译器还是很高效的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;final-variable&quot;&gt;&lt;a href=&quot;#final-variable&quot; class=&quot;headerlink&quot; title=&quot;final variable&quot;&gt;&lt;/a&gt;final variable&lt;/h3&gt;&lt;p&gt;final变量的值只能在构造函数中赋值或初始化时定好。&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; String test1 = &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// error&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;test1 = &lt;span class=&quot;string&quot;&gt;&quot;&quot;&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; String test2;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// accepted&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;test2 = &lt;span class=&quot;string&quot;&gt;&quot;&quot;&lt;/span&gt;;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&quot;Java中的编码&quot;&gt;&lt;a href=&quot;#Java中的编码&quot; class=&quot;headerlink&quot; title=&quot;Java中的编码&quot;&gt;&lt;/a&gt;Java中的编码&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Java一律采用Unicode编码方式，每个字符无论中文还是英文字符都占用2个字节；&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; han = &lt;span class=&quot;string&quot;&gt;&#39;永&#39;&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;System.out.format(&lt;span class=&quot;string&quot;&gt;&quot;%x&quot;&lt;/span&gt;,(&lt;span class=&quot;keyword&quot;&gt;short&lt;/span&gt;)han);&lt;span class=&quot;comment&quot;&gt;//对第二个参数（短整型）格式化为十六进制输出，0x开头&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//输出6c38&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; han1 = &lt;span class=&quot;number&quot;&gt;0x6c38&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;System.out.println(han1);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//输出永&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;GBK–&amp;gt;UTF-8&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;dst = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; string (src,&lt;span class=&quot;string&quot;&gt;&quot;GBK&quot;&lt;/span&gt;).getbytes(&lt;span class=&quot;string&quot;&gt;&quot;UTF-8&quot;&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// or&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;dst = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; String(src.getBytes(&lt;span class=&quot;string&quot;&gt;&quot;GBK&quot;&lt;/span&gt;),&lt;span class=&quot;string&quot;&gt;&quot;UTF-8&quot;&lt;/span&gt;)&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;面向对象的五大基本原则&quot;&gt;&lt;a href=&quot;#面向对象的五大基本原则&quot; class=&quot;headerlink&quot; title=&quot;面向对象的五大基本原则&quot;&gt;&lt;/a&gt;面向对象的五大基本原则&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;单一职责原则（SRP）&lt;/li&gt;
&lt;li&gt;开放封闭原则（OCP）&lt;/li&gt;
&lt;li&gt;里氏替换原则（LSP）&lt;/li&gt;
&lt;li&gt;依赖倒置原则（DIP）&lt;/li&gt;
&lt;li&gt;接口隔离原则（ISP）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;基本数据类型的转换问题&quot;&gt;&lt;a href=&quot;#基本数据类型的转换问题&quot; class=&quot;headerlink&quot; title=&quot;基本数据类型的转换问题&quot;&gt;&lt;/a&gt;基本数据类型的转换问题&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;例1&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;short&lt;/span&gt; a = &lt;span class=&quot;number&quot;&gt;128&lt;/span&gt;；&lt;span class=&quot;comment&quot;&gt;// 00000000 10000000&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;byte&lt;/span&gt; b = (&lt;span class=&quot;keyword&quot;&gt;byte&lt;/span&gt;) a; &lt;span class=&quot;comment&quot;&gt;// b = -128(后8位)&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;例2&lt;br&gt;10原码： 0000000000000000,0000000000001010；&lt;br&gt;-10补码：1111111111111111,1111111111110110（取反再+1）&lt;br&gt;因此 ~10 =&lt;br&gt;1111111111111111,1111111111110101，减1再取反后31位得-11&lt;br&gt;所以 ~10 = -11&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;例3&lt;br&gt;==号，低精度自动转为高精度比较，如long与float，会自动转为float，+-*/亦然。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;低———————————————&amp;gt;高&lt;br&gt;byte,short,char-&amp;gt; int -&amp;gt; long -&amp;gt; float -&amp;gt; double&lt;br&gt;高到低需要强制转换，如：&lt;br&gt;int aa = (int)4.0;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;switch&lt;br&gt;参数是只能放int,String类型，但是放byte，short，char类型的也可以，是因为byte，short，shar可以自动提升（自动类型转换）为int,也不能boolean类型,任何类型不能转换为boolean类型型，强转也不行。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;final相关&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 被fianl修饰的变量不会自动改变类型&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;byte&lt;/span&gt; b1=&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,b2=&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,b3,b6;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;byte&lt;/span&gt; b4=&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;,b5=&lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;b3=(b1+b2);  &lt;span class=&quot;comment&quot;&gt;/*语句1*/&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;// 错，高到低需要强制转换&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;b6=b4+b5;    &lt;span class=&quot;comment&quot;&gt;/*语句2*/&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;// 对，b4+b5受final影响，是byte&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;引用类型&quot;&gt;&lt;a href=&quot;#引用类型&quot; class=&quot;headerlink&quot; title=&quot;引用类型&quot;&gt;&lt;/a&gt;引用类型&lt;/h2&gt;&lt;p&gt;Java中有强引用、软引用、弱引用、虚引用这四个概念，引用类型包含在包java.lang.ref中。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;强引用（StrongReference）&lt;br&gt;强引用不会被GC回收，并且在java.lang.ref里也没有实际的对应类型。举个例子来说：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;Object obj = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Object();&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;软引用（SoftReference）&lt;br&gt;软引用在JVM报告内存不足的时候才会被GC回收，否则不会回收，正是由于这种特性软引用在caching和pooling中用处广泛。软引用的用法&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;Object obj = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Object();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;SoftReference&amp;lt;Object&amp;gt; softRef =&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; SoftReference(obj);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 使用softRef.get() 获取软引用所引用的对象&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Object objg = softRef.get();&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;SoftReference 会尽可能长地保留引用直到 JVM 内存不足时才会被回收(虚拟机保证), 这一特性使得 SoftReference 非常适合缓存应用。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;弱引用（WeakReference）&lt;br&gt;当GC一但发现了弱引用对象，将会释放WeakReference所引用的对象，具体来说，就是当所引用的对象在JVM内不再有强引用时, GC后weak reference将会被自动回收。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;虚引用（PhantomReference）&lt;br&gt;当GC一但发现了虚引用对象，将会将PhantomReference对象插入ReferenceQueue队列，而此时PhantomReference所指向的对象并没有被GC回收，而是要等到ReferenceQueue被你真正的处理后才会被回收。虚引用的用法：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;Object obj = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Object();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;ReferenceQueue&amp;lt;Object&amp;gt; refQueue =&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ReferenceQueue&amp;lt;Object&amp;gt;();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;PhantomReference&amp;lt;Object&amp;gt; phanRef =&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; PhantomReference&amp;lt;Object&amp;gt;(obj, refQueue);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 调用phanRef.get()不管在什么情况下永远返回null&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Object objg = phanRef.get();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 如果obj被置为null，当GC发现了虚引用，GC会将phanRef插入进我们之前创建时传入的refQueue队列&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 注意，此时phanRef所引用的obj对象，并没有被GC回收，在我们显式地调用refQueue.poll返回phanRef之后&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 当GC第二次发现虚引用，而此时JVM将phanRef插入到refQueue会插入失败，此时GC才会对obj进行回收&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Reference&amp;lt;? extends Object&amp;gt; phanRefP = refQueue.poll();&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;反射&quot;&gt;&lt;a href=&quot;#反射&quot; class=&quot;headerlink&quot; title=&quot;反射&quot;&gt;&lt;/a&gt;反射&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;类型类&lt;br&gt;Object类中包含一个方法名叫getClass，利用这个方法就可以获得一个实例的类型类。类型类指的是代表一个类型的类，因为一切皆是对象，类型也不例外，在Java使用类型类来表示一个类型。所有的类型类都是Class类的实例。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;A a = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; A();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// print equal&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(a.getClass()==A.class)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;equal&quot;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;unequal&quot;&lt;/span&gt;);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;获取对象方法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;public Method[] getDeclaredMethods()&lt;br&gt;返回类或接口声明的所有方法，包括public, protected, default (package) 访问和private方法的Method对象，但不包括继承的方法。当然也包括它所实现接口的方法。&lt;/li&gt;
&lt;li&gt;public Method[] getMethods()&lt;br&gt;返回某个类的所有public方法，包括其继承类的公用方法，当然也包括它所实现接口的方法。&lt;/li&gt;
&lt;li&gt;对于private方法的反射调用，会抛出IllegalAccessException，因此访问的话，需绕过安全管理器的控制：&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; java.lang.reflect.Method;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ReflectPrivate&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; Exception &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        PrivateClass p = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; PrivateClass();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        Class&amp;lt;?&amp;gt; classType = p.getClass();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 获取Method对象&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        Method method = classType.getDeclaredMethod(&lt;span class=&quot;string&quot;&gt;&quot;sayHello&quot;&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Class[] &amp;#123; String.class &amp;#125;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        method.setAccessible(&lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        String str = (String) method.invoke(p, &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Object[] &amp;#123; &lt;span class=&quot;string&quot;&gt;&quot;enjoyhot&quot;&lt;/span&gt; &amp;#125;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        System.out.println(str);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;PrivateClass&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; String &lt;span class=&quot;title&quot;&gt;sayHello&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String name)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;Hello: &quot;&lt;/span&gt; + name;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;native方法&quot;&gt;&lt;a href=&quot;#native方法&quot; class=&quot;headerlink&quot; title=&quot;native方法&quot;&gt;&lt;/a&gt;native方法&lt;/h2&gt;&lt;p&gt;native方法是由另外一种语言（如c/c++，FORTRAN，汇编）实现的本地方法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;public final static native int w();  // 合法&lt;/li&gt;
&lt;li&gt;abstract方法不能用native来修饰，因为native暗示这些方法是有实现体的，只不过这些实现体是非java的，但是abstract却显然的指明这些方法无实现体。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;泛型擦除&quot;&gt;&lt;a href=&quot;#泛型擦除&quot; class=&quot;headerlink&quot; title=&quot;泛型擦除&quot;&gt;&lt;/a&gt;泛型擦除&lt;/h2&gt;&lt;p&gt;泛型可以说是Java中最常用的语法糖之一，因此虚拟机不支持这些语法，在编译时转化为Object，继承的时候利用桥方法动态调用，据此应考虑泛型在开发过程中的约束和局限性。一个较典型的局限性和约束是，java不支持泛型数组：&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// compile error&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;List&amp;lt;String&amp;gt;[] ls = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ArrayList&amp;lt;String&amp;gt;[&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// without compile error&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;List&amp;lt;String&amp;gt;[] ls = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ArrayList[&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;List&amp;lt;?&amp;gt;[] ls = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ArrayList[&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;];&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;第一种编译器检测出来直接报错，第二种逃过编译器的检测，设计者必须心理有数。&lt;br&gt;不支持泛型数组的原因是，ls对象将编译为Object[]，再对该变量进行各种赋值操作都将逃过编译器的捕捉，假如编译器不小心指定错了类型，例如：&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;List&amp;lt;Integer&amp;gt; ——&amp;gt; List&amp;lt;String&amp;gt;[]&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;在运行时才会报ClassCastException。&lt;/p&gt;
&lt;h2 id=&quot;异常&quot;&gt;&lt;a href=&quot;#异常&quot; class=&quot;headerlink&quot; title=&quot;异常&quot;&gt;&lt;/a&gt;异常&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;throwable(接口)&lt;ul&gt;
&lt;li&gt;Error (unchecked)&lt;/li&gt;
&lt;li&gt;Exception&lt;ul&gt;
&lt;li&gt;RuntimeException (unchecked)&lt;/li&gt;
&lt;li&gt;IOException (checked)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;一般而言，对于知道怎么处理的异常需要catch(A|B e),不知道的继续向上传递，通过在函数头尾部显式throws A,B；&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;断言&quot;&gt;&lt;a href=&quot;#断言&quot; class=&quot;headerlink&quot; title=&quot;断言&quot;&gt;&lt;/a&gt;断言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;assert一般用于开发/测试中，当代码发布时，这些插入的检测语句将自动地移走，即类加载器将跳过断言代码；&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;补充&quot;&gt;&lt;a href=&quot;#补充&quot; class=&quot;headerlink&quot; title=&quot;补充&quot;&gt;&lt;/a&gt;补充&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;自加运算&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 0 + 2&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; s=(i++)+(++i);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;关于finally&lt;br&gt;一般而言,不管采取什么操作，只要JVM在运行finally都会执行，除非执行某些操作终止JVM进程，譬如：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;System.exit(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;关于finnally的例子：&lt;/strong&gt;&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;23&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;24&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;25&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; k = f_test();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        System.out.println(k);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;f_test&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; a = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        a = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; a;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;finally&lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;It is in final chunk.&quot;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        a = &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; a;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 输出：&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// It is in final chunk.&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 2&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 如果将 return a; 注释掉，将输出&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// It is in final chunk.&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 1&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Java标识符由数字，字母和下划线（_），美元符号（$）组成&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;数据结构章&quot;&gt;&lt;a href=&quot;#数据结构章&quot; class=&quot;headerlink&quot; title=&quot;数据结构章&quot;&gt;&lt;/a&gt;数据结构章&lt;/h1&gt;&lt;h2 id=&quot;ArrayList&quot;&gt;&lt;a href=&quot;#ArrayList&quot; class=&quot;headerlink&quot; title=&quot;ArrayList&quot;&gt;&lt;/a&gt;ArrayList&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;&lt;em&gt;For jdk1.7 &amp;amp; 1.8&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;继承关系&quot;&gt;&lt;a href=&quot;#继承关系&quot; class=&quot;headerlink&quot; title=&quot;继承关系&quot;&gt;&lt;/a&gt;继承关系&lt;/h3&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ArrayList&lt;/span&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;E&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;AbstractList&lt;/span&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;E&lt;/span&gt;&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;List&lt;/span&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;E&lt;/span&gt;&amp;gt;, &lt;span class=&quot;title&quot;&gt;RandomAccess&lt;/span&gt;, &lt;span class=&quot;title&quot;&gt;Cloneable&lt;/span&gt;, &lt;span class=&quot;title&quot;&gt;Serializable&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;几种构造函数&quot;&gt;&lt;a href=&quot;#几种构造函数&quot; class=&quot;headerlink&quot; title=&quot;几种构造函数&quot;&gt;&lt;/a&gt;几种构造函数&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;ArrayList()&lt;/strong&gt;&lt;br&gt;Constructs an empty list with an initial capacity of ten.&lt;br&gt;&lt;strong&gt;ArrayList(Collection&amp;lt;? extends E&amp;gt; c)&lt;/strong&gt;&lt;br&gt;Constructs a list containing the elements of the specified collection, in the order they are returned by the collection’s iterator.&lt;br&gt;&lt;strong&gt;ArrayList(int initialCapacity)&lt;/strong&gt;&lt;br&gt;Constructs an empty list with the specified initial capacity.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;用法要点&quot;&gt;&lt;a href=&quot;#用法要点&quot; class=&quot;headerlink&quot; title=&quot;用法要点&quot;&gt;&lt;/a&gt;用法要点&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;ArrayList的底层是由一个Object[]数组构成的，Object[]数组，默认的长度是10 。当调用size时，计算的是逻辑长度，即“空元素不被计算”。&lt;/li&gt;
&lt;li&gt;java自动增加ArrayList大小的思路是:&lt;ul&gt;
&lt;li&gt;向ArrayList添加对象时，原对象数目加1;&lt;/li&gt;
&lt;li&gt;如果大于原底层数组长度，则以适当长度(50%+1)新建一个原数组的拷贝，并修改原数组，指向这个新建数组;&lt;/li&gt;
&lt;li&gt;原数组自动抛弃（java垃圾回收机制会自动回收）;&lt;/li&gt;
&lt;li&gt;size则在向数组添加对象后，自增1；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ArrayList扩容通过ensureCapacity判断后可扩容50%+1，Vector是默认扩展1倍。&lt;/li&gt;
&lt;li&gt;ArrayList()构造一个空列表，在添加第一个元素时，会自动扩展。而对于new ArrayList(20)则没有进行扩容行为;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&quot;http://www.importnew.com/9928.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;importnew：关于ArrayList的5道面试题&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;同步方法&quot;&gt;&lt;a href=&quot;#同步方法&quot; class=&quot;headerlink&quot; title=&quot;同步方法&quot;&gt;&lt;/a&gt;同步方法&lt;/h3&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 1&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;List list = Collections.synchronizedList(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ArrayList(...));&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 2&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;CopyOnWriteArrayList&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;CopyOnWriteArrayList&quot;&gt;&lt;a href=&quot;#CopyOnWriteArrayList&quot; class=&quot;headerlink&quot; title=&quot;CopyOnWriteArrayList&quot;&gt;&lt;/a&gt;CopyOnWriteArrayList&lt;/h2&gt;&lt;p&gt;顾名思义，写时复制，写数组时，先复制一份出来，然后向新的容器里添加元素，可以做到安全地进行并发读。因为写的时候有加锁（&lt;a href=&quot;https://github.com/enjoyhot/jdk-online/blob/master/1.8/java/util/concurrent/CopyOnWriteArrayList.java#L433&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;源码&lt;/a&gt;）并且不改变旧内存，再将原容器的引用指向新的容器，因此多线程写是同步的。通过读写分离实现安全的优点，适合使用在读操作远远大于写操作的场景（与volatile类似），如缓存。&lt;/p&gt;
&lt;h3 id=&quot;缺点：&quot;&gt;&lt;a href=&quot;#缺点：&quot; class=&quot;headerlink&quot; title=&quot;缺点：&quot;&gt;&lt;/a&gt;缺点：&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;内存占用问题&lt;br&gt;进行写操作时（如add），内存中驻留两个对象内存，可能造成频繁的GC；&lt;/li&gt;
&lt;li&gt;数据一致性问题&lt;br&gt;只能保证数据的最终一致性，不能保证实时一致性。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;HashMap&quot;&gt;&lt;a href=&quot;#HashMap&quot; class=&quot;headerlink&quot; title=&quot;HashMap&quot;&gt;&lt;/a&gt;HashMap&lt;/h2&gt;&lt;h3 id=&quot;结构&quot;&gt;&lt;a href=&quot;#结构&quot; class=&quot;headerlink&quot; title=&quot;结构&quot;&gt;&lt;/a&gt;结构&lt;/h3&gt;&lt;p&gt;　　在jdk1.7中，是数组（单位称为桶）与链表（jdk1.8中改为基于红黑树的实现）的结合体。&lt;br&gt;　　链表的基本元素Entry，内部类有key,value,hash和next四个字段，其中next也是一个Entry类型。&lt;/p&gt;
&lt;h3 id=&quot;操作&quot;&gt;&lt;a href=&quot;#操作&quot; class=&quot;headerlink&quot; title=&quot;操作&quot;&gt;&lt;/a&gt;操作&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;默认的负载因子大小为0.75，当一个map填满了75%的bucket时候，将会创建原来HashMap大小的2倍的bucket数组，来重新调整map的大小，并将原来的对象放入新的bucket数组中。这个过程叫作rehashing，因为它调用hash方法找到新的bucket位置。拓展，为什么HashMap初始化的大小需要2的指数次幂：&lt;a href=&quot;http://stackoverflow.com/questions/8352378/why-does-hashmap-require-that-the-initial-capacity-be-a-power-of-two&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;参考&lt;/a&gt;&lt;blockquote&gt;
&lt;p&gt;再查找哈希表的内在位置时[0,length-1]有个如下的操作，从而确定h所在的位置（笔者认为觉得这是寻找桶时候的类似开放定址法的实现），这样相比不是2^n-1的全111……求余而言，需要自己去实现求余，会比较高效。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;indexFor&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; h, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; length)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; h &amp;amp; (length-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;HashMap基于hashing原理，我们通过put()和get()方法储存和获取对象。&lt;ul&gt;
&lt;li&gt;当我们将键值对传递给put()方法时，它调用键对象的hashCode()方法来计算hashcode，然后找到bucket位置来储存值对象。&lt;/li&gt;
&lt;li&gt;当获取对象时，通过键对象的equals()方法找到正确的键值对，然后返回值对象。HashMap使用链表来解决碰撞问题，当发生碰撞了，对象将会储存在链表的下一个节点中。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;HashMap-vs-HashSet&quot;&gt;&lt;a href=&quot;#HashMap-vs-HashSet&quot; class=&quot;headerlink&quot; title=&quot;HashMap vs HashSet&quot;&gt;&lt;/a&gt;HashMap vs HashSet&lt;/h3&gt;&lt;p&gt;HashSet是基于HashMap实现的，HashSet底层采用 HashMap 来保存所有元素，所有放入HashSet中的集合元素实际上由 HashMap 的 key 来保存，而 HashMap的value则存储了一个公共的PRESENT对象，它是一个静态的Object对象。如添加操作：&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(E e)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; map.put(e, PRESENT) == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;HashMap-vs-HashTable&quot;&gt;&lt;a href=&quot;#HashMap-vs-HashTable&quot; class=&quot;headerlink&quot; title=&quot;HashMap vs HashTable&quot;&gt;&lt;/a&gt;HashMap vs HashTable&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Hashtable是线程安全的，通过synchronized保证线程安全，并且是安全失败的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Java快速失败与安全失败迭代器 :&lt;br&gt;java迭代器提供了遍历集合对象的功能，集合返回的迭代器有快速失败型的也有安全失败型的，快速失败迭代器在迭代时如果集合类被修改，立即抛出ConcurrentModificationException异常，而安全失败迭代器不会抛出异常，因为它是在集合类的克隆对象上操作的。ArrayList，Vector，HashMap等集合返回的迭代器都是快速失败类型的。而对于Hashtable而言：&lt;blockquote&gt;
&lt;p&gt;the iterator in Hashtable is fail-fast but the enumerator is not fail-safe. 参考：&lt;a href=&quot;http://stackoverflow.com/questions/16205443/concurrency-in-hashtables-and-fail-safe-behavior&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;stackoverflow&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;Hashtable、HashMap都使用了 Iterator。而由于历史原因，Hashtable还使用了Enumeration的方式 。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;哈希值的使用不同，HashTable直接使用对象的hashCode。而HashMap重新计算hash值，而且用与代替求模，如上&lt;strong&gt;操作&lt;/strong&gt;中代码所示。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;HashTable中hash数组默认大小是11，增加的方式是 old*2+1。HashMap数组table的长度length大小必须为2的n次方，而size默认大小是16，size和扩容后一定是原来2的指数，默认是2倍。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;HashMap可以接受null键值和值，而Hashtable则不能；&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;HashMap-vs-ConcurrentHashMap&quot;&gt;&lt;a href=&quot;#HashMap-vs-ConcurrentHashMap&quot; class=&quot;headerlink&quot; title=&quot;HashMap vs ConcurrentHashMap&quot;&gt;&lt;/a&gt;HashMap vs ConcurrentHashMap&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;ConcurrentHashMap允许多个修改操作并发进行，是线程安全的；&lt;/li&gt;
&lt;li&gt;HashMap在每个链表节点中储存键值对对象（Entry对象）。链表中next不是final，所以支持往后插入。然而，HashMap在多线程情况下rehash可能出现环形链表。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;参考：&lt;a href=&quot;https://my.oschina.net/xianggao/blog/393990&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;HashMap多线程并发问题分析&lt;/a&gt;&lt;br&gt;参考：&lt;a href=&quot;http://www.importnew.com/7099.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;关于HashMap的经典面试题&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;ConcurrentHashMap&quot;&gt;&lt;a href=&quot;#ConcurrentHashMap&quot; class=&quot;headerlink&quot; title=&quot;ConcurrentHashMap&quot;&gt;&lt;/a&gt;ConcurrentHashMap&lt;/h2&gt;&lt;h3 id=&quot;段数量&quot;&gt;&lt;a href=&quot;#段数量&quot; class=&quot;headerlink&quot; title=&quot;段数量&quot;&gt;&lt;/a&gt;段数量&lt;/h3&gt;&lt;p&gt;默认有16个，最大个数为1 &amp;lt;&amp;lt; 16= 65536&lt;/p&gt;
&lt;h3 id=&quot;实现线程安全&quot;&gt;&lt;a href=&quot;#实现线程安全&quot; class=&quot;headerlink&quot; title=&quot;实现线程安全&quot;&gt;&lt;/a&gt;实现线程安全&lt;/h3&gt;&lt;p&gt;HashTable是一个线程安全的类，它使用synchronized来锁住整张Hash表来实现线程安全，即每次锁住整张表让线程独占，线程竞争激烈的情况下HashTable的效率非常低下。而对于ConcurrentHashMap：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ConcurrentHashMap允许多个修改操作并发进行，其关键在于使用了&lt;strong&gt;锁分离技术&lt;/strong&gt;。它使用了多个锁来控制对hash表的不同部分进行的修改。&lt;/li&gt;
&lt;li&gt;ConcurrentHashMap内部使用段(Segment)来表示这些不同的部分，每个段其实就是一个小的Hashtable，它们有自己的锁。只要多个修改操作发生在不同的段上，它们就可以并发进行。只有对全局需要改变时锁定的是所有的segment，如size()。&lt;/li&gt;
&lt;li&gt;对于一个key，需要经过三次hash操作（哪个段，哪个桶，链表哪一位），才能最终定位这个元素的位置。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;基本实现图如下【jdk1.7】&lt;/strong&gt;&lt;/p&gt;
&lt;center&gt;&lt;br&gt;&lt;img src=&quot;https://www.ibm.com/developerworks/cn/java/java-lo-concurrenthashmap/image005.jpg&quot; alt=&quot;此处输入图片的描述&quot;&gt;&lt;br&gt;&lt;/center&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;在散列时如果产生“碰撞”，将采用“分离链接法”来处理“碰撞”：把“碰撞”的 HashEntry 对象链接成一个链表。由于 HashEntry 的 next 域为 final 型，所以新节点只能在链表的表头处插入。&lt;br&gt;参考：&lt;a href=&quot;http://www.ibm.com/developerworks/cn/java/java-lo-concurrenthashmap/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;ConcurrentHashMap高并发性的实现机制&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;ConcurrentHashMap1.6使用的是Segement（继承自ReentrantLock）分段锁的技术来保证同步的，使用synchronized关键字保证线程安全的是HashTable。1.8之后ConcurrentHashMap改变了实现方式，将原来的Segment用单向链表来替代，put的时候对目标链表的头节点加锁，而这时用的就是synchronized。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;ConcurrentHashMap1.6使用的是Segement（继承自ReentrantLock）分段锁的技术来保证同步的，使用synchronized关键字保证线程安全的是HashTable。1.8之后ConcurrentHashMap改变了实现方式，将原来的Segment(table)用单向链表来替代，put的时候对目标链表的头节点加锁，而这时用的也是synchronized。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;效率：System.arraycopy &amp;gt; System.copyOf(本质上新建了数组，并调用了前者) &amp;gt; for循环&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;集合框架篇&quot;&gt;&lt;a href=&quot;#集合框架篇&quot; class=&quot;headerlink&quot; title=&quot;集合框架篇&quot;&gt;&lt;/a&gt;集合框架篇&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;安全的集合：&lt;/strong&gt; ArrayList，Vector，HashMap等集合返回的迭代器都是快速失败类型的。通过抛出ConCurrenceModificationException的异常保证安全。&lt;/p&gt;
&lt;center&gt;&lt;br&gt;&lt;img src=&quot;http://images2015.cnblogs.com/blog/916361/201603/916361-20160322135512683-168468369.jpg&quot; alt=&quot;此处输入图片的描述&quot;&gt;&lt;br&gt;&lt;/center&gt;

&lt;h2 id=&quot;常用对象分类&quot;&gt;&lt;a href=&quot;#常用对象分类&quot; class=&quot;headerlink&quot; title=&quot;常用对象分类&quot;&gt;&lt;/a&gt;常用对象分类&lt;/h2&gt;&lt;h3 id=&quot;Collection&quot;&gt;&lt;a href=&quot;#Collection&quot; class=&quot;headerlink&quot; title=&quot;Collection&quot;&gt;&lt;/a&gt;Collection&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;List&lt;ul&gt;
&lt;li&gt;LinkedList&lt;br&gt;  内在为链表实现，插入，删除效率高于ArrayList&lt;/li&gt;
&lt;li&gt;ArrayList&lt;br&gt;  底层为数组实现，每次扩容都需要把整个数据复制&lt;/li&gt;
&lt;li&gt;Vector (安全，但已经很少使用了)&lt;ul&gt;
&lt;li&gt;Stack (安全)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Set&lt;ul&gt;
&lt;li&gt;TreeSet&lt;br&gt;  插入时按照红黑树排序，速率相比普通Set会慢一些，时间复杂度为log2N&lt;/li&gt;
&lt;li&gt;HashSet&lt;br&gt;  set的常用对象&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Queue&lt;ul&gt;
&lt;li&gt;PriorityQueue（大数据量求TopK操作）&lt;ul&gt;
&lt;li&gt;迭代器非按照元素的排列顺序排列，但remove时是按照优先级数最小的元素进行取出，即优先级最高的元素。&lt;/li&gt;
&lt;li&gt;优先级队列中的元素可以按照任意的顺序插入，却总是按照升序的顺序进行检索。无论何时调用remove方法，总会获得当前优先级队列中的最小元素，但并不是对所有元素都排序。它是采用了堆（一个可以自我调整的二叉树），执行增加删除操作后，可以让最小元素移动到根。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;使用普通同步容器(Vector, Hashtable)的迭代器,也需要外部锁来保证其原子性。因为普通同步容器产生的迭代器是非线程安全的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;Map&quot;&gt;&lt;a href=&quot;#Map&quot; class=&quot;headerlink&quot; title=&quot;Map&quot;&gt;&lt;/a&gt;Map&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;HashMap&lt;br&gt;  分离链接法，next不是final,因此往后插入。&lt;/li&gt;
&lt;li&gt;TreeMap&lt;br&gt;  实现了SortedMap接口，默认保证按照键的升序排列的映射表&lt;/li&gt;
&lt;li&gt;WeakHashMap&lt;br&gt;  参考&lt;a href=&quot;http://www.cnblogs.com/Skyar/p/5962253.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.cnblogs.com/Skyar/p/5962253.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Hashtable (安全)&lt;br&gt;  HashTable中hash数组默认大小是11，增加的方式是 old*2+1，保证奇数。分离链接法、开放定址法。&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;h2 id=&quot;本系列文章将分为三部分：&quot;&gt;&lt;a href=&quot;#本系列文章将分为三部分：&quot; class=&quot;headerlink&quot; title=&quot;本系列文章将分为三部分：&quot;&gt;&lt;/a&gt;本系列文章将分为三部分：&lt;/h2&gt;&lt;h3 id=&quot;Java基础篇&quot;&gt;&lt;a href=&quot;#Java基础篇&quot; class=&quot;headerlink&quot; title=&quot;Java基础篇&quot;&gt;&lt;/a&gt;Java基础篇&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;语法篇&lt;/li&gt;
&lt;li&gt;数据结构篇&lt;/li&gt;
&lt;li&gt;集合框架&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Java" scheme="http://enjoyhot.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="http://enjoyhot.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Linux 系统管理常用命令（不定时更新）</title>
    <link href="http://enjoyhot.github.io/2017/04/29/linux-management-command/"/>
    <id>http://enjoyhot.github.io/2017/04/29/linux-management-command/</id>
    <published>2017-04-29T09:23:09.000Z</published>
    <updated>2017-04-30T09:29:40.152Z</updated>
    
    <content type="html">&lt;h2 id=&quot;运行脚本的方法&quot;&gt;&lt;a href=&quot;#运行脚本的方法&quot; class=&quot;headerlink&quot; title=&quot;运行脚本的方法&quot;&gt;&lt;/a&gt;运行脚本的方法&lt;/h2&gt;&lt;h3 id=&quot;常用运行方法&quot;&gt;&lt;a href=&quot;#常用运行方法&quot; class=&quot;headerlink&quot; title=&quot;常用运行方法:&quot;&gt;&lt;/a&gt;常用运行方法:&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;$ bash a.sh&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;$ chmod +x a.sh&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;$ ./a.sh&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;$ source a.sh&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;用bash和用source的不同在于：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用bash执行时，shell script其实是在在父程序bash下新建了一个 bash子程序，之后这个子程序中执行，当程序执行完后，shell script里定义的变量都会随子程序的结束而消失；&lt;/li&gt;
&lt;li&gt;用source执行时，是在父程序bash中执行,shell script里定义的变量都还在。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;shell-script的追踪与Debug&quot;&gt;&lt;a href=&quot;#shell-script的追踪与Debug&quot; class=&quot;headerlink&quot; title=&quot;shell script的追踪与Debug&quot;&gt;&lt;/a&gt;shell script的追踪与Debug&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;sh -n xx.sh # 语法检查&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;sh -x xx.sh # 列出xx.sh的执行过程&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;脚本输入输出例子&quot;&gt;&lt;a href=&quot;#脚本输入输出例子&quot; class=&quot;headerlink&quot; title=&quot;脚本输入输出例子&quot;&gt;&lt;/a&gt;脚本输入输出例子&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;# !/bin/bash&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;# Program:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;#   This program is used to ouput parameter of the shell script&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;# History:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;# 2013/2/3 on_1y First release&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;PATH=$PATH&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;export PATH&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;echo &amp;quot;The script&amp;apos;s name is ==&amp;gt; $0&amp;quot;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;echo &amp;quot;Total parameter number is ==&amp;gt; $#&amp;quot;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;# Check whether number of the parameter is less than 2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;[ &amp;quot;$#&amp;quot; -lt 2 ] &amp;amp;&amp;amp; echo &amp;quot;The number of parameter is less than 2.Stop here.&amp;quot; &amp;amp;&amp;amp; exit 0&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;echo &amp;quot;The whole parameter is ==&amp;gt; &amp;apos;$@&amp;apos;&amp;quot;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;echo &amp;quot;The first parameter is ==&amp;gt; $1&amp;quot;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;echo &amp;quot;The first parameter is ==&amp;gt; $2&amp;quot;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;exit 0&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;输入和输出为：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;$ bash sh05.sh 1a 2b 3c 4d&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;The script&amp;apos;s name is ==&amp;gt; sh05.sh&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Total parameter number is ==&amp;gt; 4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;The whole parameter is ==&amp;gt; &amp;apos;1a 2b 3c 4d&amp;apos;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;The first parameter is ==&amp;gt; 1a&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;The first parameter is ==&amp;gt; 2b&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&quot;test命令&quot;&gt;&lt;a href=&quot;#test命令&quot; class=&quot;headerlink&quot; title=&quot;test命令&quot;&gt;&lt;/a&gt;test命令&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;test -e a.txt &amp;amp;&amp;amp; echo &amp;quot;exists&amp;quot; || echo &amp;quot;not exists&amp;quot;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;当a.txt存在时，执行echo “exists”，否则执行echo “not exists”，多个命令用&amp;amp;&amp;amp;连接即可。改变test参数可以进行多种决策判断，可以研究一下。&lt;/p&gt;
&lt;h2 id=&quot;关闭apache&quot;&gt;&lt;a href=&quot;#关闭apache&quot; class=&quot;headerlink&quot; title=&quot;关闭apache&quot;&gt;&lt;/a&gt;关闭apache&lt;/h2&gt;&lt;h3 id=&quot;版本一&quot;&gt;&lt;a href=&quot;#版本一&quot; class=&quot;headerlink&quot; title=&quot;版本一&quot;&gt;&lt;/a&gt;版本一&lt;/h3&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;/etc/init.d/httpd stop&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;!--more--&gt;
&lt;h3 id=&quot;版本二&quot;&gt;&lt;a href=&quot;#版本二&quot; class=&quot;headerlink&quot; title=&quot;版本二&quot;&gt;&lt;/a&gt;版本二&lt;/h3&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;/etc/init.d/apache2 stop&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;查看端口&quot;&gt;&lt;a href=&quot;#查看端口&quot; class=&quot;headerlink&quot; title=&quot;查看端口&quot;&gt;&lt;/a&gt;查看端口&lt;/h2&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;netstat -anp | grep &lt;span class=&quot;number&quot;&gt;9200&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;(Not all processes could be identified, non-owned process info&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; will &lt;span class=&quot;keyword&quot;&gt;not&lt;/span&gt; be shown, you would have to be root to see it all.)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;tcp        &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;      &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;192.168&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;.0&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;.1&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;53570&lt;/span&gt;       &lt;span class=&quot;number&quot;&gt;192.168&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;.0&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;.1&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;9200&lt;/span&gt;        ESTABLISHED -&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;tcp6       &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;      &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;192.168&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;.0&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;.1&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;9200&lt;/span&gt;        :::*                    LISTEN      -&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;tcp6       &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;      &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;192.168&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;.0&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;.1&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;9200&lt;/span&gt;        &lt;span class=&quot;number&quot;&gt;192.168&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;.0&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;.1&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;53570&lt;/span&gt;       ESTABLISHED -&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;unix  &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;      [ ]         STREAM     CONNECTED     &lt;span class=&quot;number&quot;&gt;105509200&lt;/span&gt; -&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;参数说明：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;-p  process&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;-a  all,显示所有连接和监听端口。&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;-n  以数字显示地址和端口（否则忽略虚拟机动态ip，127.0.0.1会以localhost显示）&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&quot;进程相关&quot;&gt;&lt;a href=&quot;#进程相关&quot; class=&quot;headerlink&quot; title=&quot;进程相关&quot;&gt;&lt;/a&gt;进程相关&lt;/h2&gt;&lt;h3 id=&quot;top&quot;&gt;&lt;a href=&quot;#top&quot; class=&quot;headerlink&quot; title=&quot;top&quot;&gt;&lt;/a&gt;top&lt;/h3&gt;&lt;p&gt;相关命令：c,m,u等&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;// 实时查看某个进程创建的线程情况&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;$ top -H -p &amp;lt;pid&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;// 类似有，但还是top信息更多&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;$ ps -T -p &amp;lt;pid&amp;gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;ps&quot;&gt;&lt;a href=&quot;#ps&quot; class=&quot;headerlink&quot; title=&quot;ps&quot;&gt;&lt;/a&gt;ps&lt;/h3&gt;&lt;p&gt;显示瞬间行程(process)的动态&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用权限：&lt;/strong&gt;所有使用者&lt;br&gt;&lt;strong&gt;使用方式：&lt;/strong&gt;&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;ps [options] [--help]&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数：&lt;/strong&gt;&lt;br&gt;ps的参数非常多,在此仅列出几个常用的参数并大略介绍含义&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;-A  列出所有的进程&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;-w  显示加宽可以显示较多的资讯&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;-au 显示较详细的资讯&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;-aux 显示所有包含其他使用者的行程&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;可添加过滤用户：&lt;/strong&gt;&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;| grep xx&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;杀死进程：&lt;/strong&gt;&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;kill -s 9 xxx(pid)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;# 等价于&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;kill -9 xxx(pid)&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;查看运行进程的绝对路径&quot;&gt;&lt;a href=&quot;#查看运行进程的绝对路径&quot; class=&quot;headerlink&quot; title=&quot;查看运行进程的绝对路径&quot;&gt;&lt;/a&gt;查看运行进程的绝对路径&lt;/h3&gt;&lt;p&gt;先通过top或其它命令查看pid，再通过以下命令查看真实运行路径：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;$ ls -al /proc/24416/exe&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;lrwxrwxrwx 1 hadoop hadoop 0 Apr  1 21:51 /proc/24416/exe -&amp;gt; /home/hadoop/jdk1.8.0_40/bin/java&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&quot;文件编码&quot;&gt;&lt;a href=&quot;#文件编码&quot; class=&quot;headerlink&quot; title=&quot;文件编码&quot;&gt;&lt;/a&gt;文件编码&lt;/h2&gt;&lt;p&gt;当将可执行的文件从windows系统搬到linux下，可能会报类似’\r’ 找不到命令的错误，那是因为shell命令中格式与dos命令格式不对造成的，只需要运行：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;dos2unix file.sh&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&quot;文件统计&quot;&gt;&lt;a href=&quot;#文件统计&quot; class=&quot;headerlink&quot; title=&quot;文件统计&quot;&gt;&lt;/a&gt;文件统计&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;对当前路径下文件的存储进行从大到小的排序并打印，显示G,MB,K等&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;du -sh * | sort -rh&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;统计第二行逗号出现的次数&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;sed -n &amp;apos;2 p&amp;apos; test.csv/part-00000 |grep -o &amp;quot;,&amp;quot;|wc -l&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;合并操作&lt;br&gt;感受下paste的魅力：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;paste -d &amp;quot; &amp;quot;  - - - - &amp;lt; 16_1.fastq&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;用户操作&quot;&gt;&lt;a href=&quot;#用户操作&quot; class=&quot;headerlink&quot; title=&quot;用户操作&quot;&gt;&lt;/a&gt;用户操作&lt;/h2&gt;&lt;h3 id=&quot;增加用户&quot;&gt;&lt;a href=&quot;#增加用户&quot; class=&quot;headerlink&quot; title=&quot;增加用户&quot;&gt;&lt;/a&gt;增加用户&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;方法1&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;useradd -d /data/home/user1 -s /bin/bash -m user1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;passwd user1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;方法2&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;adduser --home /software/home/xxx xxx&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;vim /etc/passwd&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;添加组&quot;&gt;&lt;a href=&quot;#添加组&quot; class=&quot;headerlink&quot; title=&quot;添加组&quot;&gt;&lt;/a&gt;添加组&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;# add to hadoop groups&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;sudo usermod -a -G hadoop user1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;移除组&quot;&gt;&lt;a href=&quot;#移除组&quot; class=&quot;headerlink&quot; title=&quot;移除组&quot;&gt;&lt;/a&gt;移除组&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;gpasswd -d 用户名 组名&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;无密码ssh&quot;&gt;&lt;a href=&quot;#无密码ssh&quot; class=&quot;headerlink&quot; title=&quot;无密码ssh&quot;&gt;&lt;/a&gt;无密码ssh&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;一般做法&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;生成两个重要文件&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;ssh-keygen -t rsa&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;id-rsa     #私钥&lt;br&gt;id-rsa.pub   #公钥&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;将公钥中的内容追加到另一台机器文件中&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;~/.ssh/authorized_keys&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这样另一台机器就可以无密码ssh到生成公钥对应的机器。同理，其它机器也要这样做，那么假如有n台机器，每台机器authorized_keys文件需要n-1行，代表其它n-1台机器的公钥。优点麻烦，用第二种方法。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;共用公私钥&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;生成两个重要文件&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;ssh-keygen -t rsa&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;id-rsa     #私钥&lt;br&gt;id-rsa.pub   #公钥&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;复制和分发&lt;br&gt;新建一个authorized_keys文件，内容为id-rsa.pub中的一行，然后将这&lt;strong&gt;三个文件&lt;/strong&gt;共享到其它节点的~/.ssh目录下，切记，3个文件都要拷贝。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;tmux工具&quot;&gt;&lt;a href=&quot;#tmux工具&quot; class=&quot;headerlink&quot; title=&quot;tmux工具&quot;&gt;&lt;/a&gt;tmux工具&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;删除panel:&lt;br&gt;  C-x + x&lt;/li&gt;
&lt;li&gt;迅速切换排版（水平或垂直）:&lt;br&gt;  C-x + 空格&lt;/li&gt;
&lt;li&gt;创建新窗口（panel)&lt;br&gt;  C-x + c&lt;/li&gt;
&lt;li&gt;进行切换:&lt;br&gt;  C-x + 数字键&lt;/li&gt;
&lt;li&gt;复制粘贴:&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;C-x [ 进入复制模式&lt;/li&gt;
&lt;li&gt;参考上表移动鼠标到要复制的区域，移动鼠标时可用vim的搜索功能”/“,”?”&lt;/li&gt;
&lt;li&gt;安空格键开始选择复制区域&lt;/li&gt;
&lt;li&gt;选择完成后安enter键退出&lt;/li&gt;
&lt;li&gt;C-x ] 粘贴&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;清除区域内容：&lt;br&gt;C-l&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;开机自启动&quot;&gt;&lt;a href=&quot;#开机自启动&quot; class=&quot;headerlink&quot; title=&quot;开机自启动&quot;&gt;&lt;/a&gt;开机自启动&lt;/h2&gt;&lt;h3 id=&quot;Example&quot;&gt;&lt;a href=&quot;#Example&quot; class=&quot;headerlink&quot; title=&quot;Example:&quot;&gt;&lt;/a&gt;Example:&lt;/h3&gt;&lt;p&gt;Ubuntu下，作为利用apt-get的常规软件，以Nginx为例&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;编辑开机nginx启动脚本（自动安装的忽略）&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;/usr/local/nginx.sh&lt;/li&gt;
&lt;li&gt;在/etc/init.d目录下创建链接文件到前面的脚本： ln -s /usr/local/nginx.sh /etc/init.d/nginx&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;设置nginx脚本可执行权限（自动安装的忽略）&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;chmod u+x /etc/init.d/nginx&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;进入/etc/init.d目录，将该脚本设为开启自启动&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;update-rc.d -f nginx defaults [startnum] [killnum]&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其中的[startnum]表示启动顺序，[killnum]表示退出顺序，都为可选参数，取值范围是0-99。序号越大的越晚执行。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果想取消开机自启动&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;update-rc.d -f nginx remove&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;-f选项表示强制执行。&lt;/p&gt;
&lt;h2 id=&quot;端口映射&quot;&gt;&lt;a href=&quot;#端口映射&quot; class=&quot;headerlink&quot; title=&quot;端口映射&quot;&gt;&lt;/a&gt;端口映射&lt;/h2&gt;&lt;p&gt;nohup portforward :8080 cu01:8080 &amp;amp;&lt;/p&gt;
&lt;h2 id=&quot;更改文件权限&quot;&gt;&lt;a href=&quot;#更改文件权限&quot; class=&quot;headerlink&quot; title=&quot;更改文件权限&quot;&gt;&lt;/a&gt;更改文件权限&lt;/h2&gt;&lt;p&gt;chmod ［who］ ［+ | - | =］ ［mode］ 文件名&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;权限范围：&lt;br&gt;u ：目录或者文件的当前的用户&lt;br&gt;g ：目录或者文件的当前的群组&lt;br&gt;o ：除了目录或者文件的当前用户或群组之外的用户或者群组&lt;br&gt;a ：所有的用户及群组&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;权限代号：&lt;br&gt;r ：读权限，用数字4表示&lt;br&gt;w ：写权限，用数字2表示&lt;br&gt;x ：执行权限，用数字1表示&lt;br&gt;s ：特殊权限，如root般操作该文件&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;e.g 为所有用户添加执行test.log的权限&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;chmod a+x test.log&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;用代号是最灵活的方式，但当只涉及对所有用户的，并且是直接设定某个权限，用数字是最直接的。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;chmod 764 test.log&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;表示用户拥有所有权限，所在组其它成员拥有读写权限，其它用户只有读权限。&lt;/p&gt;
&lt;h2 id=&quot;git&quot;&gt;&lt;a href=&quot;#git&quot; class=&quot;headerlink&quot; title=&quot;git&quot;&gt;&lt;/a&gt;git&lt;/h2&gt;&lt;h3 id=&quot;初始化远程仓库&quot;&gt;&lt;a href=&quot;#初始化远程仓库&quot; class=&quot;headerlink&quot; title=&quot;初始化远程仓库&quot;&gt;&lt;/a&gt;初始化远程仓库&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;cd /SHARE/repositories/&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;mkdir webpy &amp;amp; cd webpy&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;mkdir webpy.git &amp;amp; cd webpy.git&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;git init --bare&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;初始化本地仓库&quot;&gt;&lt;a href=&quot;#初始化本地仓库&quot; class=&quot;headerlink&quot; title=&quot;初始化本地仓库&quot;&gt;&lt;/a&gt;初始化本地仓库&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;cd local_project&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;git init&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;git add .&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;git commit -m &amp;quot;xxx&amp;quot;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;查看、添加、修改远程仓库&quot;&gt;&lt;a href=&quot;#查看、添加、修改远程仓库&quot; class=&quot;headerlink&quot; title=&quot;查看、添加、修改远程仓库&quot;&gt;&lt;/a&gt;查看、添加、修改远程仓库&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;git remote -v&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;git remote add origin gujw@192.168.0.2:/SHARE/repositories/webpy/webpy.git&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;git remote set-url origin gujw@192.168.0.2:/SHARE/repositories/webpy/webpy.git&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Tip：对于共享目录的仓库而言，修改client端的ip即可，远程仓库地址不变。&lt;/p&gt;
&lt;h3 id=&quot;修改github仓库&quot;&gt;&lt;a href=&quot;#修改github仓库&quot; class=&quot;headerlink&quot; title=&quot;修改github仓库&quot;&gt;&lt;/a&gt;修改github仓库&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;git remote add origin git@github.com:username/RepoName.git&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;git push origin master&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;运行脚本的方法&quot;&gt;&lt;a href=&quot;#运行脚本的方法&quot; class=&quot;headerlink&quot; title=&quot;运行脚本的方法&quot;&gt;&lt;/a&gt;运行脚本的方法&lt;/h2&gt;&lt;h3 id=&quot;常用运行方法&quot;&gt;&lt;a href=&quot;#常用运行方法&quot; class=&quot;headerlink&quot; title=&quot;常用运行方法:&quot;&gt;&lt;/a&gt;常用运行方法:&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;$ bash a.sh&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;$ chmod +x a.sh&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;$ ./a.sh&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;$ source a.sh&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://enjoyhot.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://enjoyhot.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>数据结构基础</title>
    <link href="http://enjoyhot.github.io/2017/04/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/"/>
    <id>http://enjoyhot.github.io/2017/04/29/数据结构基础/</id>
    <published>2017-04-29T09:22:09.000Z</published>
    <updated>2017-04-30T09:29:40.184Z</updated>
    
    <content type="html">&lt;h1 id=&quot;Tree&quot;&gt;&lt;a href=&quot;#Tree&quot; class=&quot;headerlink&quot; title=&quot;Tree&quot;&gt;&lt;/a&gt;Tree&lt;/h1&gt;&lt;h2 id=&quot;完全二叉树&quot;&gt;&lt;a href=&quot;#完全二叉树&quot; class=&quot;headerlink&quot; title=&quot;完全二叉树&quot;&gt;&lt;/a&gt;完全二叉树&lt;/h2&gt;&lt;p&gt;只有最下面的两层结点度小于2，并且最下面一层的结点都集中在该层最左边的若干位置的二叉树，不一定有排序；&lt;/p&gt;
&lt;h2 id=&quot;满二叉树&quot;&gt;&lt;a href=&quot;#满二叉树&quot; class=&quot;headerlink&quot; title=&quot;满二叉树&quot;&gt;&lt;/a&gt;满二叉树&lt;/h2&gt;&lt;p&gt;除了叶结点外每一个结点都有左右子叶且叶结点都处在最底层的二叉树。&lt;/p&gt;
&lt;h2 id=&quot;平衡二叉树（AVL）&quot;&gt;&lt;a href=&quot;#平衡二叉树（AVL）&quot; class=&quot;headerlink&quot; title=&quot;平衡二叉树（AVL）&quot;&gt;&lt;/a&gt;平衡二叉树（AVL）&lt;/h2&gt;&lt;p&gt;平衡二叉树（Balanced Binary Tree）是二叉查找树（也称为排序二叉树，左小于右）的一个进化体，也是第一个引入平衡概念的二叉树。1962年，G.M. Adelson-Velsky 和 E.M. Landis发明了这棵树，所以它又叫AVL树。平衡二叉树要求对于每一个节点来说，它的左右子树的高度之差不能超过1，如果插入或者删除一个节点使得高度之差大于1，就要进行节点之间的旋转，将二叉树重新维持在一个平衡状态。这个方案很好的解决了二叉查找树退化成链表的问题，把插入，查找，删除的时间复杂度最好情况和最坏情况都维持在O(logN)。但是频繁旋转会使插入和删除牺牲掉O(logN)左右的时间，不过相对二叉查找树来说，时间上稳定了很多。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;center&gt;&lt;br&gt;&lt;img src=&quot;http://pic002.cnblogs.com/images/2012/229056/2012082016003157.jpg&quot; alt=&quot;举例比较&quot;&gt;&lt;br&gt;&lt;/center&gt;


&lt;h3 id=&quot;可能有这种说法&quot;&gt;&lt;a href=&quot;#可能有这种说法&quot; class=&quot;headerlink&quot; title=&quot;可能有这种说法&quot;&gt;&lt;/a&gt;可能有这种说法&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;一种二叉搜索树&lt;br&gt;1.所有非叶子结点&lt;strong&gt;至多&lt;/strong&gt;拥有两个儿子（Left和Right）；&lt;br&gt;2.左边小于右边，大局观也是如此；&lt;/li&gt;
&lt;li&gt;特点&lt;br&gt;1.当B树的所有非叶子结点的左右子树的结点数目均保持差不多（平衡），那么B树&lt;br&gt;的搜索性能逼近二分查找（从线性到log2N），有利于增删改查；&lt;br&gt;2.同时它比连续内存空间的二分查找的优点是，这些操作不需要移动大段的内存数据，甚至通常是常数开销；&lt;/li&gt;
&lt;li&gt;使用&lt;br&gt;尽量将元素构建为左边平衡的结构:&lt;center&gt;&lt;br&gt;&lt;img src=&quot;http://p.blog.csdn.net/images/p_blog_csdn_net/manesking/31.JPG&quot; alt=&quot;此处输入图片的描述&quot;&gt;&lt;br&gt;&lt;/center&gt;

&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;Treap树堆&quot;&gt;&lt;a href=&quot;#Treap树堆&quot; class=&quot;headerlink&quot; title=&quot;Treap树堆&quot;&gt;&lt;/a&gt;Treap树堆&lt;/h2&gt;&lt;p&gt;作用：Treap的特点是实现简单，且能基本实现随机平衡的结构,避免变为链式结构。&lt;/p&gt;
&lt;p&gt;一棵treap是一棵修改了结点顺序的二叉查找树。通常树内的每个结点x都有一个关键字值key[x]，另外，还要为结点分配priority[x]，treap的结点排列成让关键字遵循二叉查找树性质，并且优先级遵循最小堆顺序性质：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果v是u的左孩子，则key[v] &amp;lt; key[u].&lt;/li&gt;
&lt;li&gt;如果v是u的右孩子，则key[v] &amp;gt; key[u].&lt;/li&gt;
&lt;li&gt;如果v是u的孩子，则priority[u] &amp;gt; priority[v].&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;treap插入操作：&lt;br&gt;1.按照二叉树的插入方法，将结点插入到树中&lt;br&gt;2.根据堆的性质(我们这里为最小堆)和优先级的大小调整结点位置，旋转不破坏排序树的特征。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;treap删除操作：&lt;br&gt;1.找到相应的结点&lt;br&gt;2.若该结点为叶子结点，则直接删除；&lt;br&gt;若该结点为只包含一个叶子结点的结点，则将其叶子结点赋值给它；&lt;br&gt;若该结点为其他情况下的节点，则进行相应的旋转，直到该结点为上述情况之一，然后进行删除。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;具体例子见：&lt;a href=&quot;http://blog.csdn.net/yang_yulei/article/details/46005845&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.csdn.net/yang_yulei/article/details/46005845&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;B-树&quot;&gt;&lt;a href=&quot;#B-树&quot; class=&quot;headerlink&quot; title=&quot;B-树&quot;&gt;&lt;/a&gt;B-树&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;M叉搜索树&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;定义任意非叶子结点&lt;strong&gt;最多只有M个儿子&lt;/strong&gt;；且M&amp;gt;2；&lt;/li&gt;
&lt;li&gt;根结点的儿子数为[2, M]；&lt;/li&gt;
&lt;li&gt;除根结点以外的非叶子结点的儿子数为[M/2, M]；&lt;/li&gt;
&lt;li&gt;每个结点存放至少M/2-1（取上整）和至多M-1个关键字；（至少2个关键字）&lt;/li&gt;
&lt;li&gt;非叶子结点的关键字个数=指向儿子的指针个数-1；&lt;/li&gt;
&lt;li&gt;非叶子结点的关键字：K&lt;a href=&quot;http://hi.csdn.net/attachment/201112/18/0_1324206104Z6fI.gif&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;1&lt;/a&gt;, K&lt;a href=&quot;http://images2015.cnblogs.com/blog/318837/201604/318837-20160422104522991-406805984.png&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;2&lt;/a&gt;, …, K[M-1]；且K[i] &amp;lt; K[i+1]；&lt;/li&gt;
&lt;li&gt;非叶子结点的指针：P&lt;a href=&quot;http://hi.csdn.net/attachment/201112/18/0_1324206104Z6fI.gif&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;1&lt;/a&gt;, P&lt;a href=&quot;http://images2015.cnblogs.com/blog/318837/201604/318837-20160422104522991-406805984.png&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;2&lt;/a&gt;, …, P[M]；其中P&lt;a href=&quot;http://hi.csdn.net/attachment/201112/18/0_1324206104Z6fI.gif&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;1&lt;/a&gt;指向关键字小于K&lt;a href=&quot;http://hi.csdn.net/attachment/201112/18/0_1324206104Z6fI.gif&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;1&lt;/a&gt;的子树，P[M]指向关键字大于K[M-1]的子树，其它P[i]指向关键字属于(K[i-1], K[i])的子树；&lt;/li&gt;
&lt;li&gt;所有叶子结点位于同一层；&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;特点&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;关键字集合分布在整颗树中；&lt;/li&gt;
&lt;li&gt;任何一个关键字出现且只出现在一个结点中；&lt;/li&gt;
&lt;li&gt;搜索有可能在非叶子结点结束；&lt;/li&gt;
&lt;li&gt;其搜索性能等价于在关键字全集内做一次二分查找；&lt;/li&gt;
&lt;li&gt;自动层次控制；&lt;/li&gt;
&lt;li&gt;根节点使用关键字个数：&lt;strong&gt;最多M-1&lt;/strong&gt;,最少M/2-1，向上取整&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;使用&lt;br&gt;M=3:&lt;br&gt;&lt;center&gt;&lt;br&gt;&lt;img src=&quot;http://img.blog.csdn.net/20160805191715603&quot; alt=&quot;M=3&quot;&gt;&lt;br&gt;&lt;img src=&quot;http://hi.csdn.net/attachment/201112/18/0_1324206104Z6fI.gif&quot; alt=&quot;此处输入图片的描述&quot;&gt;&lt;br&gt;&lt;/center&gt;&lt;br&gt;例子：&lt;a href=&quot;http://blog.csdn.net/u013400245/article/details/52824744&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.csdn.net/u013400245/article/details/52824744&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;B-树-1&quot;&gt;&lt;a href=&quot;#B-树-1&quot; class=&quot;headerlink&quot; title=&quot;B+树&quot;&gt;&lt;/a&gt;B+树&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;与B-树的差异&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;有n棵子树的结点中含有n个关键字，每个关键字不保存数据，只用来索引，所有数据都保存在叶子节点。&lt;/li&gt;
&lt;li&gt;所有的叶子结点中包含了全部关键字的信息，及指向含这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。&lt;/li&gt;
&lt;li&gt;所有的非终端结点可以看成是索引部分，结点中仅含其子树（根结点）中的最大（或最小）关键字。&lt;br&gt;&lt;strong&gt;通常在B+树上有两个头指针，一个指向根结点，一个指向关键字最小的叶子结点。&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;特点&lt;br&gt;其定义基本与B-树同，除了：&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;非叶子结点的子树指针与关键字个数相同(据July，有争议)；&lt;/li&gt;
&lt;li&gt;非叶子结点的子树指针P[i]，指向关键字值属于[K[i], K[i+1])的子树（B-树是开区间）；&lt;/li&gt;
&lt;li&gt;所有关键字都在叶子结点出现；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;一般在数据库系统或文件系统中使用的B+Tree结构都在经典B+Tree的基础上进行了优化，增加了顺序访问指针，如下图：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;在B+Tree的每个叶子节点增加一个指向相邻叶子节点的指针(链指针)，就形成了带有顺序访问指针的B+Tree。做这个优化的目的是为了提高区间访问的性能，例如图4中如果要查询key为从18到49的所有数据记录，当找到18后，只需顺着节点和指针顺序遍历就可以一次性访问到所有数据节点，极大提到了区间查询效率。
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;使用&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;B+树的基本操作：&lt;br&gt;&lt;strong&gt;查找操作&lt;/strong&gt;&lt;br&gt;对B+树可以进行两种查找运算：&lt;br&gt;　　a.从最小关键字起顺序查找；&lt;br&gt;　　b.从根结点开始，进行随机查找。&lt;br&gt;　　在查找时，若非终端结点上的剧组机等于给定值，并不终止，而是继续向下直到叶子结点。因此，在B+树中，不管查找成功与否，每次查找都是走了一条从根到叶子结点的路径。其余同B-树的查找类似。&lt;br&gt;&lt;strong&gt;插入操作&lt;/strong&gt;&lt;br&gt;    B+树的插入与B树的插入过程类似。不同的是B+树在叶结点上进行，如果叶结点中的关键码个数超过m，就必须分裂成关键码数目大致相同的两个结点，并保证上层结点中有这两个结点的最大关键码。(算法见百度百科)&lt;br&gt;&lt;strong&gt;删除操作&lt;/strong&gt;&lt;br&gt;    B+树的删除也仅在叶子结点进行，当叶子结点中的最大关键字被删除时，其在非终端结点中的值可以作为一个“分界关键字”存在。若因删除而使结点中关键字的个数少于m/2 （m/2结果取上界，如5/2结果为3）时，其和兄弟结点的合并过程亦和B-树类似。&lt;/p&gt;
&lt;p&gt;如M=3:&lt;/p&gt;
&lt;center&gt;&lt;br&gt;&lt;img src=&quot;http://img.blog.csdn.net/20160805192039968&quot; alt=&quot;M=3&quot;&gt;&lt;br&gt;&lt;/center&gt;&lt;br&gt;1. 所有关键字都出现在叶子结点的链表中（稠密索引），且链表中的关键字恰好是有序的；&lt;br&gt;2. 非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层；&lt;br&gt;3. 更适合文件索引系统（见FAQ）；&lt;br&gt;&lt;br&gt;## B&lt;em&gt;-树&lt;br&gt;&lt;br&gt;B&lt;/em&gt;-树是B+树的变体，在B+树的非根和非叶子结点再增加指向兄弟的指针：&lt;br&gt;M=3:&lt;br&gt;&lt;center&gt;&lt;br&gt;&lt;img src=&quot;http://img.blog.csdn.net/20160805192156312&quot; alt=&quot;M=3&quot;&gt;&lt;br&gt;&lt;/center&gt;

&lt;p&gt;与B+-树区别：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;B+树的分裂：当一个结点满时，分配一个新的结点，并将原结点中1/2的数据&lt;br&gt;复制到新结点，最后在父结点中增加新结点的指针；B+树的分裂只影响原结点和父结点，而不会影响兄弟结点，所以它不需要指向兄弟的指针；&lt;/li&gt;
&lt;li&gt;B*树的分裂：当一个结点满时，如果它的下一个兄弟结点未满，那么将一部分&lt;br&gt;数据移到兄弟结点中，再在原结点插入关键字，最后修改父结点中兄弟结点的关键字（因为兄弟结点的关键字范围改变了）；如果兄弟也满了，则在原结点与兄弟结点之间增加新结点，并各复制1/3的数据到新结点，最后在父结点增加新结点的指针；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;所以，B*树分配新结点的概率比B+树要低，空间使用率更高；在B+树基础上，为非叶子结点也增加链表指针，将结点的最低利用率从1/2提高到2/3；&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;红黑树（不追求“完全平衡”）&quot;&gt;&lt;a href=&quot;#红黑树（不追求“完全平衡”）&quot; class=&quot;headerlink&quot; title=&quot;红黑树（不追求“完全平衡”）&quot;&gt;&lt;/a&gt;红黑树（不追求“完全平衡”）&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://hi.csdn.net/attachment/201012/29/8394323_1293613306CGzE.jpg&quot; alt=&quot;红黑树&quot;&gt;&lt;br&gt;1）每个结点要么是红的，要么是黑的。&lt;br&gt;2）根结点是黑的。&lt;br&gt;3）每个叶结点，即空结点（NIL）是黑的。&lt;br&gt;4）如果一个结点是红的，那么它的&lt;strong&gt;俩个&lt;/strong&gt;儿子都是黑的。&lt;br&gt;5）对每个结点，从该结点到其子孙结点的所有路径上包含相同数目的黑结点。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这些约束的好处是&lt;/strong&gt;：保持了树的相对平衡，同时又比AVL的插入删除操作的复杂性要低许多。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;由于它的设计，任何不平衡都会在三次旋转之内解决,AVL树有最多O(logN)次旋转。&lt;/li&gt;
&lt;li&gt;如果插入一个node引起了树的不平衡，AVL和RB-Tree都是最多只需要2次旋转操作，即两者都是O(1)；但是在删除node引起树的不平衡时，最坏情况下，AVL需要维护从被删node到root这条路径上所有node的平衡性，因此需要旋转的量级O(logN)，而RB-Tree最多只需3次旋转，只需要O(1)的复杂度。&lt;/li&gt;
&lt;li&gt;其次，AVL的结构相较RB-Tree来说更为平衡，在插入和删除node更容易引起Tree的unbalance，因此在大量数据需要插入或者删除时，AVL需要rebalance的频率会更高。因此，RB-Tree在需要大量插入和删除node的场景下，效率更高。自然，由于AVL高度平衡，因此AVL的search效率更高。&lt;/li&gt;
&lt;li&gt;map的实现只是折衷了两者在search、insert以及delete下的效率。总体来说，RB-tree的统计性能是高于AVL的。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&quot;http://www.importnew.com/21818.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.importnew.com/21818.html&lt;/a&gt;&lt;br&gt;&lt;img src=&quot;http://images2015.cnblogs.com/blog/939998/201605/939998-20160517211944357-1810109113.png&quot; alt=&quot;get&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;为什么需要红黑树？&quot;&gt;&lt;a href=&quot;#为什么需要红黑树？&quot; class=&quot;headerlink&quot; title=&quot;为什么需要红黑树？&quot;&gt;&lt;/a&gt;为什么需要红黑树？&lt;/h3&gt;&lt;p&gt;map,set底层都提供了排序功能，且查找速度快。红黑树实际上是AVL的一种变形，但是其比AVL(平衡二叉搜索树)具有更高的插入效率，当然查找效率会平衡二叉树稍微低一点点，毕竟平衡二叉树太完美了。但是这种查找效率的损失是非常值得的。它的操作有着良好的最坏情况运行时间，并且在实践中是高效的: 它可以在O(logn)时间内做查找，插入和删除，这里的n是树中元素的数目。&lt;/p&gt;
&lt;h1 id=&quot;排序&quot;&gt;&lt;a href=&quot;#排序&quot; class=&quot;headerlink&quot; title=&quot;排序&quot;&gt;&lt;/a&gt;排序&lt;/h1&gt;&lt;h2 id=&quot;堆排序&quot;&gt;&lt;a href=&quot;#堆排序&quot; class=&quot;headerlink&quot; title=&quot;堆排序&quot;&gt;&lt;/a&gt;堆排序&lt;/h2&gt;&lt;p&gt;输入无序序列 { 1, 3, 4, 5, 2, 6, 9, 7, 8, 0 } ，如下所示，先建最大堆，建立最大堆的过程是先将原序列按照完全二叉树的顺序进行排列，然后从N/2个节点（向下取整）开始进行交换。&lt;br&gt;建完堆之后，再利用堆调整过程不断取堆顶，最终获得排序后结果。&lt;br&gt;&lt;img src=&quot;http://images2015.cnblogs.com/blog/318837/201604/318837-20160422104522991-406805984.png&quot; alt=&quot;此处输入图片的描述&quot;&gt;&lt;br&gt;&lt;img src=&quot;http://images2015.cnblogs.com/blog/318837/201604/318837-20160422104524038-1723180638.png&quot; alt=&quot;此处输入图片的描述&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;几种常见的数据结构的操作性能对比&quot;&gt;&lt;a href=&quot;#几种常见的数据结构的操作性能对比&quot; class=&quot;headerlink&quot; title=&quot;几种常见的数据结构的操作性能对比&quot;&gt;&lt;/a&gt;几种常见的数据结构的操作性能对比&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://uploadfiles.nowcoder.com/files/20140920/105_1411202746369_3.png&quot; alt=&quot;此处输入图片的描述&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;关于树的FAQ&quot;&gt;&lt;a href=&quot;#关于树的FAQ&quot; class=&quot;headerlink&quot; title=&quot;关于树的FAQ&quot;&gt;&lt;/a&gt;关于树的FAQ&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;红黑树用于内存搜索，磁盘搜索用的多是多路树？&lt;br&gt;因为磁盘读取效率是很慢的，读取次数是基于树高度，所以像数据库中的B/B+索引都是多路树，每一个block中存放多个子节点信息，减少磁盘读取次数。&lt;/li&gt;
&lt;li&gt;为什么说B+-tree比B树更适合实际应用中操作系统的文件索引和数据库索引？&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;B+-tree的磁盘读写代价更低&lt;br&gt;B+-tree的内部结点并没有指向关键字具体信息的指针。因此其内部结点相对B 树更小。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说IO读写次数也就降低了。&lt;br&gt; &lt;strong&gt;举个例子&lt;/strong&gt;，假设磁盘中的一个盘块容纳16bytes，而一个关键字2bytes，一个关键字具体信息指针2bytes。一棵9阶B-tree(一个结点最多8个关键字)的内部结点需要2个盘快（2&lt;em&gt;8+2&lt;/em&gt;8）。而B+树内部结点只需要1个盘快。当需要把内部结点读入内存中的时候（查找是基于节点信息），B 树就比B+ 树多一次盘块查找时间(在磁盘中就是盘片旋转的时间)。&lt;/li&gt;
&lt;li&gt;B+-tree的查询效率更加稳定（查询时间的均衡）&lt;br&gt;由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;读者点评：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;本文评论下第149楼，fanyy1991针对上文所说的两点，道：个人觉得这两个原因都不是主要原因。数据库索引采用B+树的主要原因是（上述从检索的角度，这里从遍历的角度）：&lt;br&gt;B-树在提高了磁盘IO性能的同时并没有解决元素遍历的效率低下的问题。正是为了解决这个问题，B+树应运而生。B+树只要遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作（或者说效率太低）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;不同的引擎对于索引有不同的支持：Innodb和MyISAM默认的索引是Btree索引（之后版本B+树）；而Memory默认的索引是Hash索引（哈希值可能重复，所以检索效率未必就高）。&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Tree&quot;&gt;&lt;a href=&quot;#Tree&quot; class=&quot;headerlink&quot; title=&quot;Tree&quot;&gt;&lt;/a&gt;Tree&lt;/h1&gt;&lt;h2 id=&quot;完全二叉树&quot;&gt;&lt;a href=&quot;#完全二叉树&quot; class=&quot;headerlink&quot; title=&quot;完全二叉树&quot;&gt;&lt;/a&gt;完全二叉树&lt;/h2&gt;&lt;p&gt;只有最下面的两层结点度小于2，并且最下面一层的结点都集中在该层最左边的若干位置的二叉树，不一定有排序；&lt;/p&gt;
&lt;h2 id=&quot;满二叉树&quot;&gt;&lt;a href=&quot;#满二叉树&quot; class=&quot;headerlink&quot; title=&quot;满二叉树&quot;&gt;&lt;/a&gt;满二叉树&lt;/h2&gt;&lt;p&gt;除了叶结点外每一个结点都有左右子叶且叶结点都处在最底层的二叉树。&lt;/p&gt;
&lt;h2 id=&quot;平衡二叉树（AVL）&quot;&gt;&lt;a href=&quot;#平衡二叉树（AVL）&quot; class=&quot;headerlink&quot; title=&quot;平衡二叉树（AVL）&quot;&gt;&lt;/a&gt;平衡二叉树（AVL）&lt;/h2&gt;&lt;p&gt;平衡二叉树（Balanced Binary Tree）是二叉查找树（也称为排序二叉树，左小于右）的一个进化体，也是第一个引入平衡概念的二叉树。1962年，G.M. Adelson-Velsky 和 E.M. Landis发明了这棵树，所以它又叫AVL树。平衡二叉树要求对于每一个节点来说，它的左右子树的高度之差不能超过1，如果插入或者删除一个节点使得高度之差大于1，就要进行节点之间的旋转，将二叉树重新维持在一个平衡状态。这个方案很好的解决了二叉查找树退化成链表的问题，把插入，查找，删除的时间复杂度最好情况和最坏情况都维持在O(logN)。但是频繁旋转会使插入和删除牺牲掉O(logN)左右的时间，不过相对二叉查找树来说，时间上稳定了很多。&lt;br&gt;
    
    </summary>
    
      <category term="Basis" scheme="http://enjoyhot.github.io/categories/Basis/"/>
    
    
      <category term="Basis" scheme="http://enjoyhot.github.io/tags/Basis/"/>
    
  </entry>
  
  <entry>
    <title>MySQL</title>
    <link href="http://enjoyhot.github.io/2017/04/29/MySQL/"/>
    <id>http://enjoyhot.github.io/2017/04/29/MySQL/</id>
    <published>2017-04-29T09:21:09.000Z</published>
    <updated>2017-04-30T09:29:40.160Z</updated>
    
    <content type="html">&lt;h1 id=&quot;设计&quot;&gt;&lt;a href=&quot;#设计&quot; class=&quot;headerlink&quot; title=&quot;设计&quot;&gt;&lt;/a&gt;设计&lt;/h1&gt;&lt;h2 id=&quot;三大范式&quot;&gt;&lt;a href=&quot;#三大范式&quot; class=&quot;headerlink&quot; title=&quot;三大范式&quot;&gt;&lt;/a&gt;三大范式&lt;/h2&gt;&lt;p&gt;范式越高，数据冗余越少，但是增加查询复杂度，表链接时效率更低。范式低，数据冗余高，但是查询会更快。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一范式，确保属性的原子性，如“地址”属性应该再细分为国家，省，市，区等；&lt;/li&gt;
&lt;li&gt;第二范式，如果一个关系满足第一范式,并且除了主键以外的其它列,都依赖于该主键,则满足第二范式；&lt;/li&gt;
&lt;li&gt;第三范式，表中每列都与主键直接相关，如订单记录中，虽说顾客编号和顾客名称都与主键（订单编号）相关，满足第二范式，但顾客名称不是直接相关；&lt;/li&gt;
&lt;/ul&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;存储引擎&quot;&gt;&lt;a href=&quot;#存储引擎&quot; class=&quot;headerlink&quot; title=&quot;存储引擎&quot;&gt;&lt;/a&gt;存储引擎&lt;/h2&gt;&lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;MyISAM&lt;br&gt;这种引擎是mysql最早提供的。这种引擎又可以分为静态MyISAM、动态MyISAM 和压缩MyISAM三种：&lt;ul&gt;
&lt;li&gt;静态MyISAM：如果数据表中的各数据列的长度都是预先固定好的，服务器将自动选择这种表类型。因为数据表中每一条记录所占用的空间都是一样的，所以这种表存取和更新的效率非常高。当数据受损时，恢复工作也比较容易做。&lt;/li&gt;
&lt;li&gt;动态MyISAM：如果数据表中出现varchar、xxxtext或xxxBLOB字段时，服务器将自动选择这种表类型。相对于静态MyISAM，这种表存储空间比较小，但由于每条记录的长度不一，所以多次修改数据后，数据表中的数据就可能离散的存储在内存中，进而导致执行效率下降。同时，内存中也可能会出现很多碎片。因此，这种类型的表要经常用optimize table 命令或优化工具来进行碎片整理。&lt;/li&gt;
&lt;li&gt;压缩MyISAM：以上说到的两种类型的表都可以用myisamchk工具压缩。这种类型的表进一步减小了占用的存储，但是这种表压缩之后不能再被修改。另外，因为是压缩数据，所以这种表在读取的时候要先时行解压缩。&lt;br&gt;但是，不管是何种MyISAM表，目前它都不支持事务，行级锁和外键约束的功能。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;MyISAM Merge引擎&lt;br&gt;这种类型是MyISAM类型的一种变种。合并表是将几个相同的MyISAM表合并为一个虚表。常应用于日志和数据仓库。&lt;/li&gt;
&lt;li&gt;InnoDB&lt;br&gt;InnoDB表类型可以看作是对MyISAM的进一步更新产品，它提供了事务、行级锁机制和外键约束的功能。&lt;/li&gt;
&lt;li&gt;Memory(heap)&lt;br&gt;这种类型的数据表只存在于内存中。它使用散列索引，所以数据的存取速度非常快。因为是存在于内存中，所以这种类型常应用于临时表中。&lt;/li&gt;
&lt;li&gt;archive&lt;br&gt;这种类型只支持select和insert语句，而且不支持索引。常应用于日志记录和聚合分析方面。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;MySql支持的表类型不止上面几种。不同的引擎对于索引有不同的支持，如Innodb和MyISAM默认的索引是Btree索引（之后版本B+树）；而Memory默认的索引是Hash索引（哈希值可能重复，所以检索效率未必就高）&lt;/p&gt;
&lt;h3 id=&quot;数据库锁&quot;&gt;&lt;a href=&quot;#数据库锁&quot; class=&quot;headerlink&quot; title=&quot;数据库锁&quot;&gt;&lt;/a&gt;数据库锁&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;锁粒度&lt;br&gt;MySQL有三种锁的级别：页级、表级、行级。&lt;br&gt;&lt;strong&gt;表级锁：&lt;/strong&gt;开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高,并发度最低。&lt;br&gt;&lt;strong&gt;页面锁：&lt;/strong&gt;开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。&lt;br&gt;&lt;strong&gt;行级锁：&lt;/strong&gt;开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低,并发度也最高。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;常见存储引擎采用锁机制&lt;br&gt;MyISAM和MEMORY存储引擎采用的是表级锁（table-level locking）；&lt;br&gt;BDB(BerkeleyDB)存储引擎采用的是页面锁（page-level locking），但也支持表级锁；&lt;br&gt;InnoDB存储引擎既支持行级锁（row-level locking），也支持表级锁，但默认情况下是采用行级锁。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;锁机制&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;共享锁&lt;br&gt;锁粒度是行或者元组（多个行），读操作&lt;/li&gt;
&lt;li&gt;排它锁&lt;br&gt;锁粒度是行或者元组（多个行），写操作&lt;/li&gt;
&lt;li&gt;说明 e.g.&lt;br&gt;如果事务t1获取了一个元组的共享锁，事务t2还可以立即获取这个元组的共享锁，但不能立即获取这个元组的排它锁（必须等到t1释放共享锁之后）。&lt;br&gt;如果事务t1获取了一个元组的排它锁，事务t2不能立即获取这个元组的共享锁，也不能立即获取这个元组的排它锁（必须等到t1释放排它锁之后）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;锁的应用&lt;br&gt;共享锁、排它锁、意向共享锁、意向排它锁相互之前都是有兼容/互斥关系的，可以用一个兼容性矩阵表示(y表示兼容，n表示不兼容):&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;        X    S    IX    IS&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;X       n     n    n     n&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;S       n     y    n     y&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;IX      n     n    y     y&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;IS      n     y    y     y&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;兼容性矩阵为什么是这个样子的？&lt;br&gt;X和S的相互关系在上文中解释过了，IX和IS的相互关系全部是兼容，这也很好理解，因为它们都只是“有意”，还处于YY阶段，没有真干，所以是可以兼容的；&lt;/p&gt;
&lt;h3 id=&quot;事务操作&quot;&gt;&lt;a href=&quot;#事务操作&quot; class=&quot;headerlink&quot; title=&quot;事务操作&quot;&gt;&lt;/a&gt;事务操作&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;InnoDB&lt;br&gt;支持事务处理，InnoDB写操作快，update快，外键操作效率高&lt;/li&gt;
&lt;li&gt;MyISAM&lt;br&gt;不支持事务操作，读取快，count操作快（因为保存了行数）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;比如说，在人员管理系统中，你删除一个人员，你即需要删除人员的基本资料，也要删除和该人员相关的信息，如信箱，文章等等，这样，这些数据库操作语句就构成一个事务！&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;delete from userinfo where ~~~&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;delete from mail where ~~&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;delete from article where~~&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;如果没有事务处理，在你删除的过程中，假设出错了，只执行了第一句，那么其后果是难以想象的！&lt;br&gt;但用事务处理，像这样类似的一系列操作，要么全部正确执行，要么全部不执行。事务处理就是来做这个事情的。&lt;br&gt;参考：&lt;a href=&quot;http://blog.csdn.net/z702143700/article/details/46048495&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.csdn.net/z702143700/article/details/46048495&lt;/a&gt;&lt;br&gt;具体例子：&lt;a href=&quot;https://segmentfault.com/q/1010000002952450&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://segmentfault.com/q/1010000002952450&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Tips&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用表锁：&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;当事务需要更新大部分数据时，表又比较大，如果使用默认的行锁，不仅效率低，而且还容易造成其他事务长时间等待和锁冲突。&lt;/li&gt;
&lt;li&gt;事务比较复杂，很可能引起死锁导致回滚。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;关于死锁：&lt;ul&gt;
&lt;li&gt;MyISAM总是一次性获得所需的全部锁，要么全部满足，要么全部等待。而在InnoDB中，锁是逐步获得的，就造成了死锁的可能。&lt;/li&gt;
&lt;li&gt;避免死锁&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;如果不同程序会并发存取多个表，尽量约定以相同的顺序访问表，可以大大降低死锁机会。&lt;/li&gt;
&lt;li&gt;在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁产生概率；&lt;/li&gt;
&lt;li&gt;对于非常容易产生死锁的业务部分，可以尝试使用升级锁定颗粒度，通过表级锁定来减少死锁产生的概率；&lt;/li&gt;
&lt;li&gt;发生死锁后，InnoDB一般都可以检测到，并使一个事务释放锁回退，另一个获取锁完成事务。&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;常规表操作&quot;&gt;&lt;a href=&quot;#常规表操作&quot; class=&quot;headerlink&quot; title=&quot;常规表操作&quot;&gt;&lt;/a&gt;常规表操作&lt;/h1&gt;&lt;h2 id=&quot;读操作&quot;&gt;&lt;a href=&quot;#读操作&quot; class=&quot;headerlink&quot; title=&quot;读操作&quot;&gt;&lt;/a&gt;读操作&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;脏读（Dirty Read)&lt;br&gt;脏读意味着一个事务读取了另一个事务未提交的数据,而这个数据是有可能回滚。&lt;/li&gt;
&lt;li&gt;不可重复读(Unrepeatable Read)&lt;br&gt;也称为虚读，不可重复读意味着，在数据库访问中，一个事务范围内两个相同的查询却返回了不同数据。这是由于查询时系统中其他事务修改的提交而引起的。&lt;br&gt;例如：事务B中对某个查询执行两次，当第一次执行完时，事务A对其数据进行了修改。事务B中再次查询时，数据发生了改变&lt;/li&gt;
&lt;li&gt;幻读(phantom read)&lt;br&gt;幻读,是指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象发生了幻觉一样。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;表复制&quot;&gt;&lt;a href=&quot;#表复制&quot; class=&quot;headerlink&quot; title=&quot;表复制&quot;&gt;&lt;/a&gt;表复制&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;类型1,table2-&amp;gt;table1，前提：table1需存在&lt;/p&gt;
&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;insert&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;into&lt;/span&gt; table1(field1,field2) &lt;span class=&quot;keyword&quot;&gt;select&lt;/span&gt; field1,field2 &lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; table2;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;类型2,table2+table3-&amp;gt;table1，前提：table1需存在&lt;/p&gt;
&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;insert&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;into&lt;/span&gt; table1(field1,field2) &lt;span class=&quot;keyword&quot;&gt;select&lt;/span&gt; * &lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;select&lt;/span&gt; field1,field2 &lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; table2 &lt;span class=&quot;keyword&quot;&gt;join&lt;/span&gt; table3) &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt; table23;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;类型3，table2-&amp;gt;table1，前提：table1不能存在&lt;/p&gt;
&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;select&lt;/span&gt; field1,field2 &lt;span class=&quot;keyword&quot;&gt;into&lt;/span&gt; table1 &lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; table2;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;临时表&quot;&gt;&lt;a href=&quot;#临时表&quot; class=&quot;headerlink&quot; title=&quot;临时表&quot;&gt;&lt;/a&gt;临时表&lt;/h2&gt;&lt;p&gt;作用：专用性和私有性，速度上和效率上更高，使用时需先建表，在从大表中抽取数据，在连接关闭后会自动销毁。&lt;br&gt;&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;create&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;temporary&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;table&lt;/span&gt; table1(&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Integer&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;Not&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;Auto&lt;/span&gt; increasement,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;varchar&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;255&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    primary &lt;span class=&quot;keyword&quot;&gt;key&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&quot;内存表&quot;&gt;&lt;a href=&quot;#内存表&quot; class=&quot;headerlink&quot; title=&quot;内存表&quot;&gt;&lt;/a&gt;内存表&lt;/h2&gt;&lt;p&gt;作用：数据在内存中，表结构持久化到磁盘，show tables时可见，其执行引擎为memory，一般较少用。&lt;/p&gt;
&lt;h2 id=&quot;关联查询&quot;&gt;&lt;a href=&quot;#关联查询&quot; class=&quot;headerlink&quot; title=&quot;关联查询&quot;&gt;&lt;/a&gt;关联查询&lt;/h2&gt;&lt;p&gt;mysql默认的join是inner join。&lt;/p&gt;
&lt;center&gt;&lt;br&gt;&lt;img src=&quot;http://www.phpddt.com/usr/uploads/2013/08/3846700421.png&quot; alt=&quot;此处输入图片的描述&quot;&gt;&lt;br&gt;&lt;/center&gt;&lt;br&gt;### cross join&lt;br&gt;交叉连接，以例子说明：&lt;br&gt;&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;select&lt;/span&gt; * &lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; table1 &lt;span class=&quot;keyword&quot;&gt;cross&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;join&lt;/span&gt; table2;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br&gt;&lt;br&gt;笛卡尔乘积，从table1循环取出每一条记录，每条都与table2匹配，都保留，实际场景中较少用。&lt;br&gt;### inner [outer] join&lt;br&gt;(有无outer都一样，下同)&lt;br&gt;内连接，根据on匹配，相当于求交集（多个匹配则相乘），没有on则求并集，与交叉连接一样；&lt;br&gt;&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;SELECT&lt;/span&gt; * &lt;span class=&quot;keyword&quot;&gt;FROM&lt;/span&gt; TableA &lt;span class=&quot;keyword&quot;&gt;INNER&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;JOIN&lt;/span&gt; TableB &lt;span class=&quot;keyword&quot;&gt;ON&lt;/span&gt; TableA.name=TableB.name;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br&gt;&lt;br&gt;&lt;center&gt;&lt;br&gt;&lt;img src=&quot;http://www.phpddt.com/usr/uploads/2013/08/2918619984.png&quot; alt=&quot;取图中结果,一行有四个属性&quot;&gt;&lt;br&gt;&lt;/center&gt;&lt;br&gt;### left [outer] join&lt;br&gt;以左表为主表，从右表中寻找匹配的记录进行拼接，没有匹配的为null，right join同理。&lt;br&gt;&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;SELECT&lt;/span&gt; * &lt;span class=&quot;keyword&quot;&gt;FROM&lt;/span&gt; TableA &lt;span class=&quot;keyword&quot;&gt;LEFT&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;OUTER&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;JOIN&lt;/span&gt; TableB &lt;span class=&quot;keyword&quot;&gt;ON&lt;/span&gt; TableA.name = TableB.name；&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br&gt;&lt;br&gt;&lt;center&gt;&lt;br&gt;&lt;img src=&quot;http://www.phpddt.com/usr/uploads/2013/08/185395006.png&quot; alt=&quot;此处输入图片的描述&quot;&gt;&lt;br&gt;&lt;/center&gt;

&lt;h3 id=&quot;full-outer-join&quot;&gt;&lt;a href=&quot;#full-outer-join&quot; class=&quot;headerlink&quot; title=&quot;full [outer] join&quot;&gt;&lt;/a&gt;full [outer] join&lt;/h3&gt;&lt;p&gt;产生A和B的并集。对于没有匹配的记录，则会以null做为值。&lt;br&gt;&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;SELECT&lt;/span&gt; * &lt;span class=&quot;keyword&quot;&gt;FROM&lt;/span&gt; TableA &lt;span class=&quot;keyword&quot;&gt;FULL&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;OUTER&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;JOIN&lt;/span&gt; TableB &lt;span class=&quot;keyword&quot;&gt;ON&lt;/span&gt; TableA.name = TableB.name;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;center&gt;&lt;br&gt;&lt;img src=&quot;http://www.phpddt.com/usr/uploads/2013/08/2345513257.png&quot; alt=&quot;此处输入图片的描述&quot;&gt;&lt;br&gt;&lt;/center&gt;

&lt;p&gt;可以通过is NULL将没有匹配的值找出来：&lt;br&gt;&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;SELECT&lt;/span&gt; * &lt;span class=&quot;keyword&quot;&gt;FROM&lt;/span&gt; TableA &lt;span class=&quot;keyword&quot;&gt;FULL&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;OUTER&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;JOIN&lt;/span&gt; TableB &lt;span class=&quot;keyword&quot;&gt;ON&lt;/span&gt; TableA.name = TableB.name&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;WHERE&lt;/span&gt; TableA.id &lt;span class=&quot;keyword&quot;&gt;IS&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;OR&lt;/span&gt; TableB.id &lt;span class=&quot;keyword&quot;&gt;IS&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;union&quot;&gt;&lt;a href=&quot;#union&quot; class=&quot;headerlink&quot; title=&quot;union&quot;&gt;&lt;/a&gt;union&lt;/h3&gt;&lt;p&gt;联合查询&lt;br&gt;&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;# 求并集&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;select * from table1 union select * from table2;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;# 求叠加（记录数是二者的总和）&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;select * from table1 union all select * from table2;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/h3&gt;&lt;center&gt;&lt;br&gt;&lt;img src=&quot;https://www.codeproject.com/KB/database/Visual_SQL_Joins/Visual_SQL_JOINS_V2.png&quot; alt=&quot;此处输入图片的描述&quot;&gt;&lt;br&gt;&lt;/center&gt;

&lt;h2 id=&quot;子查询&quot;&gt;&lt;a href=&quot;#子查询&quot; class=&quot;headerlink&quot; title=&quot;子查询&quot;&gt;&lt;/a&gt;子查询&lt;/h2&gt;&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;select * from table1 where f1=(select * from table2 where f2=&quot;xxx&quot;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;# 等价于&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;select * from table1 where f1 in (select * from table2 where f2=&quot;xxx&quot;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;select * from table1 where exists (select * from table2 f1&amp;gt;=200);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;where字句常用方式&quot;&gt;&lt;a href=&quot;#where字句常用方式&quot; class=&quot;headerlink&quot; title=&quot;where字句常用方式&quot;&gt;&lt;/a&gt;where字句常用方式&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;where age in(13,14);&lt;/li&gt;
&lt;li&gt;where date betweent “21” and “24”;&lt;/li&gt;
&lt;li&gt;where studentName like ‘小明%’；&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;分组函数与having&quot;&gt;&lt;a href=&quot;#分组函数与having&quot; class=&quot;headerlink&quot; title=&quot;分组函数与having&quot;&gt;&lt;/a&gt;分组函数与having&lt;/h3&gt;&lt;p&gt;一般而言，where能用，having也能用，但having效率低，一般只用在where不能用的场合，诸如聚合操作(sum,min,max,avg,count)作用后产生的列，where不能用，现在就只能使用having，如下场景只能用having:&lt;br&gt;&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;select field1,count(*) from table1 having count(*) &amp;gt; 4;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;select filed1,count(*) as num from table1 having num &amp;gt; 4;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;# 当然这样是不可以的&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;select goods_name,goods_number from sw_goods having goods_price &amp;gt; 100 //报错！！！因为前面并没有筛选出goods_price 字段&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&quot;JDBC&quot;&gt;&lt;a href=&quot;#JDBC&quot; class=&quot;headerlink&quot; title=&quot;JDBC&quot;&gt;&lt;/a&gt;JDBC&lt;/h2&gt;&lt;p&gt;JDBC提供了Statement、PreparedStatement 和 CallableStatement三种方式来执行查询语句，其中:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Statement 用于通用查询&lt;/li&gt;
&lt;li&gt;PreparedStatement 用于执行参数化查询&lt;/li&gt;
&lt;li&gt;CallableStatement则是用于存储过程。&lt;/li&gt;
&lt;/ul&gt;
&lt;center&gt;&lt;br&gt;&lt;img src=&quot;http://uploadfiles.nowcoder.com/images/20150611/485624_1434003586300_1.png&quot; alt=&quot;继承关系图&quot;&gt;&lt;br&gt;&lt;/center&gt;

&lt;h1 id=&quot;索引&quot;&gt;&lt;a href=&quot;#索引&quot; class=&quot;headerlink&quot; title=&quot;索引&quot;&gt;&lt;/a&gt;索引&lt;/h1&gt;&lt;h2 id=&quot;先快速看几篇文章&quot;&gt;&lt;a href=&quot;#先快速看几篇文章&quot; class=&quot;headerlink&quot; title=&quot;先快速看几篇文章&quot;&gt;&lt;/a&gt;先快速看几篇文章&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/cy163/archive/2008/10/27/1320798.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.cnblogs.com/cy163/archive/2008/10/27/1320798.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Mysql有BTree索引和Hash索引，而oracle除了这两种选择，还有Bitmap位图索引。&lt;/p&gt;
&lt;h2 id=&quot;索引的作用&quot;&gt;&lt;a href=&quot;#索引的作用&quot; class=&quot;headerlink&quot; title=&quot;索引的作用&quot;&gt;&lt;/a&gt;索引的作用&lt;/h2&gt;&lt;p&gt;索引用于快速找出在某个列中有一特定值的行。不使用索引，MySQL必须从第1条记录开始然后读完整个表直到找出相关的行，还需要考虑每次读入数据页的IO开销。&lt;br&gt;而如果采取索引，则可以根据索引指向的页以及记录在页中的位置，迅速地读取目标页进而获取目标记录。&lt;/p&gt;
&lt;h2 id=&quot;使用索引需要注意&quot;&gt;&lt;a href=&quot;#使用索引需要注意&quot; class=&quot;headerlink&quot; title=&quot;使用索引需要注意&quot;&gt;&lt;/a&gt;使用索引需要注意&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;只对WHERE和ORDER BY需要查询的字段设置索引，避免无意义的硬盘开销；&lt;/li&gt;
&lt;li&gt;组合索引支持前缀索引；&lt;/li&gt;
&lt;li&gt;更新表的时候，如增删记录，MySQL会自动更新索引，保持树的平衡；因此更多的索引意味着更多的维护成本;&lt;/li&gt;
&lt;li&gt;可通过explain语句查看SQL语句的分析结果;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;什么情况下设置了索引但无法使用&quot;&gt;&lt;a href=&quot;#什么情况下设置了索引但无法使用&quot; class=&quot;headerlink&quot; title=&quot;什么情况下设置了索引但无法使用&quot;&gt;&lt;/a&gt;什么情况下设置了索引但无法使用&lt;/h2&gt;&lt;p&gt;① 以“%”开头的LIKE语句，模糊匹配,如:&lt;br&gt;&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;like %keyword    #索引失效，使用全表扫描。但可以通过翻转函数+like前模糊查询+建立翻转函数索引=走翻转函数索引，不走全表扫描。&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;like keyword%    #索引有效&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;like %keyword%   #索引失效，也无法使用反向索引。&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;② OR语句前后没有同时使用索引，需要将where语句的字段也加上order，如：&lt;br&gt;假设已经建立以下索引：&lt;br&gt;&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;CREATE&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;INDEX&lt;/span&gt; mytable_categoryid_userid_adddate&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;ON&lt;/span&gt; mytable (category_id,user_id,adddate);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;进行查找时应：&lt;br&gt;&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;SELECT&lt;/span&gt; * &lt;span class=&quot;keyword&quot;&gt;FROM&lt;/span&gt; mytable&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;WHERE&lt;/span&gt; category_id=&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;AND&lt;/span&gt; user_id=&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;　　&lt;span class=&quot;keyword&quot;&gt;ORDER&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;BY&lt;/span&gt; category_id &lt;span class=&quot;keyword&quot;&gt;DESC&lt;/span&gt;,user_id &lt;span class=&quot;keyword&quot;&gt;DESC&lt;/span&gt;,adddate &lt;span class=&quot;keyword&quot;&gt;DESC&lt;/span&gt;;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;③ 数据类型出现隐式转化（如varchar不加单引号的话可能会自动转换为int型）；&lt;br&gt;&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;SELECT&lt;/span&gt; * &lt;span class=&quot;keyword&quot;&gt;FROM&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;`mytable`&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;WHERE&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;`a`&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&#39;12345&#39;&lt;/span&gt; #正确版本&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;SELECT&lt;/span&gt; * &lt;span class=&quot;keyword&quot;&gt;FROM&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;`mytable`&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;WHERE&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;`a`&lt;/span&gt;=&lt;span class=&quot;number&quot;&gt;12345&lt;/span&gt; #错误版本，虽可查到，但变慢&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&quot;索引的一种分法&quot;&gt;&lt;a href=&quot;#索引的一种分法&quot; class=&quot;headerlink&quot; title=&quot;索引的一种分法&quot;&gt;&lt;/a&gt;索引的一种分法&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;index —-普通的索引,数据可以重复&lt;/li&gt;
&lt;li&gt;fulltext—-全文索引，用来对大表的文本域(char，varchar，text)进行索引。语法和普通索引一样。&lt;/li&gt;
&lt;li&gt;unique —-唯一索引,唯一索引,要求所有记录都唯一&lt;/li&gt;
&lt;li&gt;primary key —-主键索引,也就是在唯一索引的基础上相应的列必须为主键&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;事务&quot;&gt;&lt;a href=&quot;#事务&quot; class=&quot;headerlink&quot; title=&quot;事务&quot;&gt;&lt;/a&gt;事务&lt;/h1&gt;&lt;h2 id=&quot;数据库事务的四大特性-简称ACID&quot;&gt;&lt;a href=&quot;#数据库事务的四大特性-简称ACID&quot; class=&quot;headerlink&quot; title=&quot;数据库事务的四大特性(简称ACID)&quot;&gt;&lt;/a&gt;数据库事务的四大特性(简称ACID)&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;原子性(Atomicity)&lt;br&gt;事务的原子性指的是，事务中包含的程序作为数据库的逻辑工作单位，它所做的对数据修改操作要么全部执行，要么完全不执行。这种特性称为原子性。&lt;br&gt;例如银行取款事务分为2个步骤(1)存折减款(2)提取现金。不可能存折减款，却没有提取现金。2个步骤必须同时完成或者都不完成。&lt;/li&gt;
&lt;li&gt;一致性(Consistency)&lt;br&gt;事务的一致性指的是在一个事务执行之前和执行之后数据库都必须处于一致性状态。这种特性称为事务的一致性。假如数据库的状态满足所有的完整性约束，就说该数据库是一致的。&lt;br&gt;例如完整性约束a+b=10，一个事务改变了a，那么b也应随之改变。&lt;/li&gt;
&lt;li&gt;分离性(亦称独立性Isolation)&lt;br&gt;分离性指并发的事务是相互隔离的。即一个事务内部的操作及正在操作的数据必须封锁起来，不被其它企图进行修改的事务看到。假如并发交叉执行的事务没有任何控制，操纵相同的共享对象的多个并发事务的执行可能引起异常情况。&lt;/li&gt;
&lt;li&gt;持久性(Durability)&lt;br&gt;持久性意味着当系统或介质发生故障时，确保已提交事务的更新不能丢失。即一旦一个事务提交，DBMS保证它对数据库中数据的改变应该是永久性的，即对已提交事务的更新能恢复。持久性通过数据库备份和恢复来保证。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;解决高并发&quot;&gt;&lt;a href=&quot;#解决高并发&quot; class=&quot;headerlink&quot; title=&quot;解决高并发&quot;&gt;&lt;/a&gt;解决高并发&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;分库，分表，分布式，增加二级缓存等；&lt;ul&gt;
&lt;li&gt;水平分库分表，由单点分布到多点数据库中，从而降低单点数据库压力。&lt;/li&gt;
&lt;li&gt;读写分离策略：极大限度提高应用中Read数据的速度和并发量。无法解决高写入压力。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;解决高并发锁的争用&lt;ul&gt;
&lt;li&gt;行锁，但似乎高并发情况下效率会下降较多；&lt;/li&gt;
&lt;li&gt;换用Redis，有个watch命令（乐观锁），监听key是否被改变，而一般真实环境下Redis又是单进程的，command是one by one的。但是watch用在分布式操作上却是有用的。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;设计&quot;&gt;&lt;a href=&quot;#设计&quot; class=&quot;headerlink&quot; title=&quot;设计&quot;&gt;&lt;/a&gt;设计&lt;/h1&gt;&lt;h2 id=&quot;三大范式&quot;&gt;&lt;a href=&quot;#三大范式&quot; class=&quot;headerlink&quot; title=&quot;三大范式&quot;&gt;&lt;/a&gt;三大范式&lt;/h2&gt;&lt;p&gt;范式越高，数据冗余越少，但是增加查询复杂度，表链接时效率更低。范式低，数据冗余高，但是查询会更快。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一范式，确保属性的原子性，如“地址”属性应该再细分为国家，省，市，区等；&lt;/li&gt;
&lt;li&gt;第二范式，如果一个关系满足第一范式,并且除了主键以外的其它列,都依赖于该主键,则满足第二范式；&lt;/li&gt;
&lt;li&gt;第三范式，表中每列都与主键直接相关，如订单记录中，虽说顾客编号和顾客名称都与主键（订单编号）相关，满足第二范式，但顾客名称不是直接相关；&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Basis" scheme="http://enjoyhot.github.io/categories/Basis/"/>
    
    
      <category term="Basis" scheme="http://enjoyhot.github.io/tags/Basis/"/>
    
  </entry>
  
  <entry>
    <title>或明</title>
    <link href="http://enjoyhot.github.io/2016/08/01/or-know/"/>
    <id>http://enjoyhot.github.io/2016/08/01/or-know/</id>
    <published>2016-08-01T13:23:50.000Z</published>
    <updated>2017-04-16T14:48:30.662Z</updated>
    
    <content type="html">&lt;p&gt;时值8月，离毕业更近了。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;br&gt;在入学时就开始算计留在学校还有多少时间，毕竟，在学校的日子将会一去不复返，总得做些有意义的事情，弥补一些遗憾或空缺。&lt;/p&gt;
&lt;p&gt;依托客观存在的24小时，寻找忙碌的理由，为未来打算，是多年来的行事法则。希望每天过得充实而又收获，但往往做到一半（呵呵），这又是另外一种境遇。有个计划，遵守计划，能完成78成，就很成功。&lt;/p&gt;
&lt;p&gt;懂得舍弃，生活不乏单调，或许，光明只有一步之遥。附上最近脑海里浮现的歌。&lt;/p&gt;
&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;330&quot; height=&quot;86&quot; src=&quot;http://music.163.com/outchain/player?type=2&amp;id=33248189&amp;auto=0&amp;height=66&quot;&gt;&lt;/iframe&gt;

</content>
    
    <summary type="html">
    
      &lt;p&gt;时值8月，离毕业更近了。&lt;br&gt;
    
    </summary>
    
      <category term="Life" scheme="http://enjoyhot.github.io/categories/Life/"/>
    
    
      <category term="Life" scheme="http://enjoyhot.github.io/tags/Life/"/>
    
  </entry>
  
  <entry>
    <title>ensemble-stacking</title>
    <link href="http://enjoyhot.github.io/2016/05/08/ensemble-stacking/"/>
    <id>http://enjoyhot.github.io/2016/05/08/ensemble-stacking/</id>
    <published>2016-05-08T09:04:30.000Z</published>
    <updated>2017-04-16T14:48:30.634Z</updated>
    
    <content type="html">&lt;h1 id=&quot;测试blog&quot;&gt;&lt;a href=&quot;#测试blog&quot; class=&quot;headerlink&quot; title=&quot;测试blog&quot;&gt;&lt;/a&gt;测试blog&lt;/h1&gt;&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;相比 Blending，Stacking 能更好地利用训练数据。以 5-Fold Stacking 为例，它的基本原理如图所示：&lt;br&gt;&lt;img src=&quot;http://img.blog.csdn.net/20160708170152466&quot; alt=&quot;stacking processing&quot;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;整个过程很像 Cross Validation。&lt;br&gt;对于一个model，首先将训练数据分为 5 份，接下来一共5个迭代，每次迭代时，将 4 份数据作为 Training Set 对每个 Base Model 进行训练，然后在剩下一份 Hold-out Set 上进行预测。那么一个model训练最终将合成一个完整对于原始训练样本的预测单列矩阵。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;同时也要将其在测试数据上的预测保存下来。这样，每个 Base Model 在每次迭代时会对训练数据的其中 1 份做出预测，对测试数据的全部做出预测。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;多个model迭代都完成以后我们就获得了一个 #训练数据行数 x #Base Model 数量 的矩阵，这个矩阵接下来就作为第二层的 Model 的训练数据。当第二层的 Model 训练完以后，将之前保存的 Base Model 对测试数据的预测（因为每个 Base Model 被训练了 5 次，对测试数据的全体做了 5 次预测，所以对这 5 次求一个平均值形成一列，多个model形成多列，从而得到一个形状与第二层训练数据相同的矩阵）拿出来让它进行预测，就得到最后的输出。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;总的来说，Stacking 方法比任何单一模型的效果都要好，而且不仅成功应用在了监督式学习中，也成功应用在了非监督式(概率密度估计)学习中。甚至应用于估计bagging模型的错误率。据论文Feature-Weighted Linear Stacking(Sill, J. and Takacs, G. and Mackey L. and Lin D., 2009, arXiv:0911.0460)而言，Stacking比Bayesian Model Averaging表现要更好！此外在Kaggle上，很多比赛多是通过Stacking获取优秀的结果！&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;测试blog&quot;&gt;&lt;a href=&quot;#测试blog&quot; class=&quot;headerlink&quot; title=&quot;测试blog&quot;&gt;&lt;/a&gt;测试blog&lt;/h1&gt;&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;相比 Blending，Stacking 能更好地利用训练数据。以 5-Fold Stacking 为例，它的基本原理如图所示：&lt;br&gt;&lt;img src=&quot;http://img.blog.csdn.net/20160708170152466&quot; alt=&quot;stacking processing&quot;&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Machine Learning" scheme="http://enjoyhot.github.io/categories/Machine-Learning/"/>
    
    
      <category term="Machine Learning" scheme="http://enjoyhot.github.io/tags/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title>MS-document-online-preview</title>
    <link href="http://enjoyhot.github.io/2016/03/12/MS-document-online-preview/"/>
    <id>http://enjoyhot.github.io/2016/03/12/MS-document-online-preview/</id>
    <published>2016-03-12T10:41:00.000Z</published>
    <updated>2017-04-16T14:48:30.658Z</updated>
    
    <content type="html">&lt;h1 id=&quot;doc-xls-ppt-pdf实现浏览器在线预览小记&quot;&gt;&lt;a href=&quot;#doc-xls-ppt-pdf实现浏览器在线预览小记&quot; class=&quot;headerlink&quot; title=&quot;doc,xls,ppt,pdf实现浏览器在线预览小记&quot;&gt;&lt;/a&gt;doc,xls,ppt,pdf实现浏览器在线预览小记&lt;/h1&gt;&lt;hr&gt;
&lt;h2 id=&quot;一般有两种方式&quot;&gt;&lt;a href=&quot;#一般有两种方式&quot; class=&quot;headerlink&quot; title=&quot;一般有两种方式&quot;&gt;&lt;/a&gt;一般有两种方式&lt;/h2&gt;&lt;h3 id=&quot;方式一：&quot;&gt;&lt;a href=&quot;#方式一：&quot; class=&quot;headerlink&quot; title=&quot;方式一：&quot;&gt;&lt;/a&gt;方式一：&lt;/h3&gt;&lt;h3 id=&quot;步骤&quot;&gt;&lt;a href=&quot;#步骤&quot; class=&quot;headerlink&quot; title=&quot;步骤&quot;&gt;&lt;/a&gt;步骤&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;文档（PDF，Word，PPT等）–&amp;gt;PDF–&amp;gt;浏览器加载pdf插件在线浏览&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;转换pdf的软件：&quot;&gt;&lt;a href=&quot;#转换pdf的软件：&quot; class=&quot;headerlink&quot; title=&quot;转换pdf的软件：&quot;&gt;&lt;/a&gt;转换pdf的软件：&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;office:&lt;/strong&gt;调用com接口，从而调用软件运行转换程序。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Openoffice：&lt;/strong&gt; 目前隶属于Apache，从Openoffice.org沿袭而来。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;LibreOffice：&lt;/strong&gt; OpenOffice.org的分支,第一个正式版。 为3.3，对格式和字体的支持、对插件扩展与Openoffice有所侧重。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;目前网络上各种转换方法，归根到底大多用到前两者，只是做了不同的代码封装。特别提一下，&lt;strong&gt;jacob.jar&lt;/strong&gt;实现Word转换成PDF，一般用于Java，本质上也还是调用office。&lt;/p&gt;
&lt;h3 id=&quot;doc2pdf软件优缺点&quot;&gt;&lt;a href=&quot;#doc2pdf软件优缺点&quot; class=&quot;headerlink&quot; title=&quot;doc2pdf软件优缺点&quot;&gt;&lt;/a&gt;doc2pdf软件优缺点&lt;/h3&gt;&lt;p&gt;（针对pythoner来说）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;office:&lt;/strong&gt;自己安装com接口插件，调用软件运行转换程序,软件过于庞大，对于性能不太好的机器有时可能会崩溃。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Openoffice：&lt;/strong&gt; 自带调用com接口API，python2.7.6内核，但是对于doc,docx格式兼容不好，转换格式不兼容的字体或者表格排版就呵呵了。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;LibreOffice：&lt;/strong&gt;自带调用com接口API，python3.3内核，暂时找不到2.7的，对doc,docx兼容较好。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;目前自三种软件调用的脚步程序一抓一大把，都大致差不多，要注意的地方是，Dispatch, constants参数的慎重选择，如constants.wdXXX有时获取不靠谱，需要自己指定值。&lt;/p&gt;
&lt;h3 id=&quot;浏览器pdf插件&quot;&gt;&lt;a href=&quot;#浏览器pdf插件&quot; class=&quot;headerlink&quot; title=&quot;浏览器pdf插件&quot;&gt;&lt;/a&gt;浏览器pdf插件&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;下载自动安装有pdf插件的浏览器，目前chrome、搜狗、火狐都支持。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;下载各种pdf阅读器进行关联，浏览器代理设置允许加载pdf阅读插件。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;加载js插件，需要浏览器支持才行，不然还是会变成下载。&lt;a href=&quot;http://www.cnblogs.com/58top/archive/2012/11/26/a-list-of-jquery-pdf-viewers-available-at-the-moment.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.cnblogs.com/58top/archive/2012/11/26/a-list-of-jquery-pdf-viewers-available-at-the-moment.html&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;试过：PDFObject，jQuery Media Plugin&lt;/p&gt;
&lt;h3 id=&quot;方式二：&quot;&gt;&lt;a href=&quot;#方式二：&quot; class=&quot;headerlink&quot; title=&quot;方式二：&quot;&gt;&lt;/a&gt;方式二：&lt;/h3&gt;&lt;h3 id=&quot;步骤-1&quot;&gt;&lt;a href=&quot;#步骤-1&quot; class=&quot;headerlink&quot; title=&quot;步骤&quot;&gt;&lt;/a&gt;步骤&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;文档（PDF，Word，PPT等）–&amp;gt;PDF–&amp;gt;转换为SWF–&amp;gt; 使用FlexPaper在线浏览&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;软件介绍&quot;&gt;&lt;a href=&quot;#软件介绍&quot; class=&quot;headerlink&quot; title=&quot;软件介绍&quot;&gt;&lt;/a&gt;软件介绍&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Openoffice：&lt;/strong&gt; word转pdf，同上分析。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;SWFTools：&lt;/strong&gt;将PDF转换为swf。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;FlexPaper：&lt;/strong&gt;一个开源轻量级的在浏览器上显示各种文档的组件，已经嵌入了flash播放器。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;目前的优缺点&quot;&gt;&lt;a href=&quot;#目前的优缺点&quot; class=&quot;headerlink&quot; title=&quot;目前的优缺点&quot;&gt;&lt;/a&gt;目前的优缺点&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;转换成功后crash的可能应该比直接用pdf低，保密性也较好，防复制防保存的功能可以进一步开发。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;兼容性较好，无需担心浏览器插件问题。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;处理流程多，对系统负担加大。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;另外:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;转换为html非常不靠谱。&lt;br&gt;转换为html非常不靠谱。&lt;br&gt;转换为html非常不靠谱。&lt;/p&gt;
&lt;/blockquote&gt;
</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;doc-xls-ppt-pdf实现浏览器在线预览小记&quot;&gt;&lt;a href=&quot;#doc-xls-ppt-pdf实现浏览器在线预览小记&quot; class=&quot;headerlink&quot; title=&quot;doc,xls,ppt,pdf实现浏览器在线预览小记&quot;&gt;&lt;/a&gt;doc,xls,ppt,pdf实现浏览器在线预览小记&lt;/h1&gt;&lt;hr&gt;
&lt;h2 id=&quot;一般有两种方式&quot;&gt;&lt;a href=&quot;#一般有两种方式&quot; class=&quot;headerlink&quot; title=&quot;一般有两种方式&quot;&gt;&lt;/a&gt;一般有两种方式&lt;/h2&gt;&lt;h3 id=&quot;方式一：&quot;&gt;&lt;a href=&quot;#方式一：&quot; class=&quot;headerlink&quot; title=&quot;方式一：&quot;&gt;&lt;/a&gt;方式一：&lt;/h3&gt;&lt;h3 id=&quot;步骤&quot;&gt;&lt;a href=&quot;#步骤&quot; class=&quot;headerlink&quot; title=&quot;步骤&quot;&gt;&lt;/a&gt;步骤&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;文档（PDF，Word，PPT等）–&amp;gt;PDF–&amp;gt;浏览器加载pdf插件在线浏览&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;转换pdf的软件：&quot;&gt;&lt;a href=&quot;#转换pdf的软件：&quot; class=&quot;headerlink&quot; title=&quot;转换pdf的软件：&quot;&gt;&lt;/a&gt;转换pdf的软件：&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;office:&lt;/strong&gt;调用com接口，从而调用软件运行转换程序。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Openoffice：&lt;/strong&gt; 目前隶属于Apache，从Openoffice.org沿袭而来。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;LibreOffice：&lt;/strong&gt; OpenOffice.org的分支,第一个正式版。 为3.3，对格式和字体的支持、对插件扩展与Openoffice有所侧重。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Python" scheme="http://enjoyhot.github.io/categories/Python/"/>
    
    
      <category term="Python" scheme="http://enjoyhot.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Git 协作纪要</title>
    <link href="http://enjoyhot.github.io/2015/12/12/git-notes/"/>
    <id>http://enjoyhot.github.io/2015/12/12/git-notes/</id>
    <published>2015-12-12T10:41:00.000Z</published>
    <updated>2017-04-16T14:48:30.634Z</updated>
    
    <content type="html">&lt;h3 id=&quot;一、常用开发模式&quot;&gt;&lt;a href=&quot;#一、常用开发模式&quot; class=&quot;headerlink&quot; title=&quot;一、常用开发模式&quot;&gt;&lt;/a&gt;一、常用开发模式&lt;/h3&gt;&lt;p&gt;先看一张图&lt;br&gt;&lt;img src=&quot;http://img.blog.csdn.net/20151212204330712&quot; alt=&quot;这里写图片描述&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;br&gt;1、少用pull或不用pull；&lt;br&gt;2、本地的多个分支，如果不是用命令行的话，对文件修改是对所有分支内容修改。&lt;/p&gt;
&lt;p&gt;git clone -&amp;gt; 修改 -&amp;gt;&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;以下分情况讨论：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、当你采用本地commit再远程push的连贯方式&lt;/p&gt;
&lt;p&gt;(将远程master获取到本地仓库假设为tmp，为后期查看log或merge等)&lt;br&gt;&lt;code&gt;git fetch origin master&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;-&amp;gt;&lt;br&gt;(查看本地master和刚才fetch的origin/master直接2条差异，-p查看详细)&lt;br&gt;&lt;code&gt;git log master origin/master -n&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20151212204450639&quot; alt=&quot;这里写图片描述&quot;&gt;&lt;/p&gt;
&lt;p&gt;-&amp;gt;&lt;br&gt;(合并origin/master到本地的master，这一步往往比较揪心，可能有冲突，解决后需：&lt;br&gt;&lt;code&gt;git add xx
git commit xx&lt;/code&gt;&lt;br&gt;)&lt;/p&gt;
&lt;p&gt;当别人比你先提交时，会出现这个错误：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20151212204609760&quot; alt=&quot;这里写图片描述&quot;&gt;&lt;/p&gt;
&lt;p&gt;解决：&lt;br&gt;&lt;code&gt;git stash
git pull
git stash pop&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20151212204657548&quot; alt=&quot;这里写图片描述&quot;&gt;&lt;br&gt;(一个个文件查看改动，无问题则add，然后commit，然后git diff –stat看看还有多少)&lt;br&gt;&lt;code&gt;git diff -w app/auth/views.py&lt;/code&gt;&lt;br&gt;(add 一个少一个)&lt;br&gt;&lt;code&gt;git diff --stat&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20151212204729887&quot; alt=&quot;这里写图片描述&quot;&gt;&lt;/p&gt;
&lt;p&gt;(记得commit)&lt;br&gt;&lt;code&gt;git merge origin/master&lt;/code&gt;&lt;br&gt;-&amp;gt;&lt;br&gt;(提交到远程origin/master)&lt;br&gt;&lt;code&gt;git push origin/master&lt;/code&gt;&lt;br&gt;2、当你采用本地commit，过一段较长时间再远程push的方式&lt;/p&gt;
&lt;p&gt;-&amp;gt;&lt;br&gt;&lt;code&gt;git fetch origin master&lt;/code&gt;&lt;br&gt;-&amp;gt;&lt;br&gt;&lt;code&gt;git merge origin/master&lt;/code&gt;&lt;br&gt;这时那些不一致的就会发生冲突&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20151212204824478&quot; alt=&quot;这里写图片描述&quot;&gt;&lt;/p&gt;
&lt;p&gt;修改文件内容的冲突后，这时你通过git add和git commit可解决&lt;/p&gt;
&lt;p&gt;-&amp;gt;&lt;br&gt;&lt;code&gt;git push origin/master&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;3、tips&lt;/p&gt;
&lt;p&gt;当查看别人甚至做了一些调试，要撤销pull以来（或者说commit之后）的操作，则用git checkout&lt;br&gt;&lt;code&gt;git checkout -- filename&lt;/code&gt;&lt;br&gt;用暂存区中filename文件来覆盖工作区中的filename文件(慎用【git checkout . 】表示所有)。&lt;/p&gt;
&lt;h3 id=&quot;二、改进工作流&quot;&gt;&lt;a href=&quot;#二、改进工作流&quot; class=&quot;headerlink&quot; title=&quot;二、改进工作流&quot;&gt;&lt;/a&gt;二、改进工作流&lt;/h3&gt;&lt;p&gt;习惯了merge之后，对git的工作流维护也是相当重要，主要是方便差错，对于各个commit的整理也是有益的。&lt;br&gt;&lt;strong&gt;1、git rebase&lt;/strong&gt;&lt;br&gt;重新定义(re)起点(base),整合工作流。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;merge&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;git checkout mywork
git merge origin&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;会生成如下的树（借用网上的图）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20160411171504432&quot; alt=&quot;这里写图片描述&quot;&gt;&lt;/p&gt;
&lt;p&gt;这样C5、C6都属于工作流的一部分，当你回退到C5时就没应用到C4的修改，需要再进行操作。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;如果用rebase：&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;git checkout mywork
git rebase origin&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;把orgin的最新commit C4 作为当前分支mywork的基础，则生成的树图示如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20160411171935979&quot; alt=&quot;这里写图片描述&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;配合远程&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;git pull --rebase origin master&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;–rebase选项告诉Git，在同步了中央仓库的修改之后，将Mary所有的提交移到master分支的顶端。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;假如冲突&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;git add .
git rebase --continue&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注：rebase的操作相对于merge操作，因为发生了时间跳跃，当发生冲突时会比较混乱（虽然 我还没遇到）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;三、分支&quot;&gt;&lt;a href=&quot;#三、分支&quot; class=&quot;headerlink&quot; title=&quot;三、分支&quot;&gt;&lt;/a&gt;三、分支&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;1、新建本地分支&lt;/strong&gt;&lt;br&gt;&lt;code&gt;git branch gujw&lt;/code&gt;&lt;br&gt;&lt;strong&gt;2、查看本地分支&lt;/strong&gt;&lt;br&gt;&lt;code&gt;git branch&lt;/code&gt;&lt;br&gt;&lt;strong&gt;3、切换本地分支&lt;/strong&gt;&lt;br&gt;&lt;code&gt;git checkout gujw&lt;/code&gt;&lt;br&gt;示例：&lt;br&gt;&lt;img src=&quot;http://img.blog.csdn.net/20151212205233998&quot; alt=&quot;这里写图片描述&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4、查看远程分支&lt;/strong&gt;&lt;br&gt;&lt;code&gt;git branch -a&lt;/code&gt;&lt;br&gt;示例：&lt;br&gt;&lt;img src=&quot;http://img.blog.csdn.net/20151212205253447&quot; alt=&quot;这里写图片描述&quot;&gt;&lt;/p&gt;
&lt;p&gt;###三、仓库移动&lt;/p&gt;
&lt;p&gt;当远程仓库域名什么的发生变化，应该是比较常见的情况。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、查看当前本地仓库链接到的远程仓库&lt;/strong&gt;&lt;br&gt;&lt;code&gt;git remote -v&lt;/code&gt;&lt;br&gt;&lt;strong&gt;2、按照格式更改url即可&lt;/strong&gt;&lt;br&gt;&lt;code&gt;git remote set-url XXXXX&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;###四、撤销操作&lt;/p&gt;
&lt;p&gt;如果你推送到remote的commit没有被其他人pull过，那么你可以使用&lt;br&gt;&lt;code&gt;git reset --hard &amp;lt;commit-hash&amp;gt;  //可以用客户端Amend代替
git push -f origin master&lt;/code&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;…&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、常用开发模式&quot;&gt;&lt;a href=&quot;#一、常用开发模式&quot; class=&quot;headerlink&quot; title=&quot;一、常用开发模式&quot;&gt;&lt;/a&gt;一、常用开发模式&lt;/h3&gt;&lt;p&gt;先看一张图&lt;br&gt;&lt;img src=&quot;http://img.blog.csdn.net/20151212204330712&quot; alt=&quot;这里写图片描述&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;br&gt;1、少用pull或不用pull；&lt;br&gt;2、本地的多个分支，如果不是用命令行的话，对文件修改是对所有分支内容修改。&lt;/p&gt;
&lt;p&gt;git clone -&amp;gt; 修改 -&amp;gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Git" scheme="http://enjoyhot.github.io/categories/Git/"/>
    
    
      <category term="Git" scheme="http://enjoyhot.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>通过欢迎度对网页排名</title>
    <link href="http://enjoyhot.github.io/2015/05/03/%E9%80%9A%E8%BF%87%E6%AC%A2%E8%BF%8E%E5%BA%A6%E5%AF%B9%E7%BD%91%E9%A1%B5%E6%8E%92%E5%90%8D/"/>
    <id>http://enjoyhot.github.io/2015/05/03/通过欢迎度对网页排名/</id>
    <published>2015-05-03T07:30:50.000Z</published>
    <updated>2017-04-16T14:48:30.690Z</updated>
    
    <content type="html">&lt;p&gt;声明：由于此次第一次使用动态加载的表达式，hexo对LaTex支持可能不太好，因此这里有些公式显示奇奇怪怪，排版比较好一点的参考csdn:&lt;a href=&quot;http://blog.csdn.net/gugugujiawei/article/details/45459089&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;博客链接&lt;/a&gt;,下次就直接上图片算了。免得这边不兼容。&lt;/p&gt;
&lt;h1 id=&quot;一、欢迎度历史&quot;&gt;&lt;a href=&quot;#一、欢迎度历史&quot; class=&quot;headerlink&quot; title=&quot;一、欢迎度历史&quot;&gt;&lt;/a&gt;一、欢迎度历史&lt;/h1&gt;&lt;p&gt;1998年 Jon Kleinberg致力于HITS的万维网搜索引擎项目，其中的算法使用了万维网的超链接结构来改进搜索引擎所得的结果。&lt;/p&gt;
&lt;p&gt;同时，在离他很近的斯坦福大学里，两名博士生正在从事一项名为PageRank的类似项目，分别是Sergey Brin和Larry Page。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;br&gt;这两个模型之间的联系令人吃惊。然而，Jon并未试图将HITS发展成为一家公司，不过后来企业家们却试着去做了，并因此而赋予了HITS那迟到的商业成功。搜索引擎Teoma的技术基础就是HITS算法的一个扩展。&lt;/p&gt;
&lt;p&gt;在介绍之前，我们先将万维网的超链接结构形成一个巨大的有向图，有向链接分为岀链和入链。&lt;/p&gt;
&lt;p&gt;网络有向图&lt;br&gt;&lt;img src=&quot;http://img.blog.csdn.net/20150503151630774&quot; alt=&quot;网络有向图&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;1-1-PageRank&quot;&gt;&lt;a href=&quot;#1-1-PageRank&quot; class=&quot;headerlink&quot; title=&quot;1.1 PageRank&quot;&gt;&lt;/a&gt;1.1 PageRank&lt;/h2&gt;&lt;p&gt;Pagerank的论点是，如果一个网页被其他重要的页面所指向，那它就是重要的。值得注意的是，推荐者的地位对推荐的作用是有一定联系的，也与推荐者推荐的总数有所关联。&lt;/p&gt;
&lt;h2 id=&quot;1-2-HITS&quot;&gt;&lt;a href=&quot;#1-2-HITS&quot; class=&quot;headerlink&quot; title=&quot;1.2 HITS&quot;&gt;&lt;/a&gt;1.2 HITS&lt;/h2&gt;&lt;p&gt;HITS定义了枢纽（hub）和权威（authority），这是网页的属性，当然一个网页可以两者都是。&lt;br&gt;&lt;img src=&quot;http://img.blog.csdn.net/20150503151736749&quot; alt=&quot;这里写图片描述&quot;&gt;&lt;br&gt;论点是，如果一个页面指向好的权威网页，那它就是一个好的枢纽网页（从而配上一个高的枢纽评分）；而如果一个网页被好的枢纽网页所指向，那它就是一个好的权威网页。&lt;/p&gt;
&lt;h2 id=&quot;1-3-查询相关性&quot;&gt;&lt;a href=&quot;#1-3-查询相关性&quot; class=&quot;headerlink&quot; title=&quot;1.3 查询相关性&quot;&gt;&lt;/a&gt;1.3 查询相关性&lt;/h2&gt;&lt;p&gt;如果每个页面的欢迎度评分是离线确定的，并且对于无论哪个查询而言（直至下次更新前）均保持恒定，则排名称为查询无关的&lt;br&gt;PageRank是查询无关的，HITS的原始版本是查询相关的。它们二者都可以修改为相反的那个类型。&lt;/p&gt;
&lt;h1 id=&quot;二、谷歌的PageRank数学&quot;&gt;&lt;a href=&quot;#二、谷歌的PageRank数学&quot; class=&quot;headerlink&quot; title=&quot;二、谷歌的PageRank数学&quot;&gt;&lt;/a&gt;二、谷歌的PageRank数学&lt;/h1&gt;&lt;h2 id=&quot;2-1-求和公式&quot;&gt;&lt;a href=&quot;#2-1-求和公式&quot; class=&quot;headerlink&quot; title=&quot;2.1 求和公式&quot;&gt;&lt;/a&gt;2.1 求和公式&lt;/h2&gt;&lt;p&gt;某个页面的Pi的PageRank记为r(Pi)，它是所有指向Pi的页面的PageRank之和。&lt;br&gt;$$ r(P&lt;em&gt;i) =\sum&lt;/em&gt;{P&lt;em&gt;j \in B&lt;/em&gt;{P_i}} \dfrac{r(P_j)}{|P&lt;em&gt;j|} $$&lt;br&gt;Bpi为指向Pi的页面集合，|Pj|是由Pj发出的岀链数量。&lt;br&gt;通过迭代的方式，解决通过未知页面的PageRank值得出另外未知页面的PageRank值。为了定义这一迭代过程，我们引入更多的记号，令$r&lt;/em&gt;{k+1}(P&lt;em&gt;i)$表示为页面Pi在第k+1次循环时的PageRank，则&lt;br&gt;$$ r&lt;/em&gt;{k+1}(P&lt;em&gt;i) =\sum&lt;/em&gt;{P&lt;em&gt;j \in B&lt;/em&gt;{P_i}} \dfrac{r_k(P_j)}{|P&lt;em&gt;j|}(1) $$&lt;br&gt;将所有页面Pi均具有$r&lt;/em&gt;{0}(P_i) =1/n$开始，并一直重复下去，直至收敛到稳定值。&lt;/p&gt;
&lt;h2 id=&quot;2-2求和方程的矩阵表示&quot;&gt;&lt;a href=&quot;#2-2求和方程的矩阵表示&quot; class=&quot;headerlink&quot; title=&quot;2.2求和方程的矩阵表示&quot;&gt;&lt;/a&gt;2.2求和方程的矩阵表示&lt;/h2&gt;&lt;p&gt;打个比方，以下面这个图为例&lt;br&gt;&lt;img src=&quot;http://img.blog.csdn.net/20150503151630774&quot; alt=&quot;网络有向图&quot;&gt;&lt;br&gt;我们引入一个n x n阶的矩阵H和一个1 x n阶的行向量$\pi^T$。矩阵H是一个行归一化超链接矩阵，则上图相应H为：&lt;br&gt;$$ H= \begin{matrix} \pmatrix{ 0 &amp;amp; 1/2 &amp;amp; 1/2 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 \ 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 \ 1/3 &amp;amp; 1/3 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1/3 &amp;amp; 0 \ 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1/2 &amp;amp; 1/2 \ 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1/2 &amp;amp; 0 &amp;amp; 1/2 \ 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1 &amp;amp; 0 &amp;amp; 0 \} \end{matrix} $$&lt;br&gt;向引入行向量$\pi^{(k)T}$，它表示在第k次循环时的PageRank向量。则(1)式可表示为：&lt;br&gt;$$\pi^{(k+1)T}=\pi^{(k)T}H (2)$$&lt;br&gt;从这个H矩阵可以看出一些端倪，书中总结出4个，我觉得关键在于在计算中通过矩阵计算降低复杂度，这在现实中是个稀疏矩阵，复杂度对于理论来说由平方降为1次。&lt;/p&gt;
&lt;h2 id=&quot;2-3迭代过程问题&quot;&gt;&lt;a href=&quot;#2-3迭代过程问题&quot; class=&quot;headerlink&quot; title=&quot;2.3迭代过程问题&quot;&gt;&lt;/a&gt;2.3迭代过程问题&lt;/h2&gt;&lt;p&gt;是否会收敛？收敛到唯一向量吗？是否与初始向量有关？收敛时间？&lt;/p&gt;
&lt;p&gt;以下分析为两位Google创始人解决的迭代问题。&lt;/p&gt;
&lt;p&gt;布林和佩奇最初利用$\pi^{(0)T}=1/ne^T$来开始迭代过程，但这可能导致排名下沉(rank sink)，譬如出现多个0，可比性降低，排名下沉很大程度上与悬挂节点（岀链为0）的出现有关。&lt;/p&gt;
&lt;p&gt;为了解决这个问题，他们使用了随机上网者的概念，对H矩阵进行调整，随机上网者特点为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;随机岀链，包括悬挂节点&lt;/li&gt;
&lt;li&gt;随机上网者在某个特定页面上所停留的时间比例便是该页面相对重要性的一个度量&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;于是，我们将H矩阵变为随机矩阵S：&lt;br&gt;$$ S= \begin{matrix} \pmatrix{ 0 &amp;amp; 1/2 &amp;amp; 1/2 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 \ 1/6 &amp;amp; 1/6 &amp;amp; 1/6 &amp;amp; 1/6 &amp;amp; 1/6 &amp;amp; 1/6 \ 1/3 &amp;amp; 1/3 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1/3 &amp;amp; 0 \ 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1/2 &amp;amp; 1/2 \ 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1/2 &amp;amp; 0 &amp;amp; 1/2 \ 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1 &amp;amp; 0 &amp;amp; 0 \} \end{matrix} $$&lt;br&gt;可以证明，S是由H的一个秩一修正所给出的，即$S=H + a(1/n e^T)$，其中，若页面i为悬挂结点则ai=1，否则为0。二值向量a为悬挂结点向量，为列向量。&lt;/p&gt;
&lt;p&gt;然而，仅靠这一点还不够，未能达成存在唯一的正向量$\pi^T$ ,且方程能很快地收敛到$\pi^T$。要做到这一点，布林和佩奇做了另外一个调整，所谓的素性调整。&lt;strong&gt;有了这个调整，所得的矩阵就是随机的并且是素的。一个素矩阵是不可约的并且非周期的，因此，链的稳态向量存在且唯一&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;转换为素矩阵是基于这样一个论述的。上网者有时会在浏览器URL地址栏输入一个新的目的地，为了对这个行为进行数学建模，布林和佩奇创造了一个新的矩阵G如下：&lt;/p&gt;
&lt;p&gt;$$ G=\alpha S + (1-\alpha)1/n ee^T$$&lt;/p&gt;
&lt;p&gt;式中，a是一个0到1的标量(在之后的章节会反复提到a在谷歌中取0.85)，表示随机上网者根据万维网的超链接结构进行浏览的时间百分比。G成为&lt;strong&gt;谷歌矩阵&lt;/strong&gt;，$E=1/n ee^T$可称为跳转矩阵，是均匀分布的，即在进行跳转时是公平跳转。&lt;/p&gt;
&lt;p&gt;在书中，分为6点简单概括G带来的后果：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;G是随机的。&lt;/li&gt;
&lt;li&gt;G是不可约的。&lt;/li&gt;
&lt;li&gt;G是非周期的，Gii&amp;gt;0导致。&lt;/li&gt;
&lt;li&gt;G是素的。&lt;/li&gt;
&lt;li&gt;G是完全稠密的。从计算的角度，这是很糟糕的。但G可以写为非常稀疏的超链接矩阵H的秩一修正。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;\begin{align}&lt;br&gt;G &amp;amp;=\alpha S + (1-\alpha)1/n ee^T \&lt;br&gt;&amp;amp; =\alpha (H + a(1/n e^T)) + (1-\alpha)1/n ee^T \&lt;br&gt;&amp;amp; =\alpha H+[\alpha(a)+(1-\alpha)e]1/ne^T&lt;br&gt;\end{align}&lt;/p&gt;
&lt;p&gt;因此，谷歌修正后的PageRank法为&lt;br&gt;$$\pi^{（k+1）T}=\pi^{（k）T}G$$&lt;/p&gt;
&lt;h2 id=&quot;2-4-PageRank向量的计算&quot;&gt;&lt;a href=&quot;#2-4-PageRank向量的计算&quot; class=&quot;headerlink&quot; title=&quot;2.4 PageRank向量的计算&quot;&gt;&lt;/a&gt;2.4 PageRank向量的计算&lt;/h2&gt;&lt;p&gt;将求解$\pi^T$转换为如下特征向量问题&lt;br&gt;$$\pi^T=\pi^TG \&lt;br&gt;    \pi^Te=1$$&lt;br&gt;将求解$\pi^T$转换为求解如下的性齐次系统：&lt;br&gt;$$\pi^T(E-G)=0^T \&lt;br&gt;    \pi^Te=1$$&lt;br&gt;第一个系统为找到对应于主特征值$\lambda_1=1$的G的归一化主左特征向量。在第二个系统中，目标则是找到E-G的归一化左零向量。两个系统均服从归一化方程$\pi^Te=1$，该方程确保$\pi^T$是一个概率向量。&lt;/p&gt;
&lt;h3 id=&quot;2-4-1-幂法计算&quot;&gt;&lt;a href=&quot;#2-4-1-幂法计算&quot; class=&quot;headerlink&quot; title=&quot;2.4.1 幂法计算&quot;&gt;&lt;/a&gt;2.4.1 幂法计算&lt;/h3&gt;&lt;p&gt;PageRank矩阵G的特点使得幂法成为了显而易见的最佳选择。幂法是求取矩阵主特征值和特征向量的最古老同时也是最简单的迭代方法之一。缺点的计算速度缓慢。&lt;br&gt;\begin{align} \pi^{（k+1）T} &amp;amp; =\pi^{（k）T}G \ &amp;amp; =\alpha S + (1-\alpha)1/n \pi^{（k）T} ee^T \ &amp;amp; =\alpha (H + a(1/n e^T)) + (1-\alpha)1/n ee^T \ &amp;amp; =\alpha \pi^{（k）T} H+[\alpha \pi^{（k）T} a+1-\alpha]e^T/n \end{align}&lt;br&gt;式中，向量-矩阵乘法$\alpha \pi^{（k）T} H$执行于H这个极端稀疏的矩阵之上，而S和G从来就没有被实际生成或存储过，每个向量-矩阵乘法的复杂度为O(n)，因为H的每一行有差不多10个非零元素，这就是使用幂法的主要原因。&lt;br&gt;这里还有几个优点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;幂法中矩阵系数仅通过向量-矩阵乘法运算的程序来进行访问，而没有实际对矩阵加以操作。&lt;/li&gt;
&lt;li&gt;幂法存储方面，除了稀疏矩阵H和悬挂结点向量a之外，就只需要保存\alpha \pi^{（k）T}$了，这个向量是完全稠密的。&lt;/li&gt;
&lt;li&gt;迭代次数仅需50~100次。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为什么仅需50次呢，解释一下，在马尔科夫链理论中给出了答案，一般而言，应用于某个矩阵的幂法的渐进收敛速率依赖于绝对值最大的两个特征值$\lambda_1$和$\lambda&lt;em&gt;2$的比值。确切来说，渐进收敛速率就是$ |\lambda&lt;/em&gt;/\lambda_1|^k \to 0 $的速率。&lt;/p&gt;
&lt;p&gt;对于G这样的随机矩阵，$\lambda_1=1$，由于G也是素的，因此$|\lambda_2|&amp;lt;1$。&lt;/p&gt;
&lt;p&gt;通过一些理论的支撑，有以下关系：&lt;br&gt;$$\lambda_k=\alpha \mu_k$$&lt;br&gt;其中$\mu_k&amp;lt;=1$&lt;/p&gt;
&lt;p&gt;在万维网结构中，$\mu_k$约等于1，因此，$|\mu_2(G)| \approx \alpha$。&lt;/p&gt;
&lt;p&gt;因此，渐进收敛速率在50次的情况为：&lt;br&gt;$$\alpha ^{50}=0.85^{50} \approx 0.000296$$&lt;br&gt;即在第50次迭代时，可以期望近似PageRank向量的精度大约为小数点后2~3位。这个精度已经足够了，当然要真正区分需要小数点后10位精度，但是当PageRank评分和内容评分结合起来之后，高精度就变得不那么重要了。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;声明：由于此次第一次使用动态加载的表达式，hexo对LaTex支持可能不太好，因此这里有些公式显示奇奇怪怪，排版比较好一点的参考csdn:&lt;a href=&quot;http://blog.csdn.net/gugugujiawei/article/details/45459089&quot;&gt;博客链接&lt;/a&gt;,下次就直接上图片算了。免得这边不兼容。&lt;/p&gt;
&lt;h1 id=&quot;一、欢迎度历史&quot;&gt;&lt;a href=&quot;#一、欢迎度历史&quot; class=&quot;headerlink&quot; title=&quot;一、欢迎度历史&quot;&gt;&lt;/a&gt;一、欢迎度历史&lt;/h1&gt;&lt;p&gt;1998年 Jon Kleinberg致力于HITS的万维网搜索引擎项目，其中的算法使用了万维网的超链接结构来改进搜索引擎所得的结果。&lt;/p&gt;
&lt;p&gt;同时，在离他很近的斯坦福大学里，两名博士生正在从事一项名为PageRank的类似项目，分别是Sergey Brin和Larry Page。&lt;br&gt;
    
    </summary>
    
      <category term="Search Engine" scheme="http://enjoyhot.github.io/categories/Search-Engine/"/>
    
    
      <category term="Search Engine" scheme="http://enjoyhot.github.io/tags/Search-Engine/"/>
    
      <category term="PageRank" scheme="http://enjoyhot.github.io/tags/PageRank/"/>
    
  </entry>
  
  <entry>
    <title>网络搜索引擎简介</title>
    <link href="http://enjoyhot.github.io/2015/04/21/%E7%BD%91%E7%BB%9C%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E7%AE%80%E4%BB%8B/"/>
    <id>http://enjoyhot.github.io/2015/04/21/网络搜索引擎简介/</id>
    <published>2015-04-21T05:23:50.000Z</published>
    <updated>2017-04-16T14:48:30.690Z</updated>
    
    <content type="html">&lt;h1 id=&quot;一、传统信息检索回顾&quot;&gt;&lt;a href=&quot;#一、传统信息检索回顾&quot; class=&quot;headerlink&quot; title=&quot;一、传统信息检索回顾&quot;&gt;&lt;/a&gt;一、传统信息检索回顾&lt;/h1&gt;&lt;p&gt;传统信息检索文档集的搜索有三种基本的计算机辅助技术：布尔模型、向量空间模型和概率模型。这些模型发展与20世纪60年代，直到2000年6月，便存在3500种不同的搜索引擎技术，并且大多数搜索引擎仍然依赖于以上三种基本模型的一种或数种。下图摘自《搜索引擎-原理技术与系统》，显示了搜索的主干流程。&lt;br&gt;&lt;img src=&quot;http://img.blog.csdn.net/20150421133224646&quot; alt=&quot;这里写图片描述&quot;&gt;&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;##1.1 布尔搜索引擎&lt;br&gt;信息检索中最早而且最简单的检索方法之一。布尔逻辑检索也称作布尔逻辑搜索，严格意义上的布尔检索法是指利用布尔逻辑运算符连接各个检索词，然后由计算机进行相应逻辑运算，以找出所需信息的方法。它使用面最广、使用频率最高。布尔逻辑运算符的作用是把检索词连接起来，构成一个逻辑检索式。&lt;/p&gt;
&lt;p&gt;##1.2向量空间模型搜索引擎&lt;br&gt;向量空间模型将文本数据变换为数值向量和矩阵，然后使用矩阵分析方法来发现文档集中的关键特征和联系。某些高级向量空间模型，如LSI（Latent Semantic Indexing,隐性语义索引）等能访问文档集中隐含的语义结构，如搜索car,能返回automobile相关文档。&lt;br&gt;该模型还有另外两个优点是相关性评分和相关性反馈。缺点是计算开销大，查询时必须计算每个文档和查询之间的距离度量，因而也伴随着另一个缺点——向量空间模型无法很好地扩展。&lt;/p&gt;
&lt;h2 id=&quot;1-3概率模型搜索引擎&quot;&gt;&lt;a href=&quot;#1-3概率模型搜索引擎&quot; class=&quot;headerlink&quot; title=&quot;1.3概率模型搜索引擎&quot;&gt;&lt;/a&gt;1.3概率模型搜索引擎&lt;/h2&gt;&lt;p&gt;用户给定一个查询请求，概率检索模型根据文档与用户请求的相关性排序文档，给出结果，举个简单的例子，对于信息检索的文档，最可能跟在information后面的词是retrieval，但独立性假设却认为任何词都会以等概率出现在information后面。重点在于相关性的定义与衡量。概率模型的构建和编程有可能十分困难，它们的复杂度上升得很快。&lt;/p&gt;
&lt;p&gt;##1.4元搜索引擎&lt;br&gt;传统搜索引擎其实还有第四种模型，即元搜素引擎。它将以上三种经典模型合为一体。&lt;/p&gt;
&lt;p&gt;##1.5搜索引擎的比较&lt;br&gt;两种最为常用的评价不同搜索方法的评价指标是查准率和查全率。查准率是指检索所得相关文献的数量占总的检索所得文献数量的比例；查全率是指检索所得相关文献数量占总的相关文献数量的比例。查准率和查全率越高，搜索引擎就越好。&lt;/p&gt;
&lt;p&gt;#二、网络搜索引擎&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;爬虫模块：蜘蛛&lt;/li&gt;
&lt;li&gt;页面仓库：蜘蛛满载页面而回，它们暂时以完整页面的形式存放在页面仓库中，而在被送到索引建立模块之前，新的页面将一直留在仓库中。&lt;/li&gt;
&lt;li&gt;索引建立模块：取出每个新的未压缩页面，并从中仅抽取出最为重要的描述，以生成该页面在不同索引中的一个压缩描述。&lt;/li&gt;
&lt;li&gt;索引：分为内容索引和特殊用途索引（如图像索引和PDF索引）&lt;/li&gt;
&lt;li&gt;查询模块：将用户的自然语言查询转化为搜索系统可以理解的语言，然后查询不同的索引以便回答查询。&lt;/li&gt;
&lt;li&gt;排名模块：接收相关页面集，并根据某个判断依据对其进行排名。区分能力的排名是结合两个分数得到的，它们分别是内容评分和欢迎度评分，共同确定了相关页面的总评分，并按照总评分的顺序将页面集呈现给用户。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;#三、网络爬行、索引建立和查询处理&lt;/p&gt;
&lt;p&gt;##3.1 网络爬行&lt;br&gt;特点：&lt;br&gt;1.爬行是一个永不停歇的过程&lt;br&gt;2.蜘蛛访问网页时，需做到有礼貌的访问，即对网站的影响降到最小，不然可能会被“惩处”&lt;br&gt;3.多个蜘蛛协调合作，制定最佳爬行策略，节省时间和精力，尽可能提高效率&lt;/p&gt;
&lt;p&gt;##3.2 内容索引&lt;br&gt;程序将分析页面内容并抽取有价值的信息，从而仅将页面中最为关键的核心部分传给适当的索引。有价值的信息存在于标题、描述和锚文本中，此外还有粗体显示的项、大字体显示的项和超链接等。建立索引后形成倒排文件，形如：&lt;br&gt;什么是倒排文件？如下例子（其中001~004对应为文档编号）：&lt;br&gt;001 xxx142 张三 男 18 元培&lt;br&gt;002 xxx205 李四 女 17 哲学&lt;br&gt;003 xxx187 王五 男 19 生物&lt;br&gt;004 xxx325 赵六 女 18 元培&lt;br&gt;而我们利用倒排文件来实现上述非关键码的查询，就能大大提高速度。对于前面的情况设计倒排表如下：&lt;br&gt;男 001，003&lt;br&gt;女 002，004&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;16&lt;br&gt;17 002&lt;br&gt;18 001，004&lt;br&gt;19 003&lt;br&gt;20&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;元培 001，004&lt;br&gt;生物 003&lt;br&gt;哲学 002&lt;/p&gt;
&lt;p&gt;##3.3查询处理&lt;br&gt;查询处理的结果，将以文档的相关评分返回，举个例子。&lt;br&gt;在文档集中查询项a和项b的组合词ab，返回的结果有：&lt;br&gt;项a : 3[1,1,27],94[1,0,7],673[0,0,3]&lt;br&gt;项b : 3[1,1,10,94[0,0,5] ,673[1,1,14]&lt;br&gt;如94[1,0,7]中，1表示的是项a在页面94的标题中出现了，0表示项a在页面的描述标签未出现，7表示项a在页面94中出现了7次。&lt;br&gt;因此，内容得分可以这样来计算：&lt;br&gt;内容得分（页面3）= （1+1+27）x (1+1+10)=348&lt;br&gt;内容得分(页面94)=（1+0+7）x (0+0+5)=40&lt;br&gt;内容得分(页面673)=（0+0+3）x (1+1+14)=48&lt;/p&gt;
&lt;p&gt;有多种方案可以利用许多其它的因子来构成内容评分，这里只是随便举了一种。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;内容评分和欢迎度评分决定了一个网页的最终评分，由于本书的重点在与欢迎度评分，因为在之后的介绍中将不多涉及内容评分。&lt;/strong&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、传统信息检索回顾&quot;&gt;&lt;a href=&quot;#一、传统信息检索回顾&quot; class=&quot;headerlink&quot; title=&quot;一、传统信息检索回顾&quot;&gt;&lt;/a&gt;一、传统信息检索回顾&lt;/h1&gt;&lt;p&gt;传统信息检索文档集的搜索有三种基本的计算机辅助技术：布尔模型、向量空间模型和概率模型。这些模型发展与20世纪60年代，直到2000年6月，便存在3500种不同的搜索引擎技术，并且大多数搜索引擎仍然依赖于以上三种基本模型的一种或数种。下图摘自《搜索引擎-原理技术与系统》，显示了搜索的主干流程。&lt;br&gt;&lt;img src=&quot;http://img.blog.csdn.net/20150421133224646&quot; alt=&quot;这里写图片描述&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Search Engine" scheme="http://enjoyhot.github.io/categories/Search-Engine/"/>
    
    
      <category term="Search Engine" scheme="http://enjoyhot.github.io/tags/Search-Engine/"/>
    
      <category term="PageRank" scheme="http://enjoyhot.github.io/tags/PageRank/"/>
    
  </entry>
  
  <entry>
    <title>export CSDN blog to Markdown</title>
    <link href="http://enjoyhot.github.io/2015/03/29/CSDN2Markdown/"/>
    <id>http://enjoyhot.github.io/2015/03/29/CSDN2Markdown/</id>
    <published>2015-03-29T08:40:00.000Z</published>
    <updated>2017-04-16T14:48:30.622Z</updated>
    
    <content type="html">&lt;p&gt;#一、综述&lt;/p&gt;
&lt;p&gt;最开始的博客用的是oschina, 自我感觉小清新，支持比较多风格的编辑器，容易编辑程度比csdn的要好。后来因为csdn人气的关系，又转到csdn，不过csdn编辑确实比较虐心，再后来就在服务器上搭一个WordPress的博客，不过用起来不是很爽。几个月前支持Markdown编辑，这无疑给用github pages的用户一个福音，因为可以直接上传到自己的github博客上。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;br&gt;用github pages生成静态的页面，目前比较流行有Jekyll,Octopress,Hexo等，其他的我没怎么调查，jekyll是github推荐的，上面有他们给的官方框架、主题，支持网页书写Markdown文章。后两者需要编译后再上传，github上呈现出来的是html文件。总体而言，后两者的界面更好，用起来更加舒适。我用的是Hexo，命令简洁，不过要注意备份整个工程，不然后果不堪设想。&lt;/p&gt;
&lt;p&gt;#二、迁移CSDN原文档到github Pages&lt;/p&gt;
&lt;p&gt;###1、前文&lt;br&gt;虽然目前CSDN支持markdown，但以前的文章都是用xeditor编辑器写的，不能导出，所以调研了方法。&lt;br&gt;总体而言有两种方法，但好像没多少人采用，因为格式可能不好。&lt;br&gt;1.爬取页面，导出html，然后在放在hexo中，目录为/source/_post/，直接放html文件，然后设置layout：false，那么hexo会忽略对html的编译，在浏览时直接超链接到html文件&lt;br&gt;2.将html文件再用程序转换为markdown&lt;br&gt;3.直接用代码爬取页面然后生成markdown文件&lt;/p&gt;
&lt;p&gt;第1种方法可能会遇到html文件中格式不支持的情况，没得到解决；&lt;br&gt;第2种方法发现在线转换效果也不好，就寻求代码解决，github上有一段&lt;a href=&quot;https://github.com/baizhebz/html2markdown4blog&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;程序&lt;/a&gt;，作者说可行，不过我环境没搭成功，不懂php，更何况要装curl（这个之前做android时NDK开发时也很难配置），后来用第3种方法就直接写python爬虫程序，参考github的一段&lt;a href=&quot;https://github.com/kesalin/PythonSnippet/blob/master/ExportCSDNBlog.py&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;程序&lt;/a&gt;，不过程序有些问题，也有些不符合如今CSDN的布局，所以我大改了一下，转为markdown的那一部分程序脉络是差不多的，这个也是最关键的部分，直接影响到markdown的显示，不过我也做得不太好。&lt;/p&gt;
&lt;p&gt;###2、程序&lt;br&gt;所需安装库：&lt;br&gt;BeautifulSoup&lt;br&gt;根据版本不同可能要改动相应的代码，一般不用改。&lt;br&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;23&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;24&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;25&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;26&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;27&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;28&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;29&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;30&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;31&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;32&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;33&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;34&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;35&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;36&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;37&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;38&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;39&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;40&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;41&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;42&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;43&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;44&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;45&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;46&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;47&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;48&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;49&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;50&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;51&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;52&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;53&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;54&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;55&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;56&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;57&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;58&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;59&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;60&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;61&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;62&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;63&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;64&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;65&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;66&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;67&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;68&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;69&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;70&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;71&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;72&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;73&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;74&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;75&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;76&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;77&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;78&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;79&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;80&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;81&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;82&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;83&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;84&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;85&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;86&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;87&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;88&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;89&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;90&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;91&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;92&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;93&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;94&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;95&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;96&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;97&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;98&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;99&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;100&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;101&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;102&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;103&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;104&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;105&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;106&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;107&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;108&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;109&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;110&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;111&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;112&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;113&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;114&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;115&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;116&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;117&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;118&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;119&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;120&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;121&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;122&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;123&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;124&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;125&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;126&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;127&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;128&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;129&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;130&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;131&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;132&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;133&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;134&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;135&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;136&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;137&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;138&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;139&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;140&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;141&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;142&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;143&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;144&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;145&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;146&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;147&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;148&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;149&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;150&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;151&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;152&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;153&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;154&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;155&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;156&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;157&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;158&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;159&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;160&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;161&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;162&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;163&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;164&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;165&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;166&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;167&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;168&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;169&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;170&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;171&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;172&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;173&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;174&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;175&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;176&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;177&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;178&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;179&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;180&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;181&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;182&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;183&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;184&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;185&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;186&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;187&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;188&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;189&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;190&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;191&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;192&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;193&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;194&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;195&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;196&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;197&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;198&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;199&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;200&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;201&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;202&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;203&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;204&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;205&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;206&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;207&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;208&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;209&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;210&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;211&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;212&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;213&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;214&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;215&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;216&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;217&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;218&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;219&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;220&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;221&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;222&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;223&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;224&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;225&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;226&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;227&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;228&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;229&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;230&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;231&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;232&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;233&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;234&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;235&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;236&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;237&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;238&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;239&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;240&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;241&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;242&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;243&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;244&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;245&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;246&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;247&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;248&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;249&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;250&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;251&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;252&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;253&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#! /usr/bin/env python&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#coding=utf-8&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; urllib2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; bs4 &lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; BeautifulSoup&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; logging&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; re&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; threading&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; traceback&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; time&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; datetime&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; sys&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;reload(sys)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;sys.setdefaultencoding(&lt;span class=&quot;string&quot;&gt;&#39;gb18030&#39;&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# global variable&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;blog = &lt;span class=&quot;string&quot;&gt;&quot;http://blog.csdn.net&quot;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;url = &lt;span class=&quot;string&quot;&gt;&quot;http://blog.csdn.net/gugugujiawei?viewmode=contents&quot;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;outputDir = &lt;span class=&quot;string&quot;&gt;&#39;F:\\linux\\Share\\github\\article\\&#39;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;gRetryCount = &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;decodeHtmlSpecialCharacter&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(htmlStr)&lt;/span&gt;:&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    specChars = &amp;#123;&lt;span class=&quot;string&quot;&gt;&quot;&amp;amp;ensp;&quot;&lt;/span&gt; : &lt;span class=&quot;string&quot;&gt;&quot;&quot;&lt;/span&gt;, \&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                 &lt;span class=&quot;string&quot;&gt;&quot;&amp;amp;emsp;&quot;&lt;/span&gt; : &lt;span class=&quot;string&quot;&gt;&quot;&quot;&lt;/span&gt;, \&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                 &lt;span class=&quot;string&quot;&gt;&quot;&amp;amp;nbsp;&quot;&lt;/span&gt; : &lt;span class=&quot;string&quot;&gt;&quot;&quot;&lt;/span&gt;, \&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                 &lt;span class=&quot;string&quot;&gt;&quot;&amp;amp;lt;&quot;&lt;/span&gt; : &lt;span class=&quot;string&quot;&gt;&quot;&amp;lt;&quot;&lt;/span&gt;, \&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                 &lt;span class=&quot;string&quot;&gt;&quot;&amp;amp;gt&quot;&lt;/span&gt; : &lt;span class=&quot;string&quot;&gt;&quot;&amp;gt;&quot;&lt;/span&gt;, \&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                 &lt;span class=&quot;string&quot;&gt;&quot;&amp;amp;amp;&quot;&lt;/span&gt; : &lt;span class=&quot;string&quot;&gt;&quot;&amp;amp;&quot;&lt;/span&gt;, \&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                 &lt;span class=&quot;string&quot;&gt;&quot;&amp;amp;quot;&quot;&lt;/span&gt; : &lt;span class=&quot;string&quot;&gt;&quot;\&quot;&quot;&lt;/span&gt;, \&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                 &lt;span class=&quot;string&quot;&gt;&quot;&amp;amp;copy;&quot;&lt;/span&gt; : &lt;span class=&quot;string&quot;&gt;&quot;®&quot;&lt;/span&gt;, \&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                 &lt;span class=&quot;string&quot;&gt;&quot;&amp;amp;times;&quot;&lt;/span&gt; : &lt;span class=&quot;string&quot;&gt;&quot;×&quot;&lt;/span&gt;, \&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                 &lt;span class=&quot;string&quot;&gt;&quot;&amp;amp;divide;&quot;&lt;/span&gt; : &lt;span class=&quot;string&quot;&gt;&quot;÷&quot;&lt;/span&gt;, \&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                 &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; key &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; specChars.keys():&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        htmlStr = htmlStr.replace(key, specChars[key])&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; htmlStr&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;repalceInvalidCharInFilename&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(filename)&lt;/span&gt;:&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    specChars = &amp;#123;&lt;span class=&quot;string&quot;&gt;&quot;\\&quot;&lt;/span&gt; : &lt;span class=&quot;string&quot;&gt;&quot;&quot;&lt;/span&gt;, \&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                 &lt;span class=&quot;string&quot;&gt;&quot;/&quot;&lt;/span&gt; : &lt;span class=&quot;string&quot;&gt;&quot;&quot;&lt;/span&gt;, \&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                 &lt;span class=&quot;string&quot;&gt;&quot;:&quot;&lt;/span&gt; : &lt;span class=&quot;string&quot;&gt;&quot;&quot;&lt;/span&gt;, \&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                 &lt;span class=&quot;string&quot;&gt;&quot;*&quot;&lt;/span&gt; : &lt;span class=&quot;string&quot;&gt;&quot;&quot;&lt;/span&gt;, \&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                 &lt;span class=&quot;string&quot;&gt;&quot;?&quot;&lt;/span&gt; : &lt;span class=&quot;string&quot;&gt;&quot;&quot;&lt;/span&gt;, \&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                 &lt;span class=&quot;string&quot;&gt;&quot;\&quot;&quot;&lt;/span&gt; : &lt;span class=&quot;string&quot;&gt;&quot;&quot;&lt;/span&gt;, \&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                 &lt;span class=&quot;string&quot;&gt;&quot;&amp;lt;&quot;&lt;/span&gt; : &lt;span class=&quot;string&quot;&gt;&quot;小于&quot;&lt;/span&gt;, \&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                 &lt;span class=&quot;string&quot;&gt;&quot;&amp;gt;&quot;&lt;/span&gt; : &lt;span class=&quot;string&quot;&gt;&quot;大于&quot;&lt;/span&gt;, \&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                 &lt;span class=&quot;string&quot;&gt;&quot;|&quot;&lt;/span&gt; : &lt;span class=&quot;string&quot;&gt;&quot; and &quot;&lt;/span&gt;, \&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                 &lt;span class=&quot;string&quot;&gt;&quot;&amp;amp;&quot;&lt;/span&gt; :&lt;span class=&quot;string&quot;&gt;&quot; or &quot;&lt;/span&gt;, \&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                 &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; key &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; specChars.keys():&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        filename = filename.replace(key, specChars[key])&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; filename&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;getPageUrlList&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(url)&lt;/span&gt;:&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;global&lt;/span&gt; blog&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;#获取所有的页面的 url&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    user_agent = &lt;span class=&quot;string&quot;&gt;&#39;Mozilla/4.0 (compatible;  MSIE 5.5; Windows NT)&#39;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    header = &amp;#123; &lt;span class=&quot;string&quot;&gt;&#39;User-Agent&#39;&lt;/span&gt; : user_agent &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    request = urllib2.Request(url, &lt;span class=&quot;keyword&quot;&gt;None&lt;/span&gt;, header)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    response = urllib2.urlopen(request)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    data = response.read()&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;#print data&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    soup = BeautifulSoup(data)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    pageListDocs = soup.find_all(id=&lt;span class=&quot;string&quot;&gt;&quot;article_list&quot;&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;# artclie----&amp;#123;url:title&amp;#125;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    articleUrlTitle = &amp;#123;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;#print len(pageListDocs)&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; pageList &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; pageListDocs:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        h1List = pageList.find_all(&lt;span class=&quot;string&quot;&gt;&#39;h1&#39;&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; articleList &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; h1List:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            hrefDocs = articleList.find_all(&lt;span class=&quot;string&quot;&gt;&quot;a&quot;&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; len(hrefDocs) &amp;gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                articleHrefDoc = hrefDocs[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                &lt;span class=&quot;comment&quot;&gt;#print &quot;hello&quot;,articleHrefDoc&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                articleUrl =  blog + articleHrefDoc[&lt;span class=&quot;string&quot;&gt;&quot;href&quot;&lt;/span&gt;]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                articleTitle = articleHrefDoc.text&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                articleUrlTitle[articleUrl] = articleTitle&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;the count of articles is&#39;&lt;/span&gt;,len(articleUrlTitle)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&#39;&#39;&#39;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    for s in articleUrlTitle:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        print s,&#39;--&#39;,articleUrlTitle[s]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &#39;&#39;&#39;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; articleUrlTitle&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;download&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(url, title)&lt;/span&gt;:&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;# 下载文章，并保存为 markdown 格式&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    logging.info(&lt;span class=&quot;string&quot;&gt;&quot; &amp;gt;&amp;gt; download: &quot;&lt;/span&gt; + url)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;downloading the article&#39;&lt;/span&gt;,title&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    data = &lt;span class=&quot;keyword&quot;&gt;None&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    title = &lt;span class=&quot;string&quot;&gt;&#39;&quot;&#39;&lt;/span&gt; + title + &lt;span class=&quot;string&quot;&gt;&#39;&quot;&#39;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    categories = &lt;span class=&quot;string&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    content = &lt;span class=&quot;string&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;#postDate = datetime.datetime.now()&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;global&lt;/span&gt; gRetryCount&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    count = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;True&lt;/span&gt;:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; count &amp;gt;= gRetryCount:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        count = count + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt;:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            time.sleep(&lt;span class=&quot;number&quot;&gt;2.0&lt;/span&gt;) &lt;span class=&quot;comment&quot;&gt;#访问太快会不响应&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            user_agent = &lt;span class=&quot;string&quot;&gt;&#39;Mozilla/4.0 (compatible;  MSIE 5.5; Windows NT)&#39;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            header = &amp;#123; &lt;span class=&quot;string&quot;&gt;&#39;User-Agent&#39;&lt;/span&gt; : user_agent &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            request = urllib2.Request(url, &lt;span class=&quot;keyword&quot;&gt;None&lt;/span&gt;, header)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            response = urllib2.urlopen(request)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            data = response.read()&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;except&lt;/span&gt; Exception,e:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            exstr = traceback.format_exc()&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            logging.info(&lt;span class=&quot;string&quot;&gt;&quot; &amp;gt;&amp;gt; failed to download &quot;&lt;/span&gt; + url + &lt;span class=&quot;string&quot;&gt;&quot;, retry: &quot;&lt;/span&gt; + str(count) + &lt;span class=&quot;string&quot;&gt;&quot;, error:&quot;&lt;/span&gt; + exstr)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;pass&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; data == &lt;span class=&quot;keyword&quot;&gt;None&lt;/span&gt;:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        logging.info(&lt;span class=&quot;string&quot;&gt;&quot; &amp;gt;&amp;gt; failed to download &quot;&lt;/span&gt; + url)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;#print data&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    soup = BeautifulSoup(data)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;#date=link_postdate&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    manageDocs = soup.find_all(&lt;span class=&quot;string&quot;&gt;&quot;div&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;article_manage&quot;&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; managerDoc &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; manageDocs:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        categoryDoc = managerDoc.find_all(&lt;span class=&quot;string&quot;&gt;&quot;span&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;link_categories&quot;&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; len(categoryDoc) &amp;gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            categories = categoryDoc[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;].a.get_text().encode(&lt;span class=&quot;string&quot;&gt;&#39;UTF-8&#39;&lt;/span&gt;).strip()&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            categories  = categories.decode(&lt;span class=&quot;string&quot;&gt;&#39;utf-8&#39;&lt;/span&gt;).encode(&lt;span class=&quot;string&quot;&gt;&#39;gb2312&#39;&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        postDateDoc = managerDoc.find_all(&lt;span class=&quot;string&quot;&gt;&quot;span&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;link_postdate&quot;&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; len(postDateDoc) &amp;gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            postDateStr = postDateDoc[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;].string.encode(&lt;span class=&quot;string&quot;&gt;&#39;UTF-8&#39;&lt;/span&gt;).strip()&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            postDate = datetime.datetime.strptime(postDateStr, &lt;span class=&quot;string&quot;&gt;&#39;%Y-%m-%d %H:%M&#39;&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;date&#39;&lt;/span&gt;,postDate&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    contentDocs = soup.find_all(id=&lt;span class=&quot;string&quot;&gt;&quot;article_content&quot;&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; contentDoc &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; contentDocs:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        htmlContent = contentDoc.prettify().encode(&lt;span class=&quot;string&quot;&gt;&#39;UTF-8&#39;&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;#print htmlContent&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;#file = open(&#39;F:\\linux\\Share\\github\\out2.txt&#39;,&#39;a+&#39;)&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;#file.write(htmlContent)&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        content = htmlContent2String(htmlContent)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    exportToMarkdown(outputDir, postDate, categories, title, content)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# htmlContent2String 是整个程序的关键，用于将html转换为markdown格式&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;htmlContent2String&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(contentStr)&lt;/span&gt;:&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;# 因为格式中可能会有点乱，换行符乱入，所以用[\s\S]匹配任何字符，包括换行符，注意其中的？是为了去除贪婪匹配&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;# &amp;lt;img src=&quot;http://img.blog.csdn.net/20150118194525562&quot; align=&quot;middle&quot; width=&quot;400 height=&quot;300&quot; alt=&quot;&quot;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;# 图片链接&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    patternImg = re.compile(&lt;span class=&quot;string&quot;&gt;r&#39;(&amp;lt;img[\s\S]+?src=&quot;)([\s\S]+?)(&quot;[\s\S]+?&amp;gt;)&#39;&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;# &amp;lt;a target=&quot;_blank&quot; href=&quot;http://blog.csdn.net/gugugujiawei/article/details/42558411&quot;&amp;gt;博文&amp;lt;/a&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;# 文字链接&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    patternHref = re.compile(&lt;span class=&quot;string&quot;&gt;r&#39;(&amp;lt;a[\s\S]+?href=&quot;)([\s\S]*?)(&quot;[\s\S]*?&amp;gt;)([\s\S]+?)(&amp;lt;/a&amp;gt;)&#39;&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;# 去除html各种标签，这里的？则是指匹配0次或1次&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    patternRemoveHtml = re.compile(&lt;span class=&quot;string&quot;&gt;r&#39;&amp;lt;/?[^&amp;gt;]+&amp;gt;&#39;&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    resultContent = patternImg.sub(&lt;span class=&quot;string&quot;&gt;r&#39;![image_mark](\2)&#39;&lt;/span&gt;, contentStr)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    resultContent = patternHref.sub(&lt;span class=&quot;string&quot;&gt;r&#39;[\4](\2)&#39;&lt;/span&gt;, resultContent)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    resultContent = re.sub(patternRemoveHtml, &lt;span class=&quot;string&quot;&gt;r&#39;&#39;&lt;/span&gt;, resultContent)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    resultContent = decodeHtmlSpecialCharacter(resultContent)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;#file = open(&#39;F:\\linux\\Share\\github\\out3.txt&#39;,&#39;a+&#39;)&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;#file.write(resultContent)&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; resultContent&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;exportToMarkdown&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(exportDir, postdate, categories, title, content)&lt;/span&gt;:&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    titleDate = postdate.strftime(&lt;span class=&quot;string&quot;&gt;&#39;%Y-%m&#39;&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    contentDate = postdate.strftime(&lt;span class=&quot;string&quot;&gt;&#39;%Y-%m-%d %H:%M:%S %z&#39;&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    filename = title&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    filename = repalceInvalidCharInFilename(filename)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    filepath = exportDir + filename + &lt;span class=&quot;string&quot;&gt;&#39;.txt&#39;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;#newFile = open(unicode(filepath, &quot;utf8&quot;), &#39;w&#39;)&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    newFile = open(filepath,&lt;span class=&quot;string&quot;&gt;&#39;a+&#39;&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;# 根据自己需要选择去留注释,这里categores和tag用了一样的&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;# newFile.write(&#39;---&#39; + &#39;\n&#39;)&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;# newFile.write(&#39;layout: post&#39; + &#39;\n&#39;)&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    newFile.write(&lt;span class=&quot;string&quot;&gt;&#39;title: &#39;&lt;/span&gt; + title + &lt;span class=&quot;string&quot;&gt;&#39;\n&#39;&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    newFile.write(&lt;span class=&quot;string&quot;&gt;&#39;date: &#39;&lt;/span&gt; + contentDate + &lt;span class=&quot;string&quot;&gt;&#39;\n&#39;&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;# newFile.write(&#39;comments: true&#39; + &#39;\n&#39;)&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    newFile.write(&lt;span class=&quot;string&quot;&gt;&#39;categories: [&#39;&lt;/span&gt; + categories + &lt;span class=&quot;string&quot;&gt;&#39;]&#39;&lt;/span&gt; + &lt;span class=&quot;string&quot;&gt;&#39;\n&#39;&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    newFile.write(&lt;span class=&quot;string&quot;&gt;&#39;tags: [&#39;&lt;/span&gt; + categories + &lt;span class=&quot;string&quot;&gt;&#39;]&#39;&lt;/span&gt; + &lt;span class=&quot;string&quot;&gt;&#39;\n&#39;&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;#newFile.write(&#39;description:&#39; + title + &#39;\n&#39;)&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;# newFile.write(&#39;keywords: &#39; + categories + &#39;\n&#39;)&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    newFile.write(&lt;span class=&quot;string&quot;&gt;&#39;---&#39;&lt;/span&gt; + &lt;span class=&quot;string&quot;&gt;&#39;\n\n&#39;&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    content = content.decode(&lt;span class=&quot;string&quot;&gt;&#39;utf-8&#39;&lt;/span&gt;).encode(&lt;span class=&quot;string&quot;&gt;&#39;gb18030&#39;&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;#print content&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    newFile.write(content)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    newFile.write(&lt;span class=&quot;string&quot;&gt;&#39;\n&#39;&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    newFile.close()&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; __name__ == &lt;span class=&quot;string&quot;&gt;&quot;__main__&quot;&lt;/span&gt;:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;global&lt;/span&gt; url&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    articleUrlTitle = getPageUrlList(url)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&#39;&#39;&#39;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    for s in articleUrlTitle:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        print s,&#39;--&#39;,articleUrlTitle[s]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &#39;&#39;&#39;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;#multithread download&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    threads = []&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; url &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; articleUrlTitle:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        patternTitle = re.compile(&lt;span class=&quot;string&quot;&gt;&#39;\r\n *(.+) *\r\n&#39;&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        title = patternTitle.sub(&lt;span class=&quot;string&quot;&gt;r&#39;\1&#39;&lt;/span&gt;,articleUrlTitle[url])&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;# print &#39;title&#39;,title&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        t = threading.Thread(target = download,args = (url,title))&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        t.start()&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        threads.append(t)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; threads:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        i.join()&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;success&quot;&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;注意一下，我是直接在windows下运行生成的txt文件，所以文件时dos文件，当在linux下编辑的话会出现各种因格式问题导致的奇怪的问题，这需要自己改一下编码。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;#一、综述&lt;/p&gt;
&lt;p&gt;最开始的博客用的是oschina, 自我感觉小清新，支持比较多风格的编辑器，容易编辑程度比csdn的要好。后来因为csdn人气的关系，又转到csdn，不过csdn编辑确实比较虐心，再后来就在服务器上搭一个WordPress的博客，不过用起来不是很爽。几个月前支持Markdown编辑，这无疑给用github pages的用户一个福音，因为可以直接上传到自己的github博客上。&lt;br&gt;
    
    </summary>
    
      <category term="Markdown" scheme="http://enjoyhot.github.io/categories/Markdown/"/>
    
    
      <category term="Markdown" scheme="http://enjoyhot.github.io/tags/Markdown/"/>
    
      <category term="CSDN" scheme="http://enjoyhot.github.io/tags/CSDN/"/>
    
  </entry>
  
  <entry>
    <title>Album</title>
    <link href="http://enjoyhot.github.io/2015/03/26/Album/"/>
    <id>http://enjoyhot.github.io/2015/03/26/Album/</id>
    <published>2015-03-26T15:45:21.000Z</published>
    <updated>2017-04-16T14:48:30.610Z</updated>
    
    <content type="html">&lt;p&gt;You just say something I don’t know.&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;You just say something I don’t know.&lt;/p&gt;

    
    </summary>
    
      <category term="Photo" scheme="http://enjoyhot.github.io/categories/Photo/"/>
    
    
      <category term="Photo" scheme="http://enjoyhot.github.io/tags/Photo/"/>
    
  </entry>
  
  <entry>
    <title>HPC集群平台搭建概念</title>
    <link href="http://enjoyhot.github.io/2015/03/24/HPC-cluster/"/>
    <id>http://enjoyhot.github.io/2015/03/24/HPC-cluster/</id>
    <published>2015-03-24T12:23:50.000Z</published>
    <updated>2017-04-16T14:48:30.638Z</updated>
    
    <content type="html">&lt;p&gt;　　在本文之前，我建议先看完这篇文章：&lt;a href=&quot;http://www.jointforce.com.cn/page/hardware_linux.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Linux高性能计算集群 – Beowulf集群&lt;/a&gt;　　&lt;/p&gt;
&lt;p&gt;#一、搭建集群中可能会遇到的问题&lt;/p&gt;
&lt;p&gt;1.集群设计/布局的一大难点就是网络，各家有各家的策略，一般围绕Beowulf变型。&lt;br&gt;2.软件的部署缺乏实操调试，也不能断定这样部署是否成功以及是否优越。&lt;br&gt;3.操作系统的选型以及安装系统、所需软件（包括集群管理工具、驱动软件、能耗监控软件等）的整个流程的手动/自动化部署。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;br&gt;4.每个提供硬件的对应公司几乎都推出他们自己的集群管理软件，浪潮好像没有，在HPC方面浪潮好像没有相应的开发社区，DELL和IBM这些大公司都有。&lt;br&gt;5.能耗的衡量，具体的优化方向和策略。&lt;/p&gt;
&lt;p&gt;#二、HPC概览&lt;/p&gt;
&lt;p&gt;##①总体构成&lt;br&gt;    Outside Network: 外部网络&lt;br&gt;    Master Node: 主节点&lt;br&gt;    Compute Nodes: 计算节点&lt;br&gt;    Storage: 存储器&lt;br&gt;    Computational Network: 计算网络&lt;br&gt;    Management Network: 管理网络&lt;/p&gt;
&lt;p&gt;##②大多数 HPCC 系统配有两个网络&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;基于TCP的管理网络&lt;/li&gt;
&lt;li&gt;计算网络，可以是基于 TCP 或其它协议的，通常是 InfiniBand 或 Myrinet 10G 之    类的高速网络&lt;br&gt;##③拓扑图&lt;br&gt;网上找的普遍认可的：&lt;br&gt;&lt;img src=&quot;http://img.blog.csdn.net/20150324151225653&quot; alt=&quot;这里写图片描述&quot;&gt;&lt;br&gt;&lt;img src=&quot;http://img.blog.csdn.net/20150324151208655&quot; alt=&quot;这里写图片描述&quot;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;p&gt;这个是自己根据实际情况“臆想”的：&lt;br&gt;&lt;img src=&quot;http://img.blog.csdn.net/20150324151438331&quot; alt=&quot;这里写图片描述&quot;&gt;&lt;/p&gt;
&lt;p&gt;##④所需软件组件（按安装顺序）：&lt;/p&gt;
&lt;p&gt;###1、对于安装系统：&lt;br&gt;　　集群中的每个节点（HPCC 节点文章链接）、主节点、登录节点和计算节点都需要有操作系统。操作系统可以安装在节点的硬盘驱动器上，甚至可以安装在ramdisk 上，这有时被称为“无盘”或“无状态”节点。一般说来，主节点创建所谓的“映像”，然后将其发送到计算节点上进行安装（硬盘驱动器或 ramdisk 上）。&lt;br&gt;　　系统装在内存会更快，但断电后要采取将系统拷贝到硬盘的方法重新存储起来，比较麻烦。&lt;br&gt;　　&lt;br&gt;　　&lt;strong&gt;几种安装工具的特点：&lt;/strong&gt;&lt;br&gt;　　&lt;img src=&quot;http://img.blog.csdn.net/20150324151858809&quot; alt=&quot;这里写图片描述&quot;&gt;&lt;/p&gt;
&lt;p&gt;　　但是，比较有名有Rocks（比xCat安装简单）、xCat。&lt;br&gt;　　&lt;strong&gt;xCAT:&lt;/strong&gt;&lt;br&gt;a、支持自己系统独立，可以自己选择基于RHEL的最新版本系统；&lt;br&gt;b、命令行安装，需要人工编辑配置文件，安装一台之后再利用脚本进行网络安装裸机节点；&lt;br&gt;c、xCat在安装起来像一个个独立软件，如其他并行计算需要的相关软件可以通过xCat命令安装；&lt;br&gt;　　&lt;strong&gt;Rocks:&lt;/strong&gt;&lt;br&gt;a、ROCKS 基于 Red Hat 发行版，这对于大多数人是合适的，但是对于使用 SUSE 或者希望使用在 RH 6.2 发行版上创建的映像的人就不合适了，里面的软件可以选择性安装。另外，ROCKS 不是克隆解决方案；&lt;br&gt;b、之前需刻录CD，GUI界面部署，之后人工进行节点命名和节点ip的配置，安装时一台一台进行；&lt;br&gt;c、Rocks则像一个集成的包，包含工具与软件；&lt;br&gt;Rocks = CentOS + Rolls&lt;br&gt;Roll软件包包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;base：基本的Rocks Cluster管理工具&lt;/li&gt;
&lt;li&gt;SGE：SUN Grid Engine，集群下作业调度&lt;/li&gt;
&lt;li&gt;HPC：为集群上的并行应用提供运行环境（MPI，PVM）&lt;/li&gt;
&lt;li&gt;area51：分析集群上文件和内核的完整性&lt;/li&gt;
&lt;li&gt;Ganglia：集群监控软件（主流hpc cluster基本都有这个）&lt;/li&gt;
&lt;li&gt;Bio：集群的生物信息学工具&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一般而言，这两种方法只有适用性与便捷性的差异。&lt;br&gt;有一个视频课程 &lt;a href=&quot;http://edu.51cto.com/course/course_id-507.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://edu.51cto.com/course/course_id-507.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　对于操作系统的选择，调研了很多，一般用Red Hat，Centos居多，一方面是社区活跃，一方面是源码开发，资源兼容较多。&lt;br&gt;（MIC开发上基本采用Red Hat，Centos，SUSE，windows也开始有了）&lt;/p&gt;
&lt;p&gt;###2、安装驱动和开发工具。&lt;br&gt;包括IB驱动、编译器、编辑器、调试器、库等。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;并行计算开发环境：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;安装英特尔众核平台软件堆栈(MPSS)，包含各种驱动。&lt;br&gt;&lt;a href=&quot;https://software.intel.com/en-us/articles/intel-manycore-platform-software-stack-mpss#lx34rel&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://software.intel.com/en-us/articles/intel-manycore-platform-software-stack-mpss#lx34rel&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;假如用intel的编译器的话（我们应该是用intel的）：&lt;br&gt;下载安装intel parallel studio xe 2015，包含有性能分析工具、编译器、高性能库、并行编程工具等，对Xeon Phi进行相应的优化和升级。 Cilk Plus，OpenMP，TBB多线程编程技术和向量化技术在Xeon &amp;amp; Xeon Phi上都已实现了，软件开发者无需额外的移植成本。（试用30天）&lt;br&gt;&lt;a href=&quot;https://software.intel.com/en-us/intel-parallel-studio-xe/try-buy&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://software.intel.com/en-us/intel-parallel-studio-xe/try-buy&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;xeon phi与第三方工具是否available，参考Intel FAQ：&lt;br&gt;&lt;a href=&quot;https://software.intel.com/en-us/articles/intel-and-third-party-tools-and-libraries-available-with-support-for-intelr-xeon-phitm&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://software.intel.com/en-us/articles/intel-and-third-party-tools-and-libraries-available-with-support-for-intelr-xeon-phitm&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;###3、配置节点信息存储系统&lt;br&gt;安装NFS、PVFS、Lustre 、Luster、GPFS、SNFS等，一般大型的HPC集群用Lustre能获得更好的性能，但不太适合小集群，小集群可以考虑用NFS和PVFS，但NFS并不是面向并行计算的，推荐用PVFS好一点。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关于Lustre：&lt;/strong&gt;&lt;br&gt;　　一个Lustre文件系统主要包括以下四个组件：管理服务器Management Server(mgs), 元数据服务器Meta Data Target(mdt), 对象存储服务器Object Storge Target(ost) ,客户端Lustre clients(lc)。&lt;br&gt;　　它主要包括三个部分：元数据服务器MDS (Metadata Server)、对象存储服务器OSS (Object Storage Server)和客户端Client。&lt;br&gt;　　正常的启动顺序是：OST -&amp;gt; MDS -&amp;gt; CLIENT&lt;/p&gt;
&lt;p&gt;　　甲骨文产品管理负责人Bob Thome表示：“云文件系统并不是甲骨文首个基于集群文件系统的产品。甲骨文管理着Lustre项目，Lustre更适合于拥有上千台服务器的大规模HPC（高性能计算）部署。云文件系统则更适合于25个节点数左右的小规模部署，尽管Lustre已经通过了多达100个节点的测试。Lustre也可以实现很多相同的功能，但使用门槛较高，安装和配置较为繁琐，并不适合于小规模部署。”&lt;br&gt;　　关于Lustre的博文：&lt;a href=&quot;http://www.cnblogs.com/jpa2/category/384788.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.cnblogs.com/jpa2/category/384788.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;PVFS存在以下不足：&lt;/strong&gt;&lt;br&gt;1）单一管理节点。上面说到过PVFS中只有一个管理节点来管理元数据，当集群系统达到一定的规模之后，管理节点将可能出现过度繁忙的情况，这时管理节点将成为系统瓶颈。&lt;br&gt;2）对数据的存储缺乏容错机制。当某一I/O节点无法工作时，上面的数据将出现不可用的情况。&lt;br&gt;3）静态配置。对PVFS的配置只能在启动前进行，一旦系统运行则不可再更改原先的配置。&lt;/p&gt;
&lt;p&gt;###4、集群管理工具（考虑是否集成了一些组件）&lt;br&gt;　　集群管理工具 (CMT)，它的职能是管理集群。它有多个功能，有的是可选功能。而必须具备的功能包括:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;维护计算节点清单（即集群中包括的节点）。只需通过简单如 /etc/hosts 的，就能复制或通过本地 DNS 发送至每个计算节点&lt;/li&gt;
&lt;li&gt;创建、管理映像或安装在计算节点上的数据包集&lt;/li&gt;
&lt;li&gt;发送映像或数据包到计算节点（一般通过 PXE ）&lt;/li&gt;
&lt;li&gt;执行对计算节点的基本监控（例如，节点工作情况？什么节点发生起落？）&lt;/li&gt;
&lt;li&gt;计算节点电源控制（不是硬性要求，但是强烈推荐）。即远程开启/关闭节点，此功能可以通过各种方法实现，有的方法需要使用增加其他硬件。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;虽然这个功能清单对于有集群经验的人来说显得太简短，但清单所载功能是 CMT真正的核心。具备其他功能也不错，但对集群来说并不是必不可少的。&lt;/p&gt;
&lt;p&gt;　　CMT 包括 Platform OCS、Clustercorp ROCKS+、Microsoft Windows CCS 和平台管理器 (Platform Manager) 、Mon等。&lt;/p&gt;
&lt;p&gt;###5、可选组件：&lt;br&gt;　　集群所需的工具并不多，但有了这些就能实现集群的基本运行。不过，它只能满足 1 个用户或 2 至 3 个用户的需要，此外，要实现全面控制和掌握集群的运行情况。要安装一些可选组件，从技术上虽然是可选项，但是没有这些工具，集群就不具备生产能力。&lt;br&gt;有一些组件可以添加到 CMT 或 CMI 上层。一个有数年管理多个集群经验的人说的，强烈建议您郑重考虑使用以下附加组件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;更加广泛的监控工具，包括集群状态图形视图，例如Ganglia（链接- &lt;a href=&quot;http://ganglia.info/）、Cacti（链接&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://ganglia.info/）、Cacti（链接&lt;/a&gt; - &lt;a href=&quot;http://www.cacti.net/）和&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.cacti.net/）和&lt;/a&gt; Nagios（链接 -&lt;a href=&quot;http://www.nagios.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.nagios.org/&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;报告工具，允许您创建关于集群运行情况的报告&lt;/li&gt;
&lt;li&gt;用户帐户管理工具（允许您在整个集群上创建用户帐号、允许用户设置密码，然后将其传播到集群的所有节点上，允许无密码登录节点，这对于运行 MPI 应用程序是必需的）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;另一个理论上可选，但值得强烈推荐的组件——任务调度器（也被称为资源管理器）任务调度器是一个允许用户提交执行任务、但不参与任务运行的排队系统。任务调度器把提交的任务排成队列，等到资源（即节点）可用时，就开始运行。任务调度器包括：Platform LSF、PBS-Pro 和 MOAB 等。&lt;/p&gt;
&lt;p&gt;###6、测试&lt;br&gt;略&lt;/p&gt;
&lt;p&gt;#三、参考链接：&lt;br&gt;&lt;a href=&quot;http://www.ibm.com/developerworks/cn/linux/l-cluster1/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.ibm.com/developerworks/cn/linux/l-cluster1/&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://zh.community.dell.com/techcenter/w/techcenter_wiki/50&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://zh.community.dell.com/techcenter/w/techcenter_wiki/50&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.hpcblog.com.cn/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.hpcblog.com.cn/&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;附上一张高清MIC图：&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20150324154126054&quot; alt=&quot;这里写图片描述&quot;&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;　　在本文之前，我建议先看完这篇文章：&lt;a href=&quot;http://www.jointforce.com.cn/page/hardware_linux.html&quot;&gt;Linux高性能计算集群 – Beowulf集群&lt;/a&gt;　　&lt;/p&gt;
&lt;p&gt;#一、搭建集群中可能会遇到的问题&lt;/p&gt;
&lt;p&gt;1.集群设计/布局的一大难点就是网络，各家有各家的策略，一般围绕Beowulf变型。&lt;br&gt;2.软件的部署缺乏实操调试，也不能断定这样部署是否成功以及是否优越。&lt;br&gt;3.操作系统的选型以及安装系统、所需软件（包括集群管理工具、驱动软件、能耗监控软件等）的整个流程的手动/自动化部署。&lt;br&gt;
    
    </summary>
    
      <category term="HPC" scheme="http://enjoyhot.github.io/categories/HPC/"/>
    
    
      <category term="HPC" scheme="http://enjoyhot.github.io/tags/HPC/"/>
    
  </entry>
  
  <entry>
    <title>HPC性能测试</title>
    <link href="http://enjoyhot.github.io/2015/03/24/HPC-benchmark/"/>
    <id>http://enjoyhot.github.io/2015/03/24/HPC-benchmark/</id>
    <published>2015-03-24T06:43:00.000Z</published>
    <updated>2017-04-16T14:48:30.638Z</updated>
    
    <content type="html">&lt;p&gt;#一、介绍&lt;/p&gt;
&lt;p&gt;　　说到高性能计算，一般都是利用搭建集群配合加速卡做并行计算实现。但用相同的硬件实现更快的方法，那就是做测试了。比较有名的就是Linpack测试了，Linpack现在在国际上已经成为最流行的用于测试高性能计算机系统浮点性能的benchmark，在高性能领域，就是利用其中的HPL测试进行测试。下面摘一段百科上的解释:&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;　　&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;　　Linpack现在在国际上已经成为最流行的用于测试高性能计算机系统浮点性能的benchmark。通过利用高性能计算机，用高斯消元法求解N元一次稠密线性代数方程组的测试，评价高性能计算机的浮点性能。&lt;br&gt;　　Linpack测试包括三类，Linpack100、Linpack1000和HPL。Linpack100求解规模为100阶的稠密线性代数方程组，它只允许采用编译优化选项进行优化，不得更改代码，甚至代码中的注释也不得修改。Linpack1000要求求解规模为1000阶的线性代数方程组，达到指定的精度要求，可以在不改变计算量的前提下做算法和代码上做优化。HPL即High Performance Linpack，也叫高度并行计算基准测试，它对数组大小N没有限制，求解问题的规模可以改变，除基本算法（计算量）不可改变外，可以采用其它任何优化方法。前两种测试运行规模较小，已不是很适合现代计算机的发展，因此现在使用较多的测试标准为HPL，而且阶次N也是linpack测试必须指明的参数。&lt;br&gt;　　HPL是针对现代并行计算机提出的测试方式。用户在不修改任意测试程序的基础上，可以调节问题规模大小N(矩阵大小)、使用到的CPU数目、使用各种优化方法等来执行该测试程序，以获取最佳的性能。HPL采用高斯消元法求解线性方程组。当求解问题规模为N时，浮点运算次数为(2/3 &lt;em&gt; N^3－2&lt;/em&gt;N^2)。因此，只要给出问题规模N，测得系统计算时间T，峰值=计算量(2/3 &lt;em&gt; N^3－2&lt;/em&gt;N^2)/计算时间T，测试结果以浮点运算每秒（Flops）给出。&lt;br&gt;　　&lt;br&gt;计算峰值：&lt;br&gt;　　随着产品硬件的不断的升级，整个的计算能力也以数量级的速度提升。衡量计算机性能的一个重要指标就是计算峰值，例如浮点计算峰值，它是指计算机每秒钟能完成的浮点计算最大次数。包括理论浮点峰值和实测浮点峰值：&lt;br&gt;　　理论浮点峰值是该计算机理论上能达到的每秒钟能完成浮点计算最大次数，它主要是由CPU的主频决定的，&lt;br&gt;理论浮点峰值=CPU主频×CPU每个时钟周期执行浮点运算的次数×系统中CPU核心数目&lt;br&gt;　　实测浮点峰值是指Linpack测试值，也就是说在这台机器上运行Linpack测试程序，通过各种调优方法得到的最优的测试结果。实际上在实际程序运行过程中，几乎不可能达到实测浮点峰值，更不用说达到理论浮点峰值了。这两个值只是作为衡量机器性能的一个指标，用来表明机器处理能力的一个标尺和潜能的度量。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　此次参加一个高性能的比赛，虽然做的是平台搭建部分，但对此也有些了解。也了解了一下HPCC测试和NAMD测试，下面主要分这两部分来说一下。&lt;/p&gt;
&lt;p&gt;#二、正文&lt;/p&gt;
&lt;h3 id=&quot;1、HPCC&quot;&gt;&lt;a href=&quot;#1、HPCC&quot; class=&quot;headerlink&quot; title=&quot;1、HPCC&quot;&gt;&lt;/a&gt;1、HPCC&lt;/h3&gt;&lt;p&gt; 　　HPCC 全称 HPC Chanllenge Benchmark&lt;/p&gt;
&lt;p&gt;　　Benchmark 是指一组用来评估硬件或者软件相关性能的基准测试程序&lt;/p&gt;
&lt;p&gt;　　HPC Chanllenge Benchmark 由一组benchmark组成，共计7个，分别测试了系统7个方面的性能，这7个分别为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;HPL&lt;/li&gt;
&lt;li&gt;stream&lt;/li&gt;
&lt;li&gt;Random Access&lt;/li&gt;
&lt;li&gt;PTRANS,&lt;/li&gt;
&lt;li&gt;Latency/Bandwidth&lt;/li&gt;
&lt;li&gt;FFT&lt;/li&gt;
&lt;li&gt;DGEMM&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;stream&lt;/strong&gt;：测试内存带宽&lt;br&gt;内存看作是内存控制器与CPU之间的桥梁与仓库。内存的容量决定“仓库”的大小，而内存的带宽决定“桥梁”的宽窄&lt;br&gt;&lt;strong&gt;Random Access&lt;/strong&gt;：测试内存刷新的速率（随机存储中电容器需要刷新）&lt;br&gt;&lt;strong&gt;PTRANS&lt;/strong&gt;：通过多处理器结构中两两之间的通信，来衡量在整个网络的通信能力&lt;br&gt;&lt;strong&gt;Latency/Bandwidth&lt;/strong&gt;：测试延时与带宽&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Latency：8 byte 数据从一个节点到另一个节点所需时间&lt;/li&gt;
&lt;li&gt;Bandwidth：节点间网络通信的带宽&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;HPL&lt;/strong&gt;：测试系统在解线性方程组时进行浮点运算的性能&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;浮点运算：超级计算机应用的场景主要是在科学计算，经常涉及矩阵运算、各种数值模拟等。&lt;/li&gt;
&lt;li&gt;超级计算机经常以FLOPS（每秒浮点运算次数）去衡量计算能力&lt;/li&gt;
&lt;li&gt;HPCC里有3种benchmark是测试浮点计算性能的&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;FFT&lt;/strong&gt;：涉及到双精度一维离散傅里叶变换时，浮点运算的速度&lt;br&gt;&lt;strong&gt;DGEMM&lt;/strong&gt;：在做双精度矩阵乘法时，浮点运算的速度&lt;/p&gt;
&lt;p&gt;HPCC的下载地址见：&lt;a href=&quot;http://icl.cs.utk.edu/hpcc/software/index.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　这个软件13年8月后就没更新了，网上查阅了很多资料，发现使用的人好像也不多，对于高性能计算，大多都是HPL的文章和测试。要想使用好这个软件，需要研读其源代码。&lt;br&gt;　　其中的安装使用方法可参照网站的&lt;strong&gt;FAQ&lt;/strong&gt;以及软件中的&lt;strong&gt;README.html&lt;/strong&gt;&lt;br&gt;　　编译之前，需要下载好相关的库，包括MPI（mpich，mpich2，mvapich，openmpi，platform_mpi，hpmpi……）、MKL/BLAS/GotoBLAS2……、C语言编译器等，前两者集群一般需要自己去找对应的软件，详细配置请自行上网搜一下，和Linpack基本一样。&lt;/p&gt;
&lt;p&gt;###2、NAMD测试&lt;/p&gt;
&lt;p&gt;　　NAMD是一个与分子动力学有关，用来高仿真大型生物分子系统的程序。即生物分子建模程序。&lt;br&gt;　　现提供两个工作负载apoa1, f1atpase&lt;br&gt;　　它们可以从 &lt;a href=&quot;http://www.ks.uiuc.edu/Research/namd/utilities/f1atpase.tar.gz和http://www.ks.uiuc.edu/Research/namd/utilities/apoa1.tar.gz下载。&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.ks.uiuc.edu/Research/namd/utilities/f1atpase.tar.gz和http://www.ks.uiuc.edu/Research/namd/utilities/apoa1.tar.gz下载。&lt;/a&gt;
　　&lt;/p&gt;
&lt;p&gt;至于性能的话，且看图：&lt;br&gt;　　&lt;img src=&quot;http://img.blog.csdn.net/20150324144222556&quot; alt=&quot;http://www.ks.uiuc.edu/Research/namd/performance.html&quot;&gt;&lt;/p&gt;
&lt;p&gt;图片来源：&lt;a href=&quot;http://www.ks.uiuc.edu/Research/namd/performance.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;NAMD 2.8 在天津超算天河-1A上的测试结果：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;表1 每节点不同进程数以及使用不同节点数的NAMD性能（days/ns）比较&lt;/strong&gt;&lt;br&gt;&lt;img src=&quot;http://img.blog.csdn.net/20150324144513425&quot; alt=&quot;数据&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20150324144634870&quot; alt=&quot;这里写图片描述&quot;&gt;&lt;/p&gt;
&lt;p&gt;　　结论：为了在天河上达到性能最优，最佳的方案是使用GPU，并且每个节点开6个进程。参照：&lt;a href=&quot;http://blog.sina.com.cn/s/blog_a43b3cf2010157pz.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;链接&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;#一、介绍&lt;/p&gt;
&lt;p&gt;　　说到高性能计算，一般都是利用搭建集群配合加速卡做并行计算实现。但用相同的硬件实现更快的方法，那就是做测试了。比较有名的就是Linpack测试了，Linpack现在在国际上已经成为最流行的用于测试高性能计算机系统浮点性能的benchmark，在高性能领域，就是利用其中的HPL测试进行测试。下面摘一段百科上的解释:&lt;br&gt;
    
    </summary>
    
      <category term="HPC" scheme="http://enjoyhot.github.io/categories/HPC/"/>
    
    
      <category term="HPC" scheme="http://enjoyhot.github.io/tags/HPC/"/>
    
      <category term="benchmark" scheme="http://enjoyhot.github.io/tags/benchmark/"/>
    
  </entry>
  
  <entry>
    <title>学习感悟</title>
    <link href="http://enjoyhot.github.io/2015/03/19/study-thinking-20150319/"/>
    <id>http://enjoyhot.github.io/2015/03/19/study-thinking-20150319/</id>
    <published>2015-03-19T05:42:00.000Z</published>
    <updated>2017-04-16T14:48:30.682Z</updated>
    
    <content type="html">&lt;h1 id=&quot;社会篇&quot;&gt;&lt;a href=&quot;#社会篇&quot; class=&quot;headerlink&quot; title=&quot;社会篇&quot;&gt;&lt;/a&gt;社会篇&lt;/h1&gt;&lt;p&gt;   走过2014，看得很多是互联网如何在颠覆各个行业。以下说的都是感悟，可能有些无序，多多包含。&lt;/p&gt;
&lt;p&gt;   无论是做科研也好，投入社会工作也罢，在做以互联网技术为核心的技术学习时，都要有一个目标，做出为社会认可的有价值的“产品”，并间接体现为金钱财富。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;   其实，互联网从访问互联网的用户中赚钱，流量即是渠道。曾听过一句话——“有流量就能赚钱”。确实，在各个行业环环相扣的时候，利用“代理”的作用能把流量转化为金钱，也由于这个原因，才使那么多网民孜孜不倦地以合法或不合法的手段游走于因特网各个角落。&lt;/p&gt;
&lt;p&gt;   然而，怎样最高效率地利用流量，叫要看个人的素养，假如我们将单纯上网的网民比作现实中普通的消费者，那么单纯利用流量赚钱可以比作打工者，而管理某个访问点的可以比作房东，那么房地产，设计师又如何？那需要有强大编程功底的各个阶层的创作者来担任了。从做服务，到做标准，互联网是另一个世界，虚拟而却又像现实生活中那样分工明确，生活着。&lt;/p&gt;
&lt;p&gt;   在这里，我相信都想往高处走，做创作者。但这里我有个发现，能做到标准的少之又少，多数成功者，走的却是先往高处走，当走到一定规模后，市场足够大，再往低处走，做稳定发展的打算。之后有余力再在高处不断试探，不断阶梯式上升，建造更高的高峰。&lt;/p&gt;
&lt;p&gt;   14年相比13年又可以称为互联网的爆炸阶段，不管是从从业的数量来看还是从创业的数量来看。一切的发展归根到底都是为了服务人类生活，往更便捷更智能更廉价发展。&lt;/p&gt;
&lt;p&gt;   因此，才涌现了更方便的产品，更智能的算法，更高速的计算。&lt;/p&gt;
&lt;p&gt;   #热点篇&lt;/p&gt;
&lt;p&gt;   更方便的产品，更智能的算法，更高速的计算，既是相对分开，却又是一脉相承，任何一个领域都可以颠覆另一个领域，当然，最终体现在产品上， 因而产品领域是最活跃的，门槛相对低的情况下又与金钱结合得最为紧密。而超算方面一直以来都比较冷门，毕竟门槛高，又与硬件运算最为相关&lt;/p&gt;
&lt;p&gt;   说到产品，苹果、谷歌、Facebook，产品之王|搜索之王|社交之王。&lt;/p&gt;
&lt;p&gt;   说到算法，目前人工智能领域的机器学习，深度学习，还有相关的大数据，云计算等。&lt;/p&gt;
&lt;p&gt;   说到计算，那就是超算，高性能计算，单台配上GPU和MIC可以提升计算能力，或者直接在集群上并行。&lt;/p&gt;
&lt;p&gt;   这三种内容在以后的博客应该都会多多少少体现。&lt;/p&gt;
&lt;p&gt;   #学习篇&lt;/p&gt;
&lt;p&gt;   慢慢啃，从实验到产品，是一个漫长的过程，但所有的收获，都是从test开始的，或许从产品着手不需要多高的理论积累，在这个风口也完全有可能飞得老高，所以才一家家公司冒出来，或者一些资深程序员直接跳出来创业。说实在，最后能将厚积理论勃发在产品的，互联网大公司才做得最好，毕竟资金人力都全了。小公司或者突然强势冒出来，大有盖过大公司风头之势，但大多昙花一现、干不过大公司，最后被收购也不是少例。虽说这样足够混迹互联网圈，但能主导一个潮流，不算是人生的一大乐事吗？&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;社会篇&quot;&gt;&lt;a href=&quot;#社会篇&quot; class=&quot;headerlink&quot; title=&quot;社会篇&quot;&gt;&lt;/a&gt;社会篇&lt;/h1&gt;&lt;p&gt;   走过2014，看得很多是互联网如何在颠覆各个行业。以下说的都是感悟，可能有些无序，多多包含。&lt;/p&gt;
&lt;p&gt;   无论是做科研也好，投入社会工作也罢，在做以互联网技术为核心的技术学习时，都要有一个目标，做出为社会认可的有价值的“产品”，并间接体现为金钱财富。&lt;/p&gt;
    
    </summary>
    
      <category term="Life" scheme="http://enjoyhot.github.io/categories/Life/"/>
    
    
      <category term="Life" scheme="http://enjoyhot.github.io/tags/Life/"/>
    
  </entry>
  
  <entry>
    <title>【machine learning】KNN算法        </title>
    <link href="http://enjoyhot.github.io/2015/02/25/machinelearning-KNN/"/>
    <id>http://enjoyhot.github.io/2015/02/25/machinelearning-KNN/</id>
    <published>2015-02-25T08:04:00.000Z</published>
    <updated>2017-04-16T14:48:30.654Z</updated>
    
    <content type="html">&lt;p&gt;适逢学习机器学习基础知识，就将书中内容读读记记，本博文代码参考书本Machine Learning in Action（《机器学习实战》）。&lt;/p&gt;
&lt;h1 id=&quot;一、概述&quot;&gt;&lt;a href=&quot;#一、概述&quot; class=&quot;headerlink&quot; title=&quot;一、概述&quot;&gt;&lt;/a&gt;一、概述&lt;/h1&gt;&lt;p&gt;kNN算法又称为k近邻分类(k-nearest neighbor classification)算法。&lt;/p&gt;
&lt;p&gt;kNN算法则是从训练集中找到和新数据最接近的k条记录，然后根据他们的主要分类来决定新数据的类别。该算法涉及3个主要因素：训练集、距离或相似的衡量、k的大小。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;二、算法要点&quot;&gt;&lt;a href=&quot;#二、算法要点&quot; class=&quot;headerlink&quot; title=&quot;二、算法要点&quot;&gt;&lt;/a&gt;二、算法要点&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;1、指导思想&lt;/strong&gt;&lt;br&gt;kNN算法的指导思想是“近朱者赤，近墨者黑”，由你的邻居来推断出你的类别。&lt;/p&gt;
&lt;p&gt;计算步骤如下：&lt;br&gt;1）算距离：给定测试对象，计算它与训练集中的每个对象的距离&lt;br&gt;2）找邻居：圈定距离最近的k个训练对象，作为测试对象的近邻&lt;br&gt;3）做分类：根据这k个近邻归属的主要类别，来对测试对象分类&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、距离或相似度的衡量&lt;/strong&gt;&lt;br&gt;什么是合适的距离衡量？距离越近应该意味着这两个点属于一个分类的可能性越大。&lt;br&gt;距离衡量包括欧式距离、夹角余弦等。&lt;br&gt;对于文本分类来说，使用余弦(cosine)来计算相似度就比欧式(Euclidean)距离更合适。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、类别的判定&lt;/strong&gt;&lt;br&gt;投票决定：少数服从多数，近邻中哪个类别的点最多就分为该类，属于以频率为标准。&lt;br&gt;加权投票法：根据距离的远近，对近邻的投票进行加权，距离越近则权重越大（权重为距离平方的倒数），属于以量化为标准。&lt;/p&gt;
&lt;h1 id=&quot;三、优缺点&quot;&gt;&lt;a href=&quot;#三、优缺点&quot; class=&quot;headerlink&quot; title=&quot;三、优缺点&quot;&gt;&lt;/a&gt;三、优缺点&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;1、优点&lt;/strong&gt;&lt;br&gt;简单，易于理解，易于实现，无需估计参数，无需训练&lt;br&gt;适合对稀有事件进行分类（例如当流失率很低时，比如低于0.5%，构造流失预测模型）&lt;br&gt;特别适合于多分类问题(multi-modal,对象具有多个类别标签)，例如根据基因特征来判断其功能分类，kNN比SVM的表现要好&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、缺点&lt;/strong&gt;&lt;br&gt;懒惰算法，对测试样本分类时的计算量大，内存开销大，评分慢&lt;br&gt;可解释性较差，无法给出决策树那样的规则。&lt;/p&gt;
&lt;h1 id=&quot;四、利用KNN进行手写识别&quot;&gt;&lt;a href=&quot;#四、利用KNN进行手写识别&quot; class=&quot;headerlink&quot; title=&quot;四、利用KNN进行手写识别&quot;&gt;&lt;/a&gt;四、利用KNN进行手写识别&lt;/h1&gt;&lt;p&gt;假如存在训练数据，都是二值得灰度图，来源于手写面板的采集图像数据。如下表示数字‘0’，所在文件夹下包括表示0~9的文件，文件夹命名A_B.txt,A表示真实数字，B表示该数字的第B个样本（一般数据越多有有利于接近预测值）&lt;/p&gt;
&lt;p&gt;   &lt;img src=&quot;http://img.blog.csdn.net/20150225162324294?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ3VndWd1amlhd2Vp/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center&quot; alt=&quot;image_mark&quot;&gt;&lt;/p&gt;
&lt;p&gt; 在另一个文件夹中，也存在同样命名的数据文件，用于检验有监督学习下的准确率，我们称为测试数据。&lt;br&gt;在代码中，我们需要三个函数&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;def classify0(inX, dataSet, labels, k)——用于对输入单个样本inX进行分类，dataSet为训练数据，labels为训练数据的类别，K为近邻范围&lt;br&gt;def img2vector(filename)——将文件filename中的数据规格由32X32转换为1X1024的向量&lt;br&gt;def handwritingClassTest()——利用测试数据进行测试，得出错误率&lt;br&gt;我这里只用了0~9分别20个训练数据而已，提高速度。需要源代码可以到机器学习实战的配套代码中取&lt;br&gt;  &lt;a href=&quot;http://vdisk.weibo.com/s/uEZesAafcjQgx?sudaref=www.baidu.com&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://vdisk.weibo.com/s/uEZesAafcjQgx?sudaref=www.baidu.com&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;代码中用到了numpy库，numpy库用在数据量大的计算较高效&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;numpy用法小抄：&lt;/strong&gt;&lt;br&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;tile([&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;], (&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;))&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;array([[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]])&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;tile([&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;], (&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;))&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;array([[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;],&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;       [&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]])&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;`&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;第一个是矩阵A&lt;br&gt;第二个参数是要 只有一个数字时，表示 对 A中元素重复的次数&lt;br&gt;两个参数时（x， y） y表示对A中元素重复的次数， x表示 对前面的操作执行x次。&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;b= np.arange(&lt;span class=&quot;number&quot;&gt;12&lt;/span&gt;).reshape(&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;b&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;array([[ &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;],&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;           [ &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;],&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;           [ &lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;9&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;11&lt;/span&gt;]])&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;b.sum(axis=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) &lt;span class=&quot;comment&quot;&gt;# 计算每一列的和，注意理解轴的含义，参考数组的第一篇文章&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;array([&lt;span class=&quot;number&quot;&gt;12&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;15&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;18&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;21&lt;/span&gt;])&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;b.min(axis=&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;) &lt;span class=&quot;comment&quot;&gt;# 获取每一行的最小值&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;array([&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;])&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;b.cumsum(axis=&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;) &lt;span class=&quot;comment&quot;&gt;# 计算每一行的累积和&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;array([[ &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;],&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;           [ &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;9&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;15&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;22&lt;/span&gt;],&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;           [ &lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;17&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;27&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;38&lt;/span&gt;]])&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;需要用到再另外写博客进行补充。&lt;br&gt;KNN.py&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;23&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;24&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;25&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;26&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;27&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;28&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;29&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;30&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;31&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;32&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;33&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;34&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;35&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;36&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;37&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;38&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;39&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;40&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;41&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;42&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;43&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;44&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;45&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;46&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;47&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;48&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;49&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;50&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;51&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;52&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;53&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;54&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;55&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;56&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;57&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;58&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;59&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;60&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;61&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;62&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;63&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;64&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;65&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;66&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#! /usr/bin/env python&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#coding=utf-8&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; numpy &lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; *&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; operator&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; os &lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; listdir&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;classify0&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(inX, dataSet, labels, k)&lt;/span&gt;:&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;#inX------[x,x,x,x]&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;#dataSet------array([[x,x,x,x],[x,x,x,x]])&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;#labels------[x,x]&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;#k------n&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    dataSetSize = dataSet.shape[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    diffMat = tile(inX, (dataSetSize,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)) - dataSet&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    sqDiffMat = diffMat**&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    sqDistances = sqDiffMat.sum(axis=&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    distances = sqDistances**&lt;span class=&quot;number&quot;&gt;0.5&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    sortedDistIndicies = distances.argsort()&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    classCount=&amp;#123;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; range(k):&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        voteIlabel = labels[sortedDistIndicies[i]]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        classCount[voteIlabel] = classCount.get(voteIlabel,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;#将字典按value值大小降序排序,结果为二维列表&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    sortedClassCount = sorted(classCount.iteritems(), key=operator.itemgetter(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;), reverse=&lt;span class=&quot;keyword&quot;&gt;True&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; sortedClassCount[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;][&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;img2vector&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(filename)&lt;/span&gt;:&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    returnVect = zeros((&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1024&lt;/span&gt;))&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    fr = open(filename,&lt;span class=&quot;string&quot;&gt;&#39;r&#39;&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; range(&lt;span class=&quot;number&quot;&gt;32&lt;/span&gt;):&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        lineStr = fr.readline()&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; j &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; range(&lt;span class=&quot;number&quot;&gt;32&lt;/span&gt;):&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            returnVect[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;32&lt;/span&gt;*i+j] = int(lineStr[j])&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; returnVect&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;trainFile = &lt;span class=&quot;string&quot;&gt;&#39;F:\\python\\pyproject\\ML\\codes\\machinelearninginaction\\Ch02\\training20\\&#39;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;testFile = &lt;span class=&quot;string&quot;&gt;&#39;F:\\python\\pyproject\\ML\\codes\\machinelearninginaction\\Ch02\\testDigits\\&#39;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;handwritingClassTest&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;:&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    hwLabels = []&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    trainingFileList = listdir(trainFile)           &lt;span class=&quot;comment&quot;&gt;#load the training set&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    m = len(trainingFileList)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    trainingMat = zeros((m,&lt;span class=&quot;number&quot;&gt;1024&lt;/span&gt;))&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; range(m):&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        fileNameStr = trainingFileList[i]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        fileStr = fileNameStr.split(&lt;span class=&quot;string&quot;&gt;&#39;.&#39;&lt;/span&gt;)[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]     &lt;span class=&quot;comment&quot;&gt;#take off .txt&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        classNumStr = int(fileStr.split(&lt;span class=&quot;string&quot;&gt;&#39;_&#39;&lt;/span&gt;)[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;])&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        hwLabels.append(classNumStr)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        path = trainFile + &lt;span class=&quot;string&quot;&gt;&#39;%s&#39;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        trainingMat[i,:] = img2vector(path % fileNameStr)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    testFileList = listdir(testFile)        &lt;span class=&quot;comment&quot;&gt;#iterate through the test set&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    errorCount = &lt;span class=&quot;number&quot;&gt;0.0&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    mTest = len(testFileList)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; range(mTest):&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        fileNameStr = testFileList[i]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        fileStr = fileNameStr.split(&lt;span class=&quot;string&quot;&gt;&#39;.&#39;&lt;/span&gt;)[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]     &lt;span class=&quot;comment&quot;&gt;#take off .txt&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        classNumStr = int(fileStr.split(&lt;span class=&quot;string&quot;&gt;&#39;_&#39;&lt;/span&gt;)[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;])&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        path = testFile + &lt;span class=&quot;string&quot;&gt;&#39;%s&#39;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        vectorUnderTest = img2vector(path % fileNameStr)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        classifierResult = classify0(vectorUnderTest, trainingMat, hwLabels, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;the classifier came back with: %d, the real answer is: %d&quot;&lt;/span&gt; % (classifierResult, classNumStr)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (classifierResult != classNumStr): errorCount += &lt;span class=&quot;number&quot;&gt;1.0&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;\nthe total number of errors is: %d&quot;&lt;/span&gt; % errorCount&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;\nthe total error rate is: %f&quot;&lt;/span&gt; % (errorCount/float(mTest))&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt; 再在test.py中调用KNN.handwritingClassTest()，则程序开始运行&lt;/p&gt;
&lt;p&gt;  test.py&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#! /usr/bin/env python&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#coding=utf-8&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; KNN&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;KNN.handwritingClassTest()&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt; 可看到错误率10.68%，挺高的，增加训练数据量就应该会减小一些。&lt;/p&gt;
&lt;p&gt;  &lt;img src=&quot;http://img.blog.csdn.net/20150225165135118?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ3VndWd1amlhd2Vp/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center&quot; alt=&quot;image_mark&quot;&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;适逢学习机器学习基础知识，就将书中内容读读记记，本博文代码参考书本Machine Learning in Action（《机器学习实战》）。&lt;/p&gt;
&lt;h1 id=&quot;一、概述&quot;&gt;&lt;a href=&quot;#一、概述&quot; class=&quot;headerlink&quot; title=&quot;一、概述&quot;&gt;&lt;/a&gt;一、概述&lt;/h1&gt;&lt;p&gt;kNN算法又称为k近邻分类(k-nearest neighbor classification)算法。&lt;/p&gt;
&lt;p&gt;kNN算法则是从训练集中找到和新数据最接近的k条记录，然后根据他们的主要分类来决定新数据的类别。该算法涉及3个主要因素：训练集、距离或相似的衡量、k的大小。&lt;br&gt;
    
    </summary>
    
      <category term="Machine Learning" scheme="http://enjoyhot.github.io/categories/Machine-Learning/"/>
    
    
      <category term="Machine Learning" scheme="http://enjoyhot.github.io/tags/Machine-Learning/"/>
    
      <category term="Classifier" scheme="http://enjoyhot.github.io/tags/Classifier/"/>
    
  </entry>
  
  <entry>
    <title>网络爬虫框架scrapy介绍及应用——抓取新浪新闻的标题内容评论        </title>
    <link href="http://enjoyhot.github.io/2015/01/21/python-scrapy/"/>
    <id>http://enjoyhot.github.io/2015/01/21/python-scrapy/</id>
    <published>2015-01-21T07:12:00.000Z</published>
    <updated>2017-04-16T14:48:30.674Z</updated>
    
    <content type="html">&lt;h1 id=&quot;一、综述&quot;&gt;&lt;a href=&quot;#一、综述&quot; class=&quot;headerlink&quot; title=&quot;一、综述&quot;&gt;&lt;/a&gt;一、综述&lt;/h1&gt;&lt;p&gt;  开始这篇博文之前，调研了相关的爬虫方法，简单罗列冰山一角。&lt;/p&gt;
&lt;p&gt;  综述：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.crifan.com/summary_about_flow_process_of_fetch_webpage_simulate_login_website_and_some_notice/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.crifan.com/summary_about_flow_process_of_fetch_webpage_simulate_login_website_and_some_notice/&lt;/a&gt;&lt;/p&gt;
 &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;  手动编写爬虫，httpclient是常用工具。常见的请求方式有httpget和httppost&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/mr_tank_/article/details/17454315&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.csdn.net/mr_tank_/article/details/17454315&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/chszs/article/details/16854747&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.csdn.net/chszs/article/details/16854747&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.yeetrack.com/?p=779&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.yeetrack.com/?p=779&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;  这个教程很全面。供参考和备查&lt;/p&gt;
&lt;p&gt;  htmlunit&lt;/p&gt;
&lt;p&gt;  httpclient 对js 的支持比较差，有时候需要使用htmlunit 或者selenium。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.360doc.com/content/13/1229/14/14875906_340995211.shtml&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.360doc.com/content/13/1229/14/14875906_340995211.shtml&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/strawbingo/article/details/5768421&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.csdn.net/strawbingo/article/details/5768421&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/microsoftmvp/p/3716750.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.cnblogs.com/microsoftmvp/p/3716750.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; 抽取相关&lt;br&gt;当爬取了html 后，需要去除噪声广告，抽取有用的信息。jsoup 和tika 是非常强大的工具&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://jsoup.org/cookbook/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://jsoup.org/cookbook/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://summerbell.iteye.com/blog/565922&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://summerbell.iteye.com/blog/565922&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;  github开源爬虫库&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/CrawlScript/WebCollector&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/CrawlScript/WebCollector&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/zhuoran/crawler4j&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/zhuoran/crawler4j&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;  开源爬虫框架nutch&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/xuekyo/archive/2013/04/18/3028559.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.cnblogs.com/xuekyo/archive/2013/04/18/3028559.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://ahei.info/nutch-tutorial.htm&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://ahei.info/nutch-tutorial.htm&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://lc87624.iteye.com/blog/1625677&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://lc87624.iteye.com/blog/1625677&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;  由于要学习python语言，就关注了python爬虫的方法，scrapy框架是个成熟的开源爬虫框架，因此选择其作为学习内容。&lt;br&gt;Scrapy是一个基于Twisted，纯Python实现的爬虫框架，用户只需要定制开发几个模块就可以轻松的实现一个爬虫，用来抓取网页内容、图片、视频等，非常方便。&lt;/p&gt;
&lt;h1 id=&quot;二、scrapy框架&quot;&gt;&lt;a href=&quot;#二、scrapy框架&quot; class=&quot;headerlink&quot; title=&quot;二、scrapy框架&quot;&gt;&lt;/a&gt;二、scrapy框架&lt;/h1&gt;&lt;h2 id=&quot;1、整体架构如下：&quot;&gt;&lt;a href=&quot;#1、整体架构如下：&quot; class=&quot;headerlink&quot; title=&quot;1、整体架构如下：&quot;&gt;&lt;/a&gt;1、整体架构如下：&lt;/h2&gt;&lt;p&gt;   &lt;img src=&quot;http://img.blog.csdn.net/20150121152425667?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ3VndWd1amlhd2Vp/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center&quot; alt=&quot;image_mark&quot;&gt;&lt;/p&gt;
&lt;p&gt; 绿线是数据流向，首先从初始URL 开始，Scheduler 会将其交给 Downloader 进行下载，下载之后会交给 Spider 进行分析，Spider分析出来的结果有两种：一种是需要进一步抓取的链接，&lt;/p&gt;
&lt;p&gt;例如之前分析的“下一页”的链接，这些东西会被传回 Scheduler ；另一种是需要保存的数据，它们则被送到Item Pipeline 那里，那是对数据进行后期处理（详细分析、过滤、存储等）的&lt;/p&gt;
&lt;p&gt;地方。另外，在数据流动的通道里还可以安装各种中间件，进行必要的处理。参考&lt;a href=&quot;http://blog.csdn.net/HanTangSongMing/article/details/24454453&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;br&gt;    博客
   &lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;2、工程文件介绍&quot;&gt;&lt;a href=&quot;#2、工程文件介绍&quot; class=&quot;headerlink&quot; title=&quot;2、工程文件介绍&quot;&gt;&lt;/a&gt;2、工程文件介绍&lt;/h2&gt;&lt;p&gt;假设你已经配置好环境了，进入某个文件夹pythonproject，在命令行中输入&lt;br&gt;scrapy startproject mypro&lt;br&gt;即可在pythonporoject文件夹下找到mypro的工程文件夹，结构如下：&lt;/p&gt;
&lt;p&gt;├── mypro&lt;br&gt;│   ├── mypro&lt;br&gt;│   │   ├── &lt;strong&gt;init&lt;/strong&gt;.py&lt;br&gt;│   │   ├── items.py&lt;br&gt;│   │   ├── pipelines.py&lt;br&gt;│   │   ├── settings.py&lt;br&gt;│   │   └── spiders&lt;br&gt;│   │      └── &lt;strong&gt;init&lt;/strong&gt;.py&lt;br&gt;│   └── scrapy.cfg&lt;/p&gt;
&lt;p&gt;scrapy.cfg: 项目配置文件&lt;br&gt;items.py: 需要提取的数据结构定义文件&lt;br&gt;pipelines.py:管道定义，用来对items里面提取的数据做进一步处理，如保存等&lt;br&gt;settings.py: 爬虫配置文件&lt;/p&gt;
&lt;p&gt;Items是将要装载抓取的数据的容器，它工作方式像python里面的字典，但它提供更多的保护，比如对未定义的字段填充以防止拼写错误。它通过创建一个scrapy.item.Item类来声明&lt;br&gt;，定义它的属性为scrpiy.item.Field对象，就像是一个对象关系映射(ORM)，我们通过将需要的item模型化，来控制从dmoz.org获得的站点数据。虽然这次的实现并没有用到items.py和&lt;/p&gt;
&lt;p&gt;pipelines.py，但大规模的爬虫还是需要注意一下解耦。&lt;br&gt;举个例子：&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; scrapy.item &lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; Item, Field&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;DmozItem&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Item)&lt;/span&gt;:&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    title = Field()&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    link = Field()&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    desc = Field()&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt; 在修改初始化代码时，首先需要在pythonproject//mypro//mypro//spiders下新建一个python文件，原则上所有的实现可以在这个文件里完成，当然耦合度就高了。在这个文件中，你需要新&lt;/p&gt;
&lt;p&gt;建一个类，这个类需要添加以下属性：&lt;br&gt;1、该类继承于某个spider类，根据自己的需求，有很多可以选，如crawSpider，BaseSpider，Spider，XMLFeedSpider，CSVFeedSpider，SitemapSpider等等&lt;br&gt;2、name：爬虫的识别名，它必须是唯一的，在不同的爬虫中你必须定义不同的名字，例如下文的”yourname”&lt;br&gt;3、start_urls：爬虫开始爬的一个URL列表。爬虫从这里开始抓取数据，所以，第一次下载的数据将会从这些URLS开始。其他子URL将会从这些起始URL中继承性生成。&lt;br&gt;4、parse()：爬虫的方法，调用时候传入从每一个URL传回的Response对象作为参数，response将会是parse方法的唯一的一个参数，这个方法负责解析返回的数据、匹配抓取的数据(解析为&lt;/p&gt;
&lt;p&gt;item)并跟踪更多的URL。返回前可以巧妙地运用yield方法递归调用网址，此关键词的作用是返回某个对象后继续执行。如果不用该关键字，则直接会在函数中返回。&lt;/p&gt;
&lt;p&gt;一般而言，运用scrapy的步骤是这样的：&lt;br&gt;1、在pythonproject//mypro//mypro//spiders下新建一个python文件&lt;br&gt;2、导入该导入的库文件，新建一个类满足以上要求。&lt;br&gt;3、根据继承的类的要求和功能，定义爬取规则。&lt;br&gt;4、在def parse(self, response)函数中对response对象解析，将需要的内容存入item对象并返回，在这里对数据不返回而是进行进一步处理也是可以的，耦合度高。&lt;br&gt;5、PipeLine用来对Spider返回的Item列表进行保存操作，可以写入到文件、或者数据库等。PipeLine只有一个需要实现的方法：process_item。&lt;br&gt;万事具备之后，通过命令行进入pythonproject//mypro文件夹中，敲下命令行开始爬虫&lt;br&gt;scrapy crawl “yourname”&lt;br&gt;scrapy命令罗列几个，要更多请参看&lt;a href=&quot;http://scrapy-chs.readthedocs.org/zh_CN/0.24/topics/commands.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;doc&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;scrapy startproject xxx&lt;/code&gt; 新建一个xxx的project&lt;/li&gt;
&lt;li&gt;&lt;code&gt;scrapy crawl xxx&lt;/code&gt; 开始爬取，必须在project中&lt;/li&gt;
&lt;li&gt;&lt;code&gt;scrapy shell url&lt;/code&gt; 在scrapy的shell中打开url，非常实用&lt;/li&gt;
&lt;li&gt;&lt;code&gt;scrapy runspider &amp;lt;spider_file.py&amp;gt;&lt;/code&gt; 可以在没有project的情况下运行爬虫&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;三、新浪新闻爬虫&quot;&gt;&lt;a href=&quot;#三、新浪新闻爬虫&quot; class=&quot;headerlink&quot; title=&quot;三、新浪新闻爬虫&quot;&gt;&lt;/a&gt;三、新浪新闻爬虫&lt;/h1&gt;&lt;p&gt;众所周知，评论一般是隐藏起来的，或者显示部分，需要手动点击加载去获取更多评论。有两种方法可以解决这种方法，一种是利用js动态解析，工作量大，也比较难实现，二是直接定位到其查询数据库的url，直接抽取。下文就是讲第二种方法。&lt;br&gt;新浪页面导航为我们简单分好类了&lt;a href=&quot;http://news.sina.com.cn/guide/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://news.sina.com.cn/guide/&lt;/a&gt;，而且每个类别中都可以找到相应的滚动新闻（url冠以roll），因而没必要用到crawSpider这个类，这个类功能很强大，不仅可以自动去重，还可以定义更多的爬取规则。例如这个链接&lt;a href=&quot;http://roll.finance.sina.com.cn/finance/zq1/index_1.shtml&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://roll.finance.sina.com.cn/finance/zq1/index_1.shtml&lt;/a&gt;，通过修改数字可以实现不断爬取对于新闻的url，当然没有这么“好”的url也是可以找到新闻的url。例如：&lt;a href=&quot;http://sports.sina.com.cn/nba/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://sports.sina.com.cn/nba/&lt;/a&gt;&lt;br&gt;可以调用的浏览器的开发工具查找对应的js代码，查看数据库的url，之后在查看评论的时候也是这样的方法（点击刷新即可）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20150121163439093?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ3VndWd1amlhd2Vp/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center&quot; alt=&quot;image_mark&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20150121163529857?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ3VndWd1amlhd2Vp/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center&quot; alt=&quot;image_mark&quot;&gt;&lt;/p&gt;
&lt;p&gt; 访问这个&lt;a href=&quot;http://feed.mix.sina.com.cn/api/roll/tags?channelid=6&amp;amp;sq=x_where:digit_cl==399872&amp;amp;begin=1401552000&amp;amp;tags=%E6%B9%96%E4%BA%BA%2C%E9%AA%91%E5%A3%AB%2C%E7%81%AB%E7%AE%AD%2C%E8%A9%B9%E5%A7%86%E6%96%AF%2C%E7%A7%91%E6%AF%94&amp;amp;num=30&amp;amp;lid=-3000&amp;amp;versionNumber=1.2.4&amp;amp;page=4&amp;amp;encode=utf-8&amp;amp;callback=feedCardJsonpCallback&amp;amp;_=1421828921159&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;链接&lt;/a&gt;可以查看url&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20150121163516500?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ3VndWd1amlhd2Vp/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center&quot; alt=&quot;image_mark&quot;&gt;&lt;/p&gt;
&lt;p&gt;   因此，访问这个&lt;a href=&quot;http://roll.finance.sina.com.cn/finance/zq1/index_1.shtml&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;链接&lt;/a&gt;的内容，爬取新闻url,访问新闻并爬取标题、内容、评论。&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;23&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;24&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;25&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;26&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;27&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;28&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;29&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;30&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;31&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;32&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;33&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;34&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;35&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;36&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;37&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;38&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;39&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;40&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;41&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;42&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;43&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;44&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;45&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;46&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;47&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;48&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;49&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;50&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;51&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;52&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;53&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;54&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;55&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;56&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;57&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;58&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;59&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;60&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;61&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;62&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;63&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;64&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;65&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;66&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;67&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;68&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;69&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;70&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;71&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;72&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;73&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;74&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;75&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;76&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;77&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;78&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;79&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;80&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;81&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;82&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;83&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;84&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;85&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;86&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;87&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;88&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;89&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;90&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;91&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;92&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;93&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;94&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;95&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;96&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;97&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;98&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;99&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;100&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;101&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;102&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;103&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;104&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;105&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;106&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;107&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;108&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;109&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;110&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;111&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;112&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;113&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;114&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;115&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;116&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;117&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;118&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;119&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;120&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;121&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;122&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;123&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;124&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;125&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;126&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;127&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;128&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;129&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;130&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;131&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;132&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;133&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;134&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;135&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;136&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;137&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;138&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;139&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;140&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;141&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;142&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;143&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;144&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;145&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;146&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;147&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;148&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;149&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;150&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;151&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;152&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;153&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;154&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;155&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;156&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;157&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;158&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;159&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;160&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;161&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;162&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;163&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;164&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;165&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;166&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;167&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;168&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;169&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;170&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;171&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;172&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;173&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;174&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;175&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;176&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;177&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;178&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;179&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;180&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;181&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;182&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;183&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;184&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;185&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;186&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;187&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;188&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;189&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;190&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;191&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;192&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;193&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;194&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;195&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;196&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;197&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;198&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;199&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;200&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;201&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;202&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;203&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;204&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;205&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;206&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;207&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;208&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;209&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;210&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;211&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;212&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;213&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;214&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;215&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;216&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;217&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;218&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;219&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;220&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;221&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;222&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#! /usr/bin/env python&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#coding=utf-8&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; scrapy.selector &lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; Selector&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; scrapy.http &lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; Request&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; re,os&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; bs4 &lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; BeautifulSoup&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; scrapy.spider &lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; Spider&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; urllib2,thread&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#处理编码问题&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; sys&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;reload(sys)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;sys.setdefaultencoding(&lt;span class=&quot;string&quot;&gt;&#39;gb18030&#39;&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#flag的作用是保证第一次爬取的时候不进行单个新闻页面内容的爬取&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;flag=&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;projectpath=&lt;span class=&quot;string&quot;&gt;&#39;F:\\Python27\\pythonproject\\fuck\\&#39;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;loop&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(*response)&lt;/span&gt;:&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        sel = Selector(response[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;])&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;#get title&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        title = sel.xpath(&lt;span class=&quot;string&quot;&gt;&#39;//h1/text()&#39;&lt;/span&gt;).extract()&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;#get pages&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        pages=sel.xpath(&lt;span class=&quot;string&quot;&gt;&#39;//div[@id=&quot;artibody&quot;]//p/text()&#39;&lt;/span&gt;).extract()&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;#get chanel_id &amp;amp; comment_id&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        s=sel.xpath(&lt;span class=&quot;string&quot;&gt;&#39;//meta[@name=&quot;comment&quot;]&#39;&lt;/span&gt;).extract()&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;#comment_id = channel[index+3:index+15]&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        index2=len(response[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;].url)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        news_id=response[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;].url[index2&lt;span class=&quot;number&quot;&gt;-14&lt;/span&gt;:index2&lt;span class=&quot;number&quot;&gt;-6&lt;/span&gt;]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        comment_id=&lt;span class=&quot;string&quot;&gt;&#39;31-1-&#39;&lt;/span&gt;+news_id&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;#评论内容都在这个list中&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        cmntlist=[]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        page=&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;#含有新闻url,标题,内容,评论的文件&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        file2=&lt;span class=&quot;keyword&quot;&gt;None&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;#该变量的作用是当某新闻下存在非手机用户评论时置为False&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        is_all_tel=&lt;span class=&quot;keyword&quot;&gt;True&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;((page==&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;or&lt;/span&gt; (cmntlist != [])):&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            tel_count=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;#each page tel_user_count&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;#提取到的评论url&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            url=&lt;span class=&quot;string&quot;&gt;&quot;http://comment5.news.sina.com.cn/page/info?version=1&amp;amp;format=js&amp;amp;channel=cj&amp;amp;newsid=&quot;&lt;/span&gt;+str(comment_id)+&lt;span class=&quot;string&quot;&gt;&quot;&amp;amp;group=0&amp;amp;compress=1&amp;amp;ie=gbk&amp;amp;oe=gbk&amp;amp;page=&quot;&lt;/span&gt;+str&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;(page)+&lt;span class=&quot;string&quot;&gt;&quot;&amp;amp;page_size=100&quot;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            url_contain=urllib2.urlopen(url).read()&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            b=&lt;span class=&quot;string&quot;&gt;&#39;=&amp;#123;&#39;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            after = url_contain[url_contain.index(b)+len(b)&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;:]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;#字符串中的None对应python中的null，不然执行eval时会出错&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            after=after.replace(&lt;span class=&quot;string&quot;&gt;&#39;null&#39;&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&#39;None&#39;&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;#转换为字典变量text&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            text=eval(after)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;cmntlist&#39;&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; text[&lt;span class=&quot;string&quot;&gt;&#39;result&#39;&lt;/span&gt;]:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                cmntlist=text[&lt;span class=&quot;string&quot;&gt;&#39;result&#39;&lt;/span&gt;][&lt;span class=&quot;string&quot;&gt;&#39;cmntlist&#39;&lt;/span&gt;]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                cmntlist=[]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; cmntlist != [] &lt;span class=&quot;keyword&quot;&gt;and&lt;/span&gt; (page==&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;):&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                filename=str(comment_id)+&lt;span class=&quot;string&quot;&gt;&#39;.txt&#39;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                path=projectpath+&lt;span class=&quot;string&quot;&gt;&#39;stock\\&#39;&lt;/span&gt; +filename&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                file2=open(path,&lt;span class=&quot;string&quot;&gt;&#39;a+&#39;&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                news_content=str(&lt;span class=&quot;string&quot;&gt;&#39;&#39;&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; p &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; pages:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                    news_content=news_content+p+&lt;span class=&quot;string&quot;&gt;&#39;\n&#39;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                item=&lt;span class=&quot;string&quot;&gt;&quot;&amp;lt;url&amp;gt;&quot;&lt;/span&gt;+response[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;].url+&lt;span class=&quot;string&quot;&gt;&quot;&amp;lt;/url&amp;gt;&quot;&lt;/span&gt;+&lt;span class=&quot;string&quot;&gt;&#39;\n\n&#39;&lt;/span&gt;+&lt;span class=&quot;string&quot;&gt;&quot;&amp;lt;title&amp;gt;&quot;&lt;/span&gt;+str(title[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;])+&lt;span class=&quot;string&quot;&gt;&quot;&amp;lt;/title&amp;gt;\n\n&quot;&lt;/span&gt;+&lt;span class=&quot;string&quot;&gt;&quot;&amp;lt;content&amp;gt;\n&quot;&lt;/span&gt;+str(news_content)+&lt;span class=&quot;string&quot;&gt;&quot;&amp;lt;/content&amp;gt;\n\n&amp;lt;comment&amp;gt;\n&quot;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                file2.write(item)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; cmntlist != []:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                content=&lt;span class=&quot;string&quot;&gt;&#39;&#39;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; status_dic &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; cmntlist:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; status_dic[&lt;span class=&quot;string&quot;&gt;&#39;uid&#39;&lt;/span&gt;]!=&lt;span class=&quot;string&quot;&gt;&#39;0&#39;&lt;/span&gt;:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                        is_all_tel=&lt;span class=&quot;keyword&quot;&gt;False&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                        &lt;span class=&quot;comment&quot;&gt;#这一句视编码情况而定，在这里去掉decode和encode也行&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                        s=status_dic[&lt;span class=&quot;string&quot;&gt;&#39;content&#39;&lt;/span&gt;].decode(&lt;span class=&quot;string&quot;&gt;&#39;UTF-8&#39;&lt;/span&gt;).encode(&lt;span class=&quot;string&quot;&gt;&#39;GBK&#39;&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                        &lt;span class=&quot;comment&quot;&gt;#见另一篇博客“三张图”&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                        s=s.replace(&lt;span class=&quot;string&quot;&gt;&quot;&#39;&quot;&lt;/span&gt;&lt;span class=&quot;string&quot;&gt;&quot;&#39;&quot;&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&#39;&quot;&#39;&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                        s=s.replace(&lt;span class=&quot;string&quot;&gt;&quot;\n&quot;&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&#39;&#39;&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                        s1=&lt;span class=&quot;string&quot;&gt;&quot;u&#39;&quot;&lt;/span&gt;+s+&lt;span class=&quot;string&quot;&gt;&quot;&#39;&quot;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                        &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt;:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                            ss=eval(s1)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                        &lt;span class=&quot;keyword&quot;&gt;except&lt;/span&gt;:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                            &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt;:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                                s1=&lt;span class=&quot;string&quot;&gt;&#39;u&quot;&#39;&lt;/span&gt;+s+&lt;span class=&quot;string&quot;&gt;&#39;&quot;&#39;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                                ss=eval(s1)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                            &lt;span class=&quot;keyword&quot;&gt;except&lt;/span&gt;:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                                &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                        content=content+status_dic[&lt;span class=&quot;string&quot;&gt;&#39;time&#39;&lt;/span&gt;]+&lt;span class=&quot;string&quot;&gt;&#39;\t&#39;&lt;/span&gt;+status_dic[&lt;span class=&quot;string&quot;&gt;&#39;uid&#39;&lt;/span&gt;]+&lt;span class=&quot;string&quot;&gt;&#39;\t&#39;&lt;/span&gt;+ss+&lt;span class=&quot;string&quot;&gt;&#39;\n&#39;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                    &lt;span class=&quot;comment&quot;&gt;#当属于手机用户时&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                    &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                        tel_count=tel_count+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                &lt;span class=&quot;comment&quot;&gt;#当一个page下不都是手机用户时，这里也可以用is_all_tel进行判断，一种是用开关的方式，一种是统计的方式&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                &lt;span class=&quot;comment&quot;&gt;#算了不改了&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; tel_count!=len(cmntlist):&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                    file2.write(content)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            page=page+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;#while loop end here&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; file2!=&lt;span class=&quot;keyword&quot;&gt;None&lt;/span&gt;:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;#当都是手机用户时，移除文件，否则写入&quot;&amp;lt;/comment&amp;gt;&quot;到文件尾&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; is_all_tel:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                file2.close()&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt;:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                    os.remove(file2.name)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;except&lt;/span&gt; WindowsError:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                    &lt;span class=&quot;keyword&quot;&gt;pass&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                file2.write(&lt;span class=&quot;string&quot;&gt;&quot;&amp;lt;/comment&amp;gt;&quot;&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                file2.close()&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;DmozSpider&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Spider)&lt;/span&gt;:&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    name = &lt;span class=&quot;string&quot;&gt;&quot;stock&quot;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    allowed_domains = [&lt;span class=&quot;string&quot;&gt;&quot;sina.com.cn&quot;&lt;/span&gt;]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;#在本程序中，start_urls并不重要，因为并没有解析&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    start_urls = [&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;string&quot;&gt;&quot;http://news.sina.com.cn/&quot;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    ]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;global&lt;/span&gt; projectpath&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; os.path.exists(projectpath+&lt;span class=&quot;string&quot;&gt;&#39;stock&#39;&lt;/span&gt;):&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;pass&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        os.mkdir(projectpath+&lt;span class=&quot;string&quot;&gt;&#39;stock&#39;&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;parse&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(self, response)&lt;/span&gt;:&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;#这个scrapy.selector.Selector是个不错的处理字符串的类，python对编码很严格，它却处理得很好&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;#在做这个爬虫的时候，碰到很多奇奇怪怪的编码问题，主要是中文，试过很多既有的类，BeautifulSoup处理得也不是很好&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        sel = Selector(response)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;global&lt;/span&gt; flag&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(flag==&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;):&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            flag=&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            page=&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; page&amp;lt;&lt;span class=&quot;number&quot;&gt;260&lt;/span&gt;:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                url=&lt;span class=&quot;string&quot;&gt;&quot;http://roll.finance.sina.com.cn/finance/zq1/index_&quot;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                url=url+str(page)+&lt;span class=&quot;string&quot;&gt;&quot;.shtml&quot;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                &lt;span class=&quot;comment&quot;&gt;#伪装为浏览器&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                user_agent = &lt;span class=&quot;string&quot;&gt;&#39;Mozilla/4.0 (compatible; MSIE 5.5; Windows NT)&#39;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                headers = &amp;#123; &lt;span class=&quot;string&quot;&gt;&#39;User-Agent&#39;&lt;/span&gt; : user_agent &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                req = urllib2.Request(url, headers=headers)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                response = urllib2.urlopen(req)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                url_contain = response.read()&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                &lt;span class=&quot;comment&quot;&gt;#利用BeautifulSoup进行文档解析&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                soup = BeautifulSoup(url_contain)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                params = soup.findAll(&lt;span class=&quot;string&quot;&gt;&#39;div&#39;&lt;/span&gt;,&amp;#123;&lt;span class=&quot;string&quot;&gt;&#39;class&#39;&lt;/span&gt;:&lt;span class=&quot;string&quot;&gt;&#39;listBlk&#39;&lt;/span&gt;&amp;#125;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; os.path.exists(projectpath+&lt;span class=&quot;string&quot;&gt;&#39;stock\\&#39;&lt;/span&gt;+&lt;span class=&quot;string&quot;&gt;&#39;link&#39;&lt;/span&gt;):&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                     &lt;span class=&quot;keyword&quot;&gt;pass&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                     os.mkdir(projectpath+&lt;span class=&quot;string&quot;&gt;&#39;stock\\&#39;&lt;/span&gt;+&lt;span class=&quot;string&quot;&gt;&#39;link&#39;&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                filename=&lt;span class=&quot;string&quot;&gt;&#39;link.txt&#39;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                path=projectpath+&lt;span class=&quot;string&quot;&gt;&#39;stock\\link\\&#39;&lt;/span&gt; + filename&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                filelink=open(path,&lt;span class=&quot;string&quot;&gt;&#39;a+&#39;&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; params_item &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; params:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                    persons = params_item.findAll(&lt;span class=&quot;string&quot;&gt;&#39;li&#39;&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; item &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; persons:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                        href=item.find(&lt;span class=&quot;string&quot;&gt;&#39;a&#39;&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                        mil_link= href.get(&lt;span class=&quot;string&quot;&gt;&#39;href&#39;&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                        filelink.write(str(mil_link)+&lt;span class=&quot;string&quot;&gt;&#39;\n&#39;&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                        &lt;span class=&quot;comment&quot;&gt;#递归调用parse,传入新的爬取url&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                        &lt;span class=&quot;keyword&quot;&gt;yield&lt;/span&gt; Request(mil_link, callback=self.parse)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                page=page+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;#对单个新闻页面新建线程进行爬取&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; flag!=&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (response.status != &lt;span class=&quot;number&quot;&gt;404&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;and&lt;/span&gt; (response.status != &lt;span class=&quot;number&quot;&gt;502&lt;/span&gt;):&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                thread.start_new_thread(loop,(response,))&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt; 爬取结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20150121171359378?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ3VndWd1amlhd2Vp/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center&quot; alt=&quot;image_mark&quot;&gt;&lt;/p&gt;
&lt;p&gt;在爬取的过程中要注意三点：&lt;br&gt;1.爬取不要过于频繁，不然可能会被封ip，可以减小爬取的速度，sleep一下，或者更改设置文件，我的在F:\Python27\python\Lib\site-packages\Scrapy-0.24.4-py2.7.egg\scrapy\settings\default_settings.py&lt;br&gt;2.文件夹的文件上限为21845，超过后注意再新建一个文件夹爬取&lt;br&gt;3.线程不能开得太多，不然也可能达到上限，可以考虑用代码现在所开线程的多少或者利用分布式系统&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、综述&quot;&gt;&lt;a href=&quot;#一、综述&quot; class=&quot;headerlink&quot; title=&quot;一、综述&quot;&gt;&lt;/a&gt;一、综述&lt;/h1&gt;&lt;p&gt;  开始这篇博文之前，调研了相关的爬虫方法，简单罗列冰山一角。&lt;/p&gt;
&lt;p&gt;  综述：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.crifan.com/summary_about_flow_process_of_fetch_webpage_simulate_login_website_and_some_notice/&quot;&gt;http://www.crifan.com/summary_about_flow_process_of_fetch_webpage_simulate_login_website_and_some_notice/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="http://enjoyhot.github.io/categories/Python/"/>
    
    
      <category term="Python" scheme="http://enjoyhot.github.io/tags/Python/"/>
    
      <category term="Spider" scheme="http://enjoyhot.github.io/tags/Spider/"/>
    
      <category term="Scrapy" scheme="http://enjoyhot.github.io/tags/Scrapy/"/>
    
  </entry>
  
</feed>
